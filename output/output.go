package output

import (
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path"
	"strings"
	"sync"

	"github.com/lsldigital/gocipe/util"
)

var (
	_tools toolset
)

const (
	//LogSuccess indicates a Success log message type
	LogSuccess = "✅ [Ok]"
	//LogSkipped indicates a Skipped log message type
	LogSkipped = "👻 [Skipped]"
	//LogError indicates a Error log message type
	LogError = "❗️ [Error]"
	//LogInfo indicates a Info log message type
	LogInfo = "🦋 [Info]"

	//WithHeader indicates header to be prepended to file
	WithHeader = true

	//WithoutHeader indicates header not to be prepended to file
	WithoutHeader = false
)

// Output is the implementation
type Output struct {
	verbose                   bool
	messages                  []string
	gofiles                   []string
	success, failure, skipped int
	log                       chan string
}

// toolset represents go tools used by the generators
type toolset struct {
	Go        string
	GoImports string
	Protoc    string
}

func init() {
	initToolset()
}

//New creates a new instance of output with logger started
func New(verbose bool) *Output {
	var out Output
	out.log = make(chan string)
	out.verbose = verbose

	out.log = make(chan string)

	go func() {
		for m := range out.log {
			out.messages = append(out.messages, m)
			if out.verbose {
				log.Println(m)
			}
		}
	}()

	return &out
}

//Write stops listening to messages and writes to file
func (l *Output) Write(path string) {
	close(l.log)

	fmt.Println("\n\n# Summary:")

	if l.skipped > 0 {
		fmt.Printf("%s Skipped %d files\n", LogSkipped, l.skipped)
	}

	if l.success > 0 {
		fmt.Printf("%s Wrote %d files\n", LogSuccess, l.success)
	}

	if l.failure > 0 {
		fmt.Printf("%s Error generating %d files\n", LogError, l.failure)
	}

	err := ioutil.WriteFile(path, []byte(strings.Join(l.messages, "\n")), os.FileMode(0755))

	if err != nil {
		log.Println("Failed to write log file.")
	}

	l.messages = []string{}
}

//Log an entry record
func (l *Output) Log(status, msg string, tokens ...interface{}) {
	entry := status + ` ` + fmt.Sprintf(msg, tokens...)
	l.messages = append(l.messages, entry)
}

//AddGoFile appends go file to slice gofiles
func (l *Output) AddGoFile(name string) {
	l.gofiles = append(l.gofiles, name)
}

// GenerateAndOverwrite deletes a file if exists and then saves it
func (l *Output) GenerateAndOverwrite(component string, template string, filename string, hasHeader bool, data interface{}) {
	var err error
	filename, err = util.GetAbsPath(filename)
	if err != nil {
		l.Log(LogError, "Error resolving absolute path for overwrite <%s>: %s", filename, err)
		l.failure++
	} else if util.FileExists(filename) {
		l.Log(LogInfo, "Deleting existing file <%s>", filename)
		util.DeleteIfExists(filename)
	}

	l.GenerateAndSave(component, template, filename, hasHeader, data)
}

// GenerateAndSave saves a generated file and returns error
func (l *Output) GenerateAndSave(component string, template string, filename string, hasHeader bool, data interface{}) {
	var (
		code     string
		isString bool
		err      error
		mode     os.FileMode = 0755
	)

	filename, err = util.GetAbsPath(filename)
	if err != nil {
		fmt.Println(err)
		l.Log(LogError, "Error resolving absolute path for save <%s>: %s", filename, err)
		l.failure++
		return
	}

	if util.FileExists(filename) {
		l.Log(LogInfo, "Skipping existing file <%s>", filename)
		l.skipped++
		return
	}

	if err = os.MkdirAll(path.Dir(filename), mode); err != nil {
		l.Log(LogError, "Error processing <%s>: %s", filename, err)
		l.failure++
		return
	}

	if code, isString = data.(string); !isString {
		code, err = util.ExecuteTemplate(template, data)
		if err != nil {
			l.Log(LogError, "Error executing template <%s>: %s", filename, err)
			l.failure++
			return
		}
	}

	var header string
	if !hasHeader {
		//no header
	} else if strings.HasSuffix(filename, ".go") {
		header = "// generated by gocipe; DO NOT EDIT\n\n"
	} else if strings.HasSuffix(filename, ".proto") {
		header = "// generated by gocipe; DO NOT EDIT\n\n"
	} else if strings.HasSuffix(filename, ".sql") {
		header = "-- generated by gocipe; DO NOT EDIT\n\n"
	} else if strings.HasSuffix(filename, ".sh") {
		header = "-- generated by gocipe; DO NOT EDIT\n\n"
	}

	err = ioutil.WriteFile(filename, []byte(header+code), mode)
	if err != nil {
		fmt.Println(err)
		l.Log(LogError, "Error writing file <%s>: %s", filename, err)
		l.failure++
		return
	}

	l.Log(LogSuccess, "Wrote file <%s>", filename)
	l.success++

	if strings.HasSuffix(filename, ".go") {
		l.AddGoFile(filename)
	} else if strings.HasSuffix(filename, ".sh") {
		os.Chmod(filename, 0755)
	}
}

// initToolset check if all required tools are present
func initToolset() {
	var (
		err error
		ok  = true
	)

	if wd, err := os.Getwd(); err != nil {
		log.Fatalln("Could not get working directory: ", err)
	} else {
		util.WorkingDir = wd
	}

	_tools.Go, err = exec.LookPath("go")
	if err != nil {
		fmt.Println("Required tool go not found: ", err)
		ok = false
	}

	_tools.GoImports, err = exec.LookPath("goimports")
	if err != nil {
		fmt.Println("Required tool goimports not found: ", err)
		ok = false
	}

	_tools.Protoc, err = exec.LookPath("protoc")
	if err != nil {
		fmt.Println("Required tool protoc not found: ", err)
		ok = false
	}

	_, err = exec.LookPath("protoc-gen-go")
	if err != nil {
		fmt.Println("Required tool protoc-gen-go not found: ", err)
		fmt.Println("Install using go get -u github.com/golang/protobuf/protoc-gen-go")
		ok = false
	}

	cmd := exec.Command("vue", "-V")
	_, err = cmd.CombinedOutput()
	if err != nil {
		fmt.Println("Required tool Vue not found: ", err)
		fmt.Println("Install using: sudo npm install -g @vue/cli")
		ok = false
	}

	if !ok {
		log.Fatalln("Please install above tools before continuing.")
	}
}

// PostProcessGoFiles executes goimports and gofmt on go files that have been generated
func (l *Output) PostProcessGoFiles(r *util.Recipe) {
	if len(l.gofiles) == 0 {
		return
	}

	newProject := !util.FileExists(util.WorkingDir + "/go.mod")

	if newProject {
		fmt.Printf("Running go mod init %s\n", r.ImportPath)
		cmd := exec.Command(_tools.Go, "mod", "init", r.ImportPath)
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
		err := cmd.Run()

		if err != nil {
			fmt.Printf("Error running go mod init %s: %s\n", r.ImportPath, err)
		}
	}

	var wg sync.WaitGroup
	wg.Add(len(l.gofiles))

	for _, file := range l.gofiles {
		go func(file string) {
			defer wg.Done()

			cmd := exec.Command(_tools.GoImports, "-w", file)
			cmd.Stdout = os.Stdout
			cmd.Stderr = os.Stderr
			err := cmd.Run()

			if err != nil {
				fmt.Printf("Error running %s on %s: %s\n", _tools.GoImports, file, err)
				return
			}
		}(file)
	}

	wg.Wait()

	if !newProject {
		fmt.Println("Running go mod tidy")
		cmd := exec.Command(_tools.Go, "mod", "tidy")
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr

		if err := cmd.Run(); err != nil {
			fmt.Printf("Error running go mod tidy: %s\n", err)
		}

		fmt.Println("Running go get")
		cmd = exec.Command(_tools.Go, "get")
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr

		if err := cmd.Run(); err != nil {
			fmt.Printf("Error running go get: %s\n", err)
		}
	}
}

// ProcessProto executes protoc to generate go files from protobuf files
func (l *Output) ProcessProto() {
	var (
		cmd    *exec.Cmd
		err    error
		mode   os.FileMode = 0755
		gopath             = os.Getenv("GOPATH") + "/src/"
	)

	l.Log(LogInfo, "Executing protoc to generate go files...")

	// models.proto
	if !util.FileExists(util.WorkingDir + "/models") {
		if err = os.MkdirAll(util.WorkingDir+"/models", mode); err != nil {

			l.Log(LogError, "Could not create folder <%s>: %s", util.WorkingDir+"/models", err)
			l.failure++

			return
		}
		l.Log(LogInfo, "Created folder: <%s>", util.WorkingDir+"/models")
	}
	cmd = exec.Command(
		_tools.Protoc,
		`-I=`+util.WorkingDir+`/proto`,
		util.WorkingDir+`/proto/models.proto`,
		`--go_out=plugins=grpc:`+gopath,
	)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	err = cmd.Run()

	if err != nil {
		l.Log(LogError, "Error generating proto from models.proto: %s", err)
		l.failure++
		return
	}

	l.Log(LogInfo, "Folder created <%s>: %s", util.WorkingDir+"/models")

	// service_admin.proto, if admin service is to be generated
	if util.FileExists(util.WorkingDir + `/proto/service_admin.proto`) {
		if !util.FileExists(util.WorkingDir + "/services/admin") {
			if err = os.MkdirAll(util.WorkingDir+"/services/admin", mode); err != nil {
				l.Log(LogError, "Error creating folder <%s>: %s", util.WorkingDir+"/services/admin", err)
				return
			}
			l.Log(LogError, "Folder created <%s>", util.WorkingDir+"/services/admin")
		}
		cmd = exec.Command(
			_tools.Protoc,
			`-I=`+util.WorkingDir+`/proto`,
			util.WorkingDir+`/proto/service_admin.proto`,
			`--go_out=plugins=grpc:`+gopath,
		)
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
		err = cmd.Run()

		if err != nil {
			return
		}

		l.Log(LogInfo, `Generated go files from service_admin.proto using protoc`)
	}
}

// CreateVue runs "vue create" in web/{subFolder}
func (l *Output) CreateVue(subFolder string) {
	cmd := exec.Command("vue", "create", "--preset", "./preset.json", subFolder)
	cmd.Dir = util.WorkingDir + "/web"
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	err := cmd.Run()
	if err != nil {
		l.Log(LogError, " Could not create Vue project for admin: %s", err)
		return
	}

	util.DeleteIfExists("web/preset.json")
}
