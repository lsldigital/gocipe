package main

import (
	"github.com/GeertJohan/go.rice/embedded"
	"time"
)

func init() {

	// define files
	file3 := &embedded.EmbeddedFile{
		Filename:    "admin/admin_config_upload.go.tmpl",
		FileModTime: time.Unix(1539936852, 0),
		Content:     string("package admin\n\n// UploadPaths is an index of upload options\nvar UploadPaths = map[string]*files.UploadOptions{\n\t{{- range $i, $entity := .Entities}}\n\t{{- range $entity.GetFileFields}}\n\t\"{{lower $entity.Name}}/{{lower .Name}}\":\t&{{$entity.Name}}{{.Name}}UploadOpts,\n\t{{- end}}\n\t{{- end}}\n}\n\n{{range $i, $entity := .Entities -}}\n{{range $entity.GetFileFields }}\n// {{$entity.Name}}{{.Name}}UploadOpts contains upload parameters for the \"{{.Name}}\" field in Entity \"{{$entity.Name}}\"\nvar {{$entity.Name}}{{.Name}}UploadOpts = files.UploadOptions{\n\tDir:\t\t\t\"media\",\n\tDestination:    \"{{lower $entity.Name}}/{{lower .Name}}\",\n\tMediaPrefixURL: \"/media/\",\n\tFileType:       files.TypeImage,\n\tMaxSize:        util.NoLimit,\n\tConvertTo:      imagist.TypeImageJPG,\n\tImgDimensions:  &imagist.ImageDimensions{\n\t\tMinWidth:       util.NoLimit,\n\t\tMinHeight:      util.NoLimit,\n\t\tFormats: []imagist.FormatDimensions{\n\t\t\t{Name: \"thumb\", Width: 400, Height: 200},\n\t\t\t{Name: \"full\", Width: util.NoLimit, Height: util.NoLimit, Watermark: imagist.BottomRight},\n\t\t},\n\t},\n}\n{{end}}\n{{end}}"),
	}
	file4 := &embedded.EmbeddedFile{
		Filename:    "admin/admin_helpers.go.tmpl",
		FileModTime: time.Unix(1538482115, 0),
		Content:     string("package admin\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/gosimple/slug\"\n\t\"{{.ImportPath}}/models\"\n)\n\n// NewBoolFilter returns a new filter for boolean types\nfunc NewBoolFilter(filter *Filter) (*models.Filter, error) {\n\tvalue, err := strconv.ParseBool(filter.Value); \n\t\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &models.Filter{Field: filter.Field, Operation: \"=\", Value: value}, nil\n}\n\n// NewStringFilter returns a new filter for text values\nfunc NewStringFilter(filter *Filter) (*models.Filter, error) {\n\tswitch filter.Operation {\n\tcase \"=\":\n\t\treturn &models.Filter{Field: filter.Field, Operation: \"=\", Value: filter.Value}, nil\n\tcase \"~\":\n\t\treturn &models.Filter{Field: filter.Field, Operation: \"LIKE\", Value: filter.Value}, nil\n\t}\n\n\treturn nil, ErrorInvalidOperation\n}\n\n// NewDateFilter returns a new filter to handle dates\nfunc NewDateFilter(filter *Filter) (*models.Filter, error) {\n\tvar (\n\t\tvalue time.Time\n\t\terr   error\n\t)\n\n\tif value, err = time.Parse(time.RFC3339, filter.Value); err != nil {\n\t\treturn nil, err\n\t}\n\n\tswitch filter.Operation {\n\tcase \"=\":\n\t\treturn &models.Filter{Field: filter.Field, Operation: \"=\", Value: value}, nil\n\tcase \">\":\n\t\treturn &models.Filter{Field: filter.Field, Operation: \">\", Value: value}, nil\n\tcase \">=\":\n\t\treturn &models.Filter{Field: filter.Field, Operation: \">=\", Value: value}, nil\n\tcase \"<\":\n\t\treturn &models.Filter{Field: filter.Field, Operation: \"<\", Value: value}, nil\n\tcase \"<=\":\n\t\treturn &models.Filter{Field: filter.Field, Operation: \"<=\", Value: value}, nil\n\t}\n\n\treturn &models.Filter{Field: filter.Field, Operation: \"LIKE\", Value: value}, nil\n}\n\nfunc setSlug(id string, value string, table string, field string) {\n\tsuffix := \"\"\n\tmax := 10\n\tfor i := 0; i < max; i++ {\n\t\tif i >= max-1 {\n\t\t\tnow := time.Now()\n\t\t\tsuffix = fmt.Sprintf(\"%d\", now.Nanosecond())\n\t\t} else if i > 0 {\n\t\t\tsuffix = fmt.Sprintf(\"%02d\", i)\n\t\t}\n\n\t\ttx, err := models.StartTransaction(context.Background())\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\tslug := slug.Make(value + `-` + suffix)\n\t\trows, err := tx.Query(`SELECT id FROM `+table+` WHERE slug = $1 AND id <> $2 LIMIT 1`, slug, id)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tdefer rows.Close() // Is it safe in a loop?\n\n\t\tvar exist bool\n\t\tfor rows.Next() {\n\t\t\texist = true\n\t\t\tbreak\n\t\t}\n\n\t\tif exist {\n\t\t\ttx.Rollback()\n\t\t\tcontinue\n\t\t}\n\n\t\ttx, err = models.StartTransaction(context.Background())\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\tstmt, err := tx.Prepare(`UPDATE ` + table + ` SET ` + field + ` = $1 WHERE id = $2`)\n\t\tif err != nil {\n\t\t\ttx.Rollback()\n\t\t\tcontinue\n\t\t}\n\n\t\t_, err = stmt.Exec(slug, id)\n\t\tif err != nil {\n\t\t\ttx.Rollback()\n\t\t\tcontinue\n\t\t}\n\n\t\terr = tx.Commit()\n\t\tif err != nil {\n\t\t\ttx.Rollback()\n\t\t\tcontinue\n\t\t}\n\n\t\tbreak\n\t}\n}\n"),
	}
	file5 := &embedded.EmbeddedFile{
		Filename:    "admin/admin_permissions.go.tmpl",
		FileModTime: time.Unix(1539936852, 0),
		Content:     string("package admin\n\nconst (\n    {{range .Permissions}}\n    // {{.Name}} is a permission token to {{.Name}}\n    {{.Name}} = \"{{.Code}}\"\n    {{end}}\n)"),
	}
	file6 := &embedded.EmbeddedFile{
		Filename:    "admin/service_admin.go.tmpl",
		FileModTime: time.Unix(1539936852, 0),
		Content:     string("package admin\n\nimport (\n\t\"github.com/pkg/errors\"\n\t\"golang.org/x/net/context\"\n\t\n\t{{ if .GenerateAuth }}\"{{.ImportPath}}/auth\"{{ end }}\n)\n\nconst (\n\t// StatusDraft says status is 'draft'\n\tStatusDraft = \"draft\"\n\t// StatusSaved says status is 'saved'\n\tStatusSaved = \"saved\"\n\t// StatusUnpublished says status is 'unpublished'\n\tStatusUnpublished = \"unpublished\"\n\t// StatusPublished says status is 'published'\n\tStatusPublished = \"published\"\n)\n\nvar (\n\t// ErrorInvalidOperation indicates an error for an invalid operation\n\tErrorInvalidOperation   = errors.New(\"invalid filter operation specified\")\n\t// ErrorRequestEmpty indicates an error when empty request is received\n\tErrorRequestEmpty       = errors.New(\"request object is malformed\")\n\t// ErrorInvalidUploadField indicates an error for an unknown upload field\n\tErrorInvalidUploadField = errors.New(\"invalid upload field\") \n\t// ErrorInvalidStatus indicates an invalid status has been submitted \n\tErrorInvalidStatus      = errors.New(\"invalid status\")\n\n\t{{ if .GenerateAuth }}_guardian auth.Guardian{{ end }}\n)\n\n{{ if .GenerateAuth }}\n// SetGuardian sets a custom guardian for admin service\n// if guardian is nil, a dummyGuardian is used\nfunc SetGuardian(guardian auth.Guardian) {\n\tif guardian == nil {\n\t\t_guardian = auth.DummyGuard\n\t} else {\n\t\t_guardian = guardian\n\t}\n}\n{{ end }}\n\n// Service represents Admin service implementation\ntype Service struct {}\n\n{{range $i, $entity := .Entities}}\n/**\n * [BEGIN] {{.Name}}\n */\n\n{{if .Admin.Create -}}\n// Create{{.Name}} allows creation of entity of type {{.Name}}\nfunc(s Service) Create{{.Name}}(ctx context.Context, req *Create{{.Name}}Request) (*Create{{.Name}}Response, error) {\n\tvar (\n\t\terr  error\n\t\ttx   *sql.Tx\n\t\tres  Create{{.Name}}Response\n\t\t{{if or .Admin.Hooks.PreCreate .Admin.Hooks.PostCreate -}}\n\t\tstop bool\n\t\t{{- end}}\n\t)\n\n\tif req == nil {\n\t\treturn &res, ErrorRequestEmpty\n\t}\n\n\tif req.{{.Name}} == nil {\n\t\tres.{{.Name}} = new(models.{{.Name}})\n\t} else {\n\t\tres.{{.Name}}    = req.{{.Name}}\n\t\tres.{{.Name}}.ID = {{pkeyPropertyEmptyVal .PrimaryKey}}\n\t}\n\n\t{{ if .Admin.Auth.Generate }}\n\tpassport, err := _guardian.GetPassport(req.GetKey())\n\tif err != nil {\n\t\treturn &res, errors.WithStack(err)\n\t}\n\n\tif hasPerm := passport.HasPermission(res.{{.Name}}, PermCreate{{.Name}}); !hasPerm {\n\t\treturn &res, errors.WithStack(fmt.Errorf(\"Permission denied\")) \n\t}\n\t{{ end }}\n\n\tres.{{.Name}}.Status = StatusDraft\n\n\ttx, err = models.StartTransaction(ctx)\n\t{{if .Admin.Hooks.PreCreate}}\n\tstop, err = s.{{lower .Name}}PreCreate(ctx, tx, req, &res, {{if .Admin.Auth.Generate}}passport, {{end}}err)\n\tif stop {\n\t\treturn &res, nil\n\t}\n\t{{- end}}\n\n\tif err != nil {\n\t\treturn &res, errors.WithStack(err)\n\t}\n\n\terr = models.{{.Name}}Repo.Save(ctx, res.{{.Name}}, tx, true)\n\n\tif err != nil {\n\t\treturn &res, errors.WithStack(err)\n\t}\n\n\t{{if .Admin.Hooks.PostCreate -}}\n\tstop, err = s.{{lower .Name}}PostCreate(ctx, req, &res, err)\n\tif stop {\n\t\treturn &res, nil\n\t}\n\t{{- end}}\n\n\tif err != nil {\n\t\treturn &res, errors.WithStack(err)\n\t}\n\n\treturn &res, errors.WithStack(err)\n}\n{{- end}}\n\n{{if .Admin.Read -}}\n// Get{{.Name}} allows getting a single entity of type {{.Name}}\nfunc(s Service) Get{{.Name}}(ctx context.Context, req *GetRequest) (*Get{{.Name}}Response, error) {\n\tvar (\n\t\tres  Get{{.Name}}Response\n\t\terr  error\n\t\t{{if or .Admin.Hooks.PreRead .Admin.Hooks.PostRead -}}\n\t\tstop bool\n\t\t{{- end}}\n\t)\n\n\tif req == nil || req.ID == \"\" {\n\t\treturn &res, ErrorRequestEmpty\n\t}\n\n\t{{if .Admin.Hooks.PreRead}}\n\tstop, err = s.{{lower .Name}}PreRead(ctx, req, &res)\n\tif stop {\n\t\treturn &res, nil\n\t}\n\t{{- end}}\n\n\tres.{{.Name}}, err = models.{{.Name}}Repo.GetWithRel(ctx, req.ID)\n\n\t{{if .Admin.Hooks.PostRead -}}\n\tstop, err = s.{{lower .Name}}PostRead(ctx, req, &res, err)\n\tif stop {\n\t\treturn &res, nil\n\t}\n\t{{- end}}\n\n\tif err != nil {\n\t\treturn &res, errors.WithStack(err)\n\t}\n\n\treturn &res, nil\n}\n{{- end}}\n\n{{if .Admin.List -}}\n// List{{plural .Name}} allows listing all entity of type {{.Name}}\nfunc(s Service) List{{plural .Name}}(ctx context.Context, req *ListRequest) (*List{{plural .Name}}Response, error) {\n\tvar (\n\t\tres  List{{plural .Name}}Response\n\t\terr  error\n\t\t{{if or .Admin.Hooks.PreList .Admin.Hooks.PostList -}}\n\t\tstop bool\n\t\t{{- end}}\n\t\tfilters []*models.Filter\n\t)\n\n\tif req == nil {\n\t\treturn &res, ErrorRequestEmpty\n\t}\n\n\t{{if .Admin.Hooks.PreList -}}\n\tstop, err = s.{{lower .Name}}PreList(ctx, req, &res)\n\tif stop {\n\t\treturn &res, nil\n\t}\n\t{{- end}}\n\n\tif req.ListOpts == nil {\n\t\treq.ListOpts = &models.ListOpts{Offset: models.NoOffset, Limit: models.NoLimit}\n\t}\n\n\t{{$filters := .GetAdminFilters }}\n\t{{if (or $filters.HasBool $filters.HasString $filters.HasDate)}}\n\tif req.Filters != nil {\n\t\tfor i := range req.Filters {\n\t\t\tswitch req.Filters[i].Field {\n\t\t\t{{if $filters.HasBool}}\n\t\t\tcase {{$filters.BoolFilters}}:\n\t\t\t\tif f, err := NewBoolFilter(req.Filters[i]); err == nil {\n\t\t\t\t\tfilters = append(filters, f)\n\t\t\t\t} else {\n\t\t\t\t\treturn &res, err\n\t\t\t\t}\n\t\t\t{{end}}\n\t\t\t{{if $filters.HasString}}\n\t\t\tcase {{$filters.StringFilters}}:\n\t\t\t\tif f, err := NewStringFilter(req.Filters[i]); err == nil {\n\t\t\t\t\tfilters = append(filters, f)\n\t\t\t\t} else {\n\t\t\t\t\treturn &res, err\n\t\t\t\t}\n\t\t\t{{end}}\n\t\t\t{{if $filters.HasDate}}\n\t\t\tcase {{$filters.DateFilters}}:\n\t\t\t\tif f, err := NewDateFilter(req.Filters[i]); err == nil {\n\t\t\t\t\tfilters = append(filters, f)\n\t\t\t\t} else {\n\t\t\t\t\treturn &res, err\n\t\t\t\t}\n\t\t\t{{end}}\n\t\t\t}\n\t\t}\n\t}\n\t{{end}}\n\n\tres.{{plural .Name}}, err = models.{{.Name}}Repo.List(ctx, req.ListOpts, filters...)\n\tif err != nil {\n\t\treturn &res, errors.WithStack(err)\n\t}\n\n\t{{if .Admin.Hooks.PostList -}}\n\tstop, err = s.{{lower .Name}}PostList(ctx, req, &res, err)\n\tif stop {\n\t\treturn &res, nil\n\t}\n\t{{- end}}\n\t\n\tif err != nil {\n\t\treturn &res, errors.WithStack(err)\n\t}\n\n\treturn &res, nil\n}\n{{- end}}\n\n{{if .Admin.Update -}}\n// Update{{.Name}} allows updating one entity of type {{.Name}}\nfunc(s Service) Update{{.Name}}(ctx context.Context, req *Update{{.Name}}Request) (*Update{{.Name}}Response, error) {\n\tvar (\n\t\terr  error\n\t\ttx   *sql.Tx\n\t\tres  Update{{.Name}}Response\n\t\t{{if or .Admin.Hooks.PreUpdate .Admin.Hooks.PostUpdate -}}\n\t\tstop bool\n\t\t{{- end}}\n\t)\n\n\tif req == nil || req.{{.Name}} == nil {\n\t\treturn &res, ErrorRequestEmpty\n\t}\n\n\t{{ if .Admin.Auth.Generate }}\n\tpassport, err := _guardian.GetPassport(req.GetKey())\n\tif err != nil {\n\t\treturn &res, errors.WithStack(err)\n\t}\n\n\tvar permission string\n\tisOwned := req.{{.Name}}.UserID == passport.GetID()\n\tif isOwned {\n\t\tpermission = PermEdit{{.Name}}\n\t} else {\n\t\tpermission = PermEdit{{.Name}}Any\n\t}\n\n\tif hasPerm := passport.HasPermission(res.{{.Name}}, permission); !hasPerm {\n\t\treturn &res, errors.WithStack(fmt.Errorf(\"Permission denied\")) \n\t}\n\t{{ end }}\n\n\t// existing records in DB\n\texisting, err := models.{{.Name}}Repo.Get(ctx, req.{{.Name}}.ID)\n\tif err != nil {\n\t\t{{if .Admin.Hooks.PreUpdate -}}\n\t\tstop, err = s.{{lower .Name}}PreUpdate(ctx, tx, req, &res, *existing, {{if .Admin.Auth.Generate}}passport, {{end}}err)\n\t\tif stop {\n\t\t\treturn &res, nil\n\t\t}\n\t\t{{end}}\n\t\treturn &res, errors.WithStack(err)\n\t}\n\n\tswitch req.{{.Name}}.Status {\n\t\tcase StatusDraft, StatusSaved, StatusUnpublished, StatusPublished:\n\t\t\t//all good\n\t\tdefault:\n\t\t\treturn &res, ErrorInvalidStatus\n\t}\n\n\tres.{{.Name}} = req.{{.Name}}\n\t{{ range .GetFileFields }}\n\tres.{{$entity.Name}}.{{.Name}} = existing.{{.Name}}\n\t{{end }}\n\t{{ if .Slug}}\n\tres.{{.Name}}.Slug = existing.Slug\n\t{{ end }}\n\ttx, err = models.StartTransaction(ctx)\n\n\t{{if .Admin.Hooks.PreUpdate -}}\n\tstop, err = s.{{lower .Name}}PreUpdate(ctx, tx, req, &res, *existing, {{if .Admin.Auth.Generate}}passport, {{end}}err)\n\tif stop {\n\t\treturn &res, nil\n\t}\n\t{{- end}}\n\n\tif err != nil {\n\t\treturn &res, errors.WithStack(err)\n\t}\n\n\terr = models.{{.Name}}Repo.SaveWithRel(ctx, res.{{.Name}}, tx, true)\n\tif err != nil {\n\t\treturn &res, errors.WithStack(err)\n\t}\n\n\t{{if .Slug}}\n\tgo setSlug(existing.GetID(), req.{{.Name}}.Get{{ucfirst .Slug}}(), \"{{.Table}}\", \"slug\")\n\t{{end}}\n\n\t{{if .Admin.Hooks.PostUpdate -}}\n\tstop, err = s.{{lower .Name}}PostUpdate(ctx, req, &res, *existing, err)\n\tif stop {\n\t\treturn &res, nil\n\t}\n\t{{- end}}\n\n\tif err != nil {\n\t\treturn &res, errors.WithStack(err)\n\t}\n\n\treturn &res, nil\n}\n{{- end}}\n\n{{if .Admin.Delete -}}\n// Delete{{.Name}} allows deleting an entity of type {{.Name}}\nfunc(s Service) Delete{{.Name}}(ctx context.Context, req *DeleteRequest) (*DeleteResponse, error) {\n\tvar (\n\t\terr  error\n\t\ttx   *sql.Tx\n\t\tres  DeleteResponse\n\t\t{{if or .Admin.Hooks.PreDelete .Admin.Hooks.PostDelete -}}\n\t\tstop bool\n\t\t{{- end}}\n\t)\n\n\tif req == nil || req.ID == \"\" {\n\t\treturn &res, ErrorRequestEmpty\n\t}\n\n\t// existing records in DB\n\texisting, err := models.{{.Name}}Repo.Get(ctx, req.ID)\n\tif err != nil {\n\t\t{{if .Admin.Hooks.PreDelete -}}\n\t\tstop, err = s.{{lower .Name}}PreDelete(ctx, tx, req, &res, *existing, err)\n\t\tif stop {\n\t\t\treturn &res, nil\n\t\t}\n\t\t{{end}}\n\t\treturn &res, errors.WithStack(err)\n\t}\n\n\ttx, err = models.StartTransaction(ctx)\n\t{{if .Admin.Hooks.PreDelete}}\n\tstop, err = s.{{lower .Name}}PreDelete(ctx, tx, req, &res, *existing, err)\n\tif stop {\n\t\treturn &res, nil\n\t}\n\t{{- end}}\n\t\n\tif err != nil {\n\t\treturn &res, errors.WithStack(err)\n\t}\n\n\terr = models.{{.Name}}Repo.Delete(ctx, existing, tx, true)\n\tif err != nil {\n\t\treturn &res, errors.WithStack(err)\n\t}\n\n\t{{if .Admin.Hooks.PostDelete}}\n\tstop, err = s.{{lower .Name}}PostDelete(ctx, req, &res, *existing, err)\n\tif stop {\n\t\treturn &res, nil\n\t}\n\t{{- end}}\n\t\n\tif err != nil {\n\t\treturn &res, errors.WithStack(err)\n\t}\n\n\treturn &res, nil\n}\n{{- end}}\n{{if .GetFileFields}}\n// Upload{{.Name}} allows uploading of files for entity of type {{.Name}}\nfunc(s Service) Upload{{.Name}}(ctx context.Context, req *UploadRequest) (*UploadResponse, error) {\n\tvar (\n\t\tres       UploadResponse\n\t\toptions   *files.UploadOptions\n\t\tfieldname string\n\t)\n\n\tif req == nil {\n\t\treturn &res, ErrorRequestEmpty\n\t}\n\n\tswitch req.Field {\n\t\t{{- range (.GetFileFieldsDefinition)}}\n\t\t{{.}}\n\t\t{{- end}}\n\t\tdefault:\n\t\t\treturn &res, ErrorInvalidUploadField\n\t}\n\n\tfileDiskPath, filePath, err := files.Upload(req.Filename, req.Content, options)\n\tif err != nil {\n\t\tif fileDiskPath != \"\" {\n\t\t\tfiles.Delete(fileDiskPath)\n\t\t}\n\t\treturn &res, err\n\t}\n\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tfiles.Delete(fileDiskPath)\n\t\treturn &res, errors.WithStack(err)\n\t}\n\n\ttx, err := models.StartTransaction(ctx)\n\tif err != nil {\n\t\tfiles.Delete(fileDiskPath)\n\t\treturn &res, err\n\t}\n\t\n\tstmt, err := tx.Prepare(`UPDATE {{.Table}} SET `+fieldname+` = $1 WHERE id = $2`)\n\tif err != nil {\n\t\tfiles.Delete(fileDiskPath)\n\t\treturn &res, errors.WithStack(err)\n\t}\n\n\t_, err = stmt.Exec(filePath, req.ID)\n\tif err != nil {\n\t\ttx.Rollback()\n\t\tfiles.Delete(fileDiskPath)\n\t\treturn &res, errors.WithStack(err)\n\t}\n\n\terr = tx.Commit()\n\tres.URI = filePath\n\treturn &res, err\n}\n{{- end}}\n\n// Lookup{{plural .Name}} lookup allows looking up an entity by its label for entity of type {{.Name}}\nfunc(s Service) Lookup{{plural .Name}}(ctx context.Context, req *LookupRequest) (*LookupResponse, error) {\n\tvar (\n\t\terr  error\n\t\trows *sql.Rows\n\t\tres  LookupResponse\n\t)\n\n\tif req == nil {\n\t\treturn &res, ErrorRequestEmpty\n\t}\n\n\ttx, err := models.StartTransaction(ctx)\n\tif err != nil {\n\t\treturn &res, err\n\t}\n    \n\trows, err = tx.Query(`SELECT id, t.\"{{.LabelField}}\", t.\"status\" FROM {{.Table}} t WHERE t.\"{{.LabelField}}\" LIKE $1`, req.Term+\"%\")\n\tif err != nil {\n\t\treturn &res, err\n\t}\n    \n\tdefer rows.Close()\n\tfor rows.Next() {\n\t\tvar id, label, status string\n\t\tif err = util.CheckContext(ctx); err != nil {\n\t\t\treturn &res, err\n\t\t}\n\n\t\terr = rows.Scan(&id, &label, &status)\n\t\tif err != nil {\n\t\t\treturn &res, errors.WithStack(err)\n\t\t}\n    \n\t\tres.Result = append(res.Result, &LookupResult{ID: id, Label: label, Status: status})\n\t}\n\n\treturn &res, err\n}\n/**\n * [END] {{.Name}}\n */\n{{end}}"),
	}
	file7 := &embedded.EmbeddedFile{
		Filename:    "admin/service_admin.proto.tmpl",
		FileModTime: time.Unix(1539936852, 0),
		Content:     string("syntax = \"proto3\";\n\npackage admin;\n\nimport \"models.proto\";\noption go_package = \"{{.ImportPath}}/services/admin\";\n\n// Filter represents a filter that can be applied for listing requests\nmessage Filter {\n    string Field     = 1;\n    string Operation = 2;\n    string Value     = 3;\n}\n\n// GetRequest represents a request to allow getting a single entity\nmessage GetRequest {\n    string Key = 1;\n    string ID = 2;\n}\n\n// ListRequest represents a request to allow listing of entities\nmessage ListRequest {\n    string Key = 1;\n    models.ListOpts ListOpts = 2;\n    repeated admin.Filter Filters = 3;\n}\n\n// DeleteRequest represents a request to allow deleting an entity\nmessage DeleteRequest {\n    string Key = 1;\n    string ID = 2;\n}\n// DeleteResponse represents result to a DeleteRequest\nmessage DeleteResponse {}\n\n// UploadOpts represents message to define upload options of files\nmessage UploadOpts {\n    bool Watermark = 1;\n}\n\n// UploadRequest represents message to allow uploading of files\nmessage UploadRequest {\n    string Key      = 1;\n    string ID       = 2;\n    string Field    = 3;\n    string Filename = 4;\n    bytes  Content  = 5;\n    UploadOpts UploadOptions = 6;\n}\n\n// UploadResponse represents result to an UploadRequest\nmessage UploadResponse {\n    string URI = 1;\n}\n\n// LookupRequest represents a request to lookup an entity by its label\nmessage LookupRequest {\n    string Key  = 1;\n    string Term = 2;\n}\n\n// LookupResult represents one (of many) results for an entity lookup request\nmessage LookupResult {\n    string ID     = 1;\n    string Label  = 2;\n    string Status = 3;\n}\n\n// LookupResponse represents a series of results to a lookup request\nmessage LookupResponse {\n    repeated LookupResult Result = 1;\n}\n\nservice Admin {\n{{- range .Entities}}\n/**\n * [BEGIN SERVICE] {{.Name}}\n */\n    {{- if .Admin.Create}}\n    // Create{{.Name}} allows creation of entity of type {{.Name}}\n    rpc Create{{.Name}}(Create{{.Name}}Request) returns (Create{{.Name}}Response);\n    {{- end}}\n    {{if .Admin.Read}}\n    // Get{{.Name}} allows getting a single entity of type {{.Name}}\n    rpc Get{{.Name}}(GetRequest) returns (Get{{.Name}}Response);\n    {{- end}}\n    {{if .Admin.List}}\n    // List{{plural .Name}} allows listing all entity of type {{.Name}}\n    rpc List{{plural .Name}}(ListRequest) returns (List{{plural .Name}}Response);\n    {{- end}}\n    {{if .Admin.Update}}\n    // Update{{.Name}} allows updating one entity of type {{.Name}}\n    rpc Update{{.Name}}(Update{{.Name}}Request) returns (Update{{.Name}}Response);\n    {{- end}}\n    {{if .Admin.Delete}}\n    // Delete{{.Name}} allows deleting an entity of type {{.Name}}\n    rpc Delete{{.Name}}(DeleteRequest) returns (DeleteResponse);\n    {{- end}}\n    {{- if .GetFileFields}}\n    // Upload{{.Name}} allows uploading of files for entity of type {{.Name}}\n    rpc Upload{{.Name}}(UploadRequest) returns (UploadResponse);\n    {{end}}\n    rpc Lookup{{plural .Name}}(LookupRequest) returns (LookupResponse);\n/**\n * [END SERVICES] {{.Name}}\n */\n{{end}}\n}\n{{- range .Entities}}\n/**\n * [BEGIN MESSAGES] {{.Name}}\n */\n{{if .Admin.Create}}\n// Create{{.Name}}Request represents a request to allow creation of entity of type {{.Name}}\nmessage Create{{.Name}}Request {\n    string Key = 1;\n    models.{{.Name}} {{.Name}} = 2;\n}\n// Create{{.Name}}Response represents result to a Create{{.Name}}Request\nmessage Create{{.Name}}Response {\n    models.{{.Name}} {{.Name}} = 1;\n}\n{{- end}}\n{{if .Admin.Read}}\n// Get{{.Name}}Response represents result to a GetRequest\nmessage Get{{.Name}}Response {\n    models.{{.Name}} {{.Name}} = 1;\n}\n{{- end}}\n{{if .Admin.List}}\n// List{{plural .Name}}Response represents result to a ListRequest\nmessage List{{plural .Name}}Response {\n    repeated models.{{.Name}} {{plural .Name}} = 1;\n}\n{{- end}}\n{{if .Admin.Update}}\n// Update{{.Name}}Request represents a request to allow updating one entity of type {{.Name}}\nmessage Update{{.Name}}Request {\n    string Key = 1;\n    models.{{.Name}} {{.Name}} = 2;\n}\n// Update{{.Name}}Response represents result to an Update{{.Name}}Request\nmessage Update{{.Name}}Response {\n    models.{{.Name}} {{.Name}} = 1;\n}\n{{- end}}\n/**\n * [END MESSAGES] {{.Name}}\n */\n{{end}}"),
	}
	file8 := &embedded.EmbeddedFile{
		Filename:    "admin/service_admin_hooks.go.tmpl",
		FileModTime: time.Unix(1539936852, 0),
		Content:     string("package admin\n\nimport (\n\t{{ if .Entity.Admin.Auth.Generate }}\"{{.ImportPath}}/auth\"{{ end }}\n)\n\n{{if .Entity.Admin.Hooks.PreRead}}\n// {{lower .Entity.Name}}PreRead is a hook that occurs before the ead operation in Admin service. Returns stop (boolean) and error\nfunc (s Service) {{lower .Entity.Name}}PreRead(ctx context.Context, req *GetRequest, res *Get{{.Entity.Name}}Response) (bool, error) {\n\treturn false, nil\n}\n{{end}}\n{{if .Entity.Admin.Hooks.PostRead}}\n// {{lower .Entity.Name}}PostRead is a hook that occurs after the Read operation in Admin service. Returns stop (boolean) and error\nfunc (s Service) {{lower .Entity.Name}}PostRead(ctx context.Context, req *GetRequest, res *Get{{.Entity.Name}}Response, err error) (bool, error) {\n\treturn false, nil\n}\n{{end}}\n{{if .Entity.Admin.Hooks.PreList}}\n// {{lower .Entity.Name}}PreList is a hook that occurs before the ist operation in Admin service. Returns stop (boolean) and error\nfunc (s Service) {{lower .Entity.Name}}PreList(ctx context.Context, req *ListRequest, res *List{{plural .Entity.Name}}Response) (bool, error) {\n\treturn false, nil\n}\n{{end}}\n{{if .Entity.Admin.Hooks.PostList}}\n// {{lower .Entity.Name}}PostList is a hook that occurs after the List operation in Admin service. Returns stop (boolean) and error\nfunc (s Service) {{lower .Entity.Name}}PostList(ctx context.Context, req *ListRequest, res *List{{plural  .Entity.Name}}Response, err error) (bool, error) {\n\treturn false, nil\n}\n{{end}}\n{{if .Entity.Admin.Hooks.PreCreate}}\n// {{lower .Entity.Name}}PreCreate is a hook that occurs before the reate operation in Admin service. Returns stop (boolean) and error\nfunc (s Service) {{lower .Entity.Name}}PreCreate(ctx context.Context, tx *sql.Tx, req *Create{{.Entity.Name}}Request, res *Create{{.Entity.Name}}Response, {{if .Entity.Admin.Auth.Generate}}passport auth.Passport, {{end}}err error) (bool, error) {\n\treturn false, nil\n}\n{{end}}\n{{if .Entity.Admin.Hooks.PostCreate}}\n// {{lower .Entity.Name}}PostCreate is a hook that occurs after the Create operation in Admin service. Returns stop (boolean) and error\nfunc (s Service) {{lower .Entity.Name}}PostCreate(ctx context.Context, req *Create{{.Entity.Name}}Request, res *Create{{.Entity.Name}}Response, err error) (bool, error) {\n\treturn false, nil\n}\n{{end}}\n{{if .Entity.Admin.Hooks.PreUpdate}}\n// {{lower .Entity.Name}}PreUpdate is a hook that occurs before the pdate operation in Admin service. Returns stop (boolean) and error\nfunc (s Service) {{lower .Entity.Name}}PreUpdate(ctx context.Context, tx *sql.Tx, req *Update{{.Entity.Name}}Request, res *Update{{.Entity.Name}}Response, existing models.{{.Entity.Name}}, {{if .Entity.Admin.Auth.Generate}}passport auth.Passport, {{end}}err error) (bool, error) {\n\treturn false, nil\n}\n{{end}}\n{{if .Entity.Admin.Hooks.PostUpdate}}\n// {{lower .Entity.Name}}PostUpdate is a hook that occurs after the Update operation in Admin service. Returns stop (boolean) and error\nfunc (s Service) {{lower .Entity.Name}}PostUpdate(ctx context.Context, req *Update{{.Entity.Name}}Request, res *Update{{.Entity.Name}}Response, existing models.{{.Entity.Name}}, err error) (bool, error) {\n\treturn false, nil\n}\n{{end}}\n{{if .Entity.Admin.Hooks.PreDelete}}\n// {{lower .Entity.Name}}PreDelete is a hook that occurs before the Delete operation in Admin service. Returns stop (boolean) and error\nfunc (s Service) {{lower .Entity.Name}}PreDelete(ctx context.Context, tx *sql.Tx, req *DeleteRequest, res *DeleteResponse, existing models.{{.Entity.Name}}, err error) (bool, error) {\n\treturn false, nil\n}\n{{end}}\n{{if .Entity.Admin.Hooks.PostDelete}}\n// {{lower .Entity.Name}}PostDelete is a hook that occurs after the Delete operation in Admin service. Returns stop (boolean) and error\nfunc (s Service) {{lower .Entity.Name}}PostDelete(ctx context.Context, req *DeleteRequest, res *DeleteResponse, existing models.{{.Entity.Name}}, err error) (bool, error) {\n\treturn false, nil\n}\n{{end}}\n"),
	}
	filea := &embedded.EmbeddedFile{
		Filename:    "application/gen-service.sh.tmpl",
		FileModTime: time.Unix(1538482115, 0),
		Content:     string("#!/bin/bash\n\nCURRENT_DIR=`pwd`\nWEB_DIR=\"${CURRENT_DIR}/web\"\nLOG_FILE=\"${CURRENT_DIR}/gen-service.log\"\n\n# Function gets an array of services as arguments (e.g. \"wire\" in \"service_wire.proto\")\ngenerate_files() {\n    # For each sub-folder in \"web\"\n    for d in ${WEB_DIR}/*/; do\n        echo -e \"# ${d}\\n\"\n        if [ ! -f \"${d}package.json\" ]; then\n            echo \"- npm init: package.json file was not found\"\n            cd \"${d}\"\n            npm init --quiet --yes >> $LOG_FILE\n        fi\n\n        if [ ! -d \"${d}node_modules/\" ]; then\n            echo \"- npm init: node_modules dir was not found\"\n            cd \"${d}\"\n            npm init --quiet --yes >> $LOG_FILE\n        fi\n\n        if [ ! -d \"${d}node_modules/.bin\" ]; then\n            echo \"- npm init: .bin dir was not found\"\n            cd \"${d}\"\n            npm init --quiet --yes >> $LOG_FILE\n        fi\n\n        if [ ! -d \"${d}node_modules/@types/google-protobuf\" ]; then\n            echo \"- npm install --save @types/google-protobuf: protobuf was not found\"\n            cd \"${d}\"\n            npm npm install --quiet --save @types/google-protobuf >> $LOG_FILE\n        fi\n\n        if [ ! -f \"${d}node_modules/.bin/protoc-gen-ts\" ]; then\n            echo \"- npm install --save-dev ts-protoc-gen: protoc-gen-ts executable was not found\"\n            cd \"${d}\"\n            npm install --quiet --save-dev ts-protoc-gen >> $LOG_FILE\n        fi\n\n        if [ ! -d \"${d}dist\" ]; then\n            echo \"- creating ${d}dist: dist dir was not found\"\n            mkdir -p \"${d}dist\"\n            echo \"\" > \"${d}dist/.gitkeep\"\n        fi\n\n        if [ ! -d \"${d}src/services\" ]; then\n            echo \"- creating ${d}src/services: src/services dir was not found\"\n            mkdir -p \"${d}src/services\"\n        fi\n\n        if [ -f \"${CURRENT_DIR}/proto/models.proto\" ]; then\n            echo \"- generating JS services for models\"\n            protoc -I=\"${CURRENT_DIR}/proto\" \\\n                \"${CURRENT_DIR}/proto/models.proto\" \\\n                --plugin=\"protoc-gen-ts=${d}node_modules/.bin/protoc-gen-ts\" \\\n                --js_out=\"import_style=commonjs,binary:${d}src/services\" \\\n                --ts_out=\"${d}src/services\"\n\n            # proto/models.proto goes in \"models\" folder\n            protoc -I=\"${CURRENT_DIR}/proto\" \\\n                \"${CURRENT_DIR}/proto/models.proto\" \\\n                --go_out=plugins=grpc:${GOPATH}/src\n        fi\n\n        if [ -f \"${CURRENT_DIR}/proto/service_admin.proto\" ]; then\n            echo \"- generating JS services for admin\"\n            protoc -I=\"${CURRENT_DIR}/proto\" \\\n                \"${CURRENT_DIR}/proto/service_admin.proto\" \\\n                --plugin=\"protoc-gen-ts=${d}node_modules/.bin/protoc-gen-ts\" \\\n                --js_out=\"import_style=commonjs,binary:${d}src/services\" \\\n                --ts_out=\"${d}src/services\"\n\n            # proto/admin.proto goes in \"admin\" folder\n            protoc -I=\"${CURRENT_DIR}/proto\" \\\n                \"${CURRENT_DIR}/proto/service_admin.proto\" \\\n                --go_out=plugins=grpc:${GOPATH}/src\n        fi\n\n        # For each proto file (the argument)\n        for f in $@; do\n            if [ -f \"${CURRENT_DIR}/proto/service_${f}.proto\" ]; then\n                echo \"- generating JS services for ${f}\"\n                protoc -I=\"${CURRENT_DIR}/proto\" \\\n                    \"${CURRENT_DIR}/proto/service_${f}.proto\" \\\n                    --plugin=\"protoc-gen-ts=${d}node_modules/.bin/protoc-gen-ts\" \\\n                    --js_out=\"import_style=commonjs,binary:${d}src/services\" \\\n                    --ts_out=\"service=true:${d}src/services\"\n            fi\n        done\n\n        echo -e \":: done\\n\"\n    done\n\n    # For each service proto file (the argument)\n    for f in $@; do\n        if [ -f \"${CURRENT_DIR}/proto/service_${f}.proto\" ]; then\n            echo \"# Generating GO services for ${f}\"\n            if [ ! -d \"${CURRENT_DIR}/services/${f}\" ]; then\n                mkdir -p \"${CURRENT_DIR}/services/${f}\"\n            fi\n            protoc -I=\"${CURRENT_DIR}/proto\" \\\n                \"${CURRENT_DIR}/proto/service_${f}.proto\" \\\n                --go_out=plugins=grpc:${GOPATH}/src\n        fi\n    done\n\n    echo -e \"\\n::Done and dusted :-)\\n\"\n}\n\n# -- MAIN SCRIPT STARTS HERE --\n\ncd ${CURRENT_DIR}\n\ndt=$(date '+%d/%m/%Y %H:%M:%S');\necho -e \"# Gen-service: ${dt}\\n\\n\" > \"${LOG_FILE}\"\n\nif [ ! -d \"${CURRENT_DIR}/vendor\" ]; then\n    echo -e \"# Dep init: Vendor folder not found.\\n\"\n    dep init >> $LOG_FILE\nfi\n\nHELP=false\nALL=false\ndeclare -a SERVICES=() # an array\n\nwhile true; do\n  case $1 in\n    -h | --help )\n        HELP=true;\n        shift;\n        ;;\n\n    -a | --all )\n        ALL=true;\n        shift;\n        ;;\n\n    -s | --services )\n        shift;\n        SERVICES=\"${@}\"\n        ;;\n\n    -- )\n        shift;\n        break\n        ;;\n\n    *  )\n        break\n        ;;\n  esac\ndone\n\n# Process all service_*.proto files in proto/ folder\nif [ \"${ALL}\" == true ]; then\n    index=0\n    for f in `find ${CURRENT_DIR}/proto/ -type f -iname \"service_*.proto\" | awk -F \"service_\" '{print $2}' | awk -F \".proto\" '{print $1}'`; do\n        SERVICES[$index]=\"${f}\"\n        index=$(($index+1))\n    done\n    generate_files ${SERVICES[@]}\n    exit 0\nfi\n\n# Process individual service_*.proto files in proto/ folder\nif [[ ${SERVICES[@]} ]]; then\n    generate_files ${SERVICES[@]}\n    exit 0\nfi\n\n# Display help\necho \"Generation of services. Usage:\"\necho \"\"\necho \" $ ./gen-service.sh -h|--help\"\necho \"   Displays this help\"\necho \"\"\necho \" $ ./gen-service.sh -a|--all\"\necho \"   Will process all service_*.proto files in 'proto' folder\"\necho \"\"\necho \" $ ./gen-service.sh -s|--services service1 service2 ... serviceN\"\necho \"   Will process individual service_*.proto files in 'proto' folder (as provided in the arguments)\"\necho \"\"\nexit 0;\n"),
	}
	fileb := &embedded.EmbeddedFile{
		Filename:    "application/main.go.tmpl",
		FileModTime: time.Unix(1539936852, 0),
		Content:     string("package main\n\nimport (\n\t\"net/http\"\n\n\trice \"github.com/GeertJohan/go.rice\"\n\t\"github.com/gorilla/mux\"\n\t\"github.com/improbable-eng/grpc-web/go/grpcweb\"\n\t\"google.golang.org/grpc\"\n\tlog \"github.com/sirupsen/logrus\"\n\t\"{{.ImportPath}}/core\"\n\t\"{{.ImportPath}}/util/web\"\n\t{{- if .Recipe.Admin.Generate}}\n\t\"{{.ImportPath}}/services/admin\"\n\t{{- end}}\n)\n\n//go:generate rice embed-go\n\n{{if not .Recipe.Bootstrap.NoVersion}}\n// Versioning info\nvar (\n\tappVersion = \"n/a\"\n\tappCommit  = \"n/a\"\n\tappBuilt   = \"n/a\"\n)\n{{end}}\n\nfunc main() {\n\t{{- if not .Recipe.Bootstrap.NoVersion}}\n\tversion := flag.Bool(\"v\", false, \"prints current app version\")\n\tflag.Parse()\n\tif *version {\n\t\tfmt.Printf(\"Version : %v \\nCommit : %v\\nBuilt: %v\\n\", appVersion, appCommit, appBuilt)\n\t\tos.Exit(0)\n\t}\n\t{{end}}\n\n\tconfig := core.Bootstrap()\n\tmodels.Init(config.DB)\n\t\n\t{{if .Recipe.Bootstrap.Assets}}\n\tcore.Assets = rice.MustFindBox(\"assets\")\n\t{{end}}\n\n\t{{if not .Recipe.Bootstrap.NoGRPCWeb}}\n\tg := grpc.NewServer()\n\t{{- if .Recipe.Admin.Generate}}\n\tadmin.RegisterAdminServer(g, &admin.Service{})\n\t{{- end}}\n\tws := grpcweb.WrapServer(g)\n\tvar router *mux.Router\n\tif core.Env == core.EnvironmentDev {\n\t\trouter = newDevRouter({{if .Recipe.Admin.Generate}}ws{{else}}nil{{end}})\n\t} else {\n\t\trouter = newProdRouter(ws)\n\t}\n\t{{end}}\n\t\n\t{{if not .Recipe.Bootstrap.NoGRPCWire}}\n\tgo func() {\n\t\tl, err := net.Listen(\"tcp\", \":\"+config.GRPCPort)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"error starting tcp listener: %v\", err)\n\t\t}\n\t\tdefer l.Close()\n\n\t\tg := grpc.NewServer()\n\t\tif err := g.Serve(l); err != nil {\n\t\t\tlog.Fatalf(\"error serving grpc: %v\", err)\n\t\t}\n\t}()\n\t{{end}}\n\n\tsrv := &http.Server{\n\t\tHandler:      router,\n\t\tAddr:         \":\" + config.HTTPPort,\n\t\tReadTimeout:  5 * time.Second,\n\t\tWriteTimeout: 10 * time.Second,\n\t\tIdleTimeout:  15 * time.Second,\n\t}\n\n\tlog.Println(\"Listening on http://127.0.0.1:\" + config.HTTPPort)\n\tif err := srv.ListenAndServe(); err != nil {\n\t\tlog.Fatalf(\"error starting http server: %v\", err)\n\t}\n}\n"),
	}
	filec := &embedded.EmbeddedFile{
		Filename:    "application/makefile.tmpl",
		FileModTime: time.Unix(1538482115, 0),
		Content:     string("VERSION     := 1.0.0\nCOMMIT      := `git rev-parse HEAD`\nDATE        := `date +%FT%T%z`\nBUILD_FLAGS := \"-X=main.appVersion=$(VERSION) -X=main.appCommit=$(COMMIT) -X=main.appBuilt=$(DATE)\"\nBUILD_DIR\t:= \"build\"\nAPPNAME\t\t:= \"{{.AppName}}\"\n\n.PHONY: build\n\nbuild:\n\t@echo \"Compiling for DEV...\"\n\t@go clean && go build -ldflags ${BUILD_FLAGS} -o ${BUILD_DIR}/${APPNAME}\n\t@echo \"Build done!\"\n\t@cd ${BUILD_DIR} && ./${APPNAME}\n\nprod:\n\t@echo \"Compiling for PROD ...\"\n\t@go clean && go generate && env GOOS=linux GOARCH=amd64 go build -ldflags ${BUILD_FLAGS} -o ${BUILD_DIR}/${APPNAME}\n\t@echo \"Compressing into tar.gz ...\"\n\t@tar -czf ${BUILD_DIR}/${APPNAME}-`date +%FT%T`.tar.gz ${BUILD_DIR}/${APPNAME}\n\t@rm ${BUILD_DIR}/${APPNAME}\n\t@echo \"Build done!\""),
	}
	filed := &embedded.EmbeddedFile{
		Filename:    "application/route.go.tmpl",
		FileModTime: time.Unix(1539936852, 0),
		Content:     string("package main\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/improbable-eng/grpc-web/go/grpcweb\"\n\tlog \"github.com/sirupsen/logrus\"\n)\n\nfunc newProdRouter(ws *grpcweb.WrappedGrpcServer) *mux.Router {\n\trouter := mux.NewRouter()\n\t{{if not .Bootstrap.NoGRPCWeb}}\n\tif ws != nil {\n\t\trouter.PathPrefix(\"/api\").Handler(http.StripPrefix(\"/api\", ws))\n\t}\n\t{{end}}\n\n\t{{if .Admin.Generate}}\n\tfiles.HTTPImageDirHandler(router, http.Dir(\"media\"), \"/media\", admin.UploadPaths)\n\t\n\tif err := web.VueAppRouting(router, \"/admin\", \"admin\", nil); err != nil {\n\t\tlog.Fatalf(\"Failed to create subroute admin: %s\\n\", err)\n\t\treturn nil\n\t}\n\t{{end}}\n\n\tif err := web.VueAppRouting(router, \"/\", \"app\", nil); err != nil {\n\t\tlog.Fatalf(\"Failed to create subroute app: %s\\n\", err)\n\t\treturn nil\n\t}\n\n\treturn router\n}\n\nfunc newDevRouter(ws *grpcweb.WrappedGrpcServer) *mux.Router {\n\trouter := mux.NewRouter()\n\t{{if not .Bootstrap.NoGRPCWeb}}\n\tif ws != nil {\n\t\trouter.PathPrefix(\"/api\").Handler(http.StripPrefix(\"/api\", ws))\n\t}\n\t{{end}}\n\n\t{{if .Admin.Generate}}\n\tfiles.HTTPImageDirHandler(router, http.Dir(\"media\"), \"/media\", admin.UploadPaths)\n\n\tif err := web.DevRouting(router, \"/admin\", \"admin\", \"8587\"); err != nil {\n\t\tlog.Warnf(\"Failed to create subrouter backoffice: %s\\n\", err)\n\t}\n\t{{end}}\n\t\n\tif err := web.DevRouting(router, \"/\", \"app\", \"8585\"); err != nil {\n\t\tlog.Warnf(\"Failed to create subrouter app: %s\\n\", err)\n\t}\n\n\treturn router\n}\n"),
	}
	filef := &embedded.EmbeddedFile{
		Filename:    "auth/auth.go.tmpl",
		FileModTime: time.Unix(1539861136, 0),
		Content:     string("package auth\n\nconst (\n\t// DummyKey is used by GetPassport\n\tDummyKey = \"justasampledummykey\"\n\n\t// Unexported dummy values for passport\n\tdummyID   = \"00000000-0000-0000-0000-0000414E4F4D\"\n\tdummyName = \"Anonymous\"\n)\n\nvar (\n\t// DummyGuard implements the Guardian interface\n\tDummyGuard = dummyGuard{}\n)\n\n// Guardian regroups method to return new Passport\ntype Guardian interface {\n\t// GetPassport returns a type implementing the Passport interface\n\tGetPassport(key string) (Passport, error)\n}\n\n// dummyGuard implements the Guardian interface\ntype dummyGuard struct{}\n\nfunc (d dummyGuard) GetPassport(key string) (Passport, error) {\n\treturn dummyPassport{}, nil\n}\n\n// Passport regroups passport methods\ntype Passport interface {\n\t// GetID returns a user ID\n\tGetID() string\n\n\t// GetName returns a user friendly identifier for user (e.g firstname, lastname, username)\n\tGetName() string\n\n\t// HasPermission returns whether user has permission for an entity\n\tHasPermission(entity interface{}, permission string) bool\n}\n\n// dummyPassport implements the Passport interface\ntype dummyPassport struct{}\n\nfunc (p dummyPassport) GetID() string {\n\treturn dummyID\n}\n\nfunc (p dummyPassport) GetName() string {\n\treturn dummyName\n}\n\nfunc (p dummyPassport) HasPermission(entity interface{}, permission string) bool {\n\treturn true\n}\n"),
	}
	fileh := &embedded.EmbeddedFile{
		Filename:    "bootstrap/bootstrap.go.tmpl",
		FileModTime: time.Unix(1538482115, 0),
		Content:     string("package core\n\nimport (\n\t\"bytes\"\n\t\"database/sql\"\n\t\"os\"\n\n\t\"github.com/joho/godotenv\"\n\trice \"github.com/GeertJohan/go.rice\"\n\tlog \"github.com/sirupsen/logrus\"\n\t// Load database driver\n\t_ \"github.com/lib/pq\"\n)\n\nconst (\n\t//EnvironmentProd represents production environment\n\tEnvironmentProd = \"PROD\"\n\n\t//EnvironmentDev represents development environment\n\tEnvironmentDev  = \"DEV\"\n)\n\nvar (\n\t// bootstrapped is a flag to prevent multiple bootstrapping\n\tbootstrapped = false\n\n\t// Env indicates in which environment (prod / dev) the application is running\n\tEnv string\n\t{{range .Bootstrap.Settings}}{{if .Public}}\n\t// {{.Name}} {{.Description}}\n\t{{.Name}} string\n\t{{end}}{{end}}\n\t{{if .Bootstrap.Assets}}\n\t// Assets is a rice box to assets directory\n\tAssets *rice.Box\n\t{{end}}\n)\n\n// Config represents application configuration loaded during bootstrap\ntype Config struct {\n\t{{if not .Bootstrap.NoDB}}DB  *sql.DB{{end}}\n\tHTTPPort string\n\t{{if not .Bootstrap.NoGRPCWire}}GRPCPort string{{end}}\n\t{{range .Bootstrap.Settings}}{{if not .Public}}\n\t// {{.Name}} {{.Description}}\n\t{{.Name}} string\n\t{{end}}{{end}}\n}\n\n// Bootstrap loads environment variables and initializes the application\nfunc Bootstrap() *Config {\n\tvar config Config\n\n\tif bootstrapped {\n\t\treturn nil\n\t}\n\n\tgodotenv.Load()\n\n\tEnv = os.Getenv(\"ENV\")\n\tif Env == \"\" {\n\t\tEnv = EnvironmentProd\n\t}\n\n\tlogLevel := os.Getenv(\"LOG_LEVEL\")\n\tswitch logLevel {\n\t\tcase \"PANIC\":\n\t\t\tlog.SetLevel(log.PanicLevel)\n\t\tcase \"FATAL\":\n\t\t\tlog.SetLevel(log.FatalLevel)\n\t\tcase \"ERROR\":\n\t\t\tlog.SetLevel(log.ErrorLevel)\n\t\tcase \"WARN\":\n\t\t\tlog.SetLevel(log.WarnLevel)\n\t\tcase \"INFO\":\n\t\t\tlog.SetLevel(log.InfoLevel)\n\t\tcase \"DEBUG\":\n\t\t\tlog.SetLevel(log.DebugLevel)\n\t\tdefault:\n\t\t\tif Env == EnvironmentProd {\n\t\t\t\tlog.SetLevel(log.ErrorLevel)\n\t\t\t} else {\n\t\t\t\tlog.SetLevel(log.DebugLevel)\n\t\t\t}\n\t}\n\n\tif logFormat := os.Getenv(\"LOG_FORMAT\"); logFormat == \"JSON\" {\n\t\tlog.SetFormatter(&log.JSONFormatter{})\n\t}\n\n\t{{if not .Bootstrap.NoDB}}\n\tdsn := os.Getenv(\"DSN\")\n\tif dsn == \"\" {\n\t\tlog.Fatal(\"Environment variable DSN must be defined. Example: postgres://user:pass@host/db?sslmode=disable\")\n\t}\n\n\tvar err error\n\tconfig.DB, err = sql.Open(\"postgres\", dsn)\n\tif err == nil {\n\t\tlog.Println(\"Connected to database successfully.\")\n\t} else if (Env == EnvironmentDev) {\n\t\tlog.Println(\"Database connection failed: \", err)\n\t} else {\n\t\tlog.Fatal(\"Database connection failed: \", err)\n\t}\n\n\terr = config.DB.Ping()\n\tif err == nil {\n\t\tlog.Println(\"Pinged database successfully.\")\n\t} else if (Env == EnvironmentDev) {\n\t\tlog.Println(\"Database ping failed: \", err)\n\t} else {\n\t\tlog.Fatal(\"Database ping failed: \", err)\n\t}\n\t{{end}}\n\n\tconfig.HTTPPort = os.Getenv(\"HTTP_PORT\")\n\tif config.HTTPPort == \"\" {\n\t\tconfig.HTTPPort = \"{{.Bootstrap.HTTPPort}}\"\n\t}\n\n\t{{if not .Bootstrap.NoGRPCWire}}\n\tconfig.GRPCPort = os.Getenv(\"GRPC_PORT\")\n\tif config.GRPCPort == \"\" {\n\t\tconfig.GRPCPort = \"{{.Bootstrap.GRPCPort}}\"\n\t}\n\t{{end}}\n\n\t{{range .Bootstrap.Settings}}{{if not .Public}}\n\tconfig.{{.Name}} = os.Getenv(\"{{upper (snake .Name)}}\")\n\tif config.{{.Name}} == \"\" {\n\t\tlog.Fatal(\"Environment variable {{upper (snake .Name)}} ({{.Description}}) must be defined.\")\n\t}\n\t{{end}}{{end}}\n\n\t{{range .Bootstrap.Settings}}{{if .Public}}\n\t{{.Name}} = os.Getenv(\"{{upper (snake .Name)}}\")\n\tif {{.Name}} == \"\" {\n\t\tlog.Fatal(\"Environment variable {{upper (snake .Name)}} ({{.Description}}) must be defined.\")\n\t}\n\t{{end}}{{end}}\n\n\tos.Clearenv() //prevent non-authorized access\n\n\treturn &config\n}\n\n\n{{if .Bootstrap.Assets}}\n// ExecuteTemplate applies templating a text/template template given data and returns the string output\nfunc ExecuteTemplate(name string, data interface{}) (string, error) {\n\tvar output bytes.Buffer\n\n\traw, err := Assets.String(\"templates/\"+name)\n\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\ttpl, err := template.New(name).Funcs(template.FuncMap{}).Parse(raw)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\terr = tpl.Execute(&output, data)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn output.String(), nil\n}\n{{end}}"),
	}
	filei := &embedded.EmbeddedFile{
		Filename:    "bootstrap/env.tmpl",
		FileModTime: time.Unix(1538482115, 0),
		Content:     string("# The following must be defined as well: ENV{{if not .Bootstrap.NoDB}}, DSN{{end}}, HTTP_PORT{{if not .Bootstrap.NoGRPCWire}}, GRPC_PORT{{end}}\n# LOG_LEVEL = \"PANIC | FATAL | ERROR | WARN | INFO | DEBUG\" # Defaults: ERROR (ENV=PROD), DEBUG (ENV=DEV)\n# LOG_FORMAT = \"TEXT | JSON\" # Defaults: TEXT\n{{range .Bootstrap.Settings}}{{upper (snake .Name)}} = \"{{.Description}}\"\n{{end}}"),
	}
	filek := &embedded.EmbeddedFile{
		Filename:    "crud/crud.go.tmpl",
		FileModTime: time.Unix(1539936852, 0),
		Content:     string("package models\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"github.com/pkg/errors\"\n\tlog \"github.com/sirupsen/logrus\"\n\t{{range .Imports}}{{.}}\n\t{{end}}\n)\n{{.Structure}}\n\n{{range .Entities}}\n//[BEGIN] {{.Name}}\n\n// Insert performs an SQL insert for {{.Name}} record and update instance with inserted id. Prefer using Save instead of Insert directly.\nfunc (repo {{.Name}}Repositorium) Insert(ctx context.Context, entity *{{.Name}}, tx *sql.Tx, autocommit bool) error {\n\tvar (\n\t\t{{- if pkeyIsAuto .PrimaryKey -}}\n\t\tid string\n\t\t{{- end}}\n\t\terr  error\n\t\tstmt *sql.Stmt\n\t)\n\n\tlog.WithFields(log.Fields{\"entity\": entity}).Debug(\"repo.{{.Name}}.Insert entered\")\n\tif entity == nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity}).Info(\"repo.{{.Name}}.Insert Entity empty error\")\n\t\treturn moderrors.SaveEmptyEntityError\n\t}\n\n\tif tx == nil {\n\t\tif err = util.CheckContext(ctx); err != nil {\n\t\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Insert context error\")\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t\t\n\t\ttx, err = StartTransaction(ctx)\n\t\tif err != nil {\n\t\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Insert StartTransaction error\")\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t}\n\t{{range .Fields}}{{range .GetBefore \"insert\"}}\n\t{{end}}{{end}}\n\n\tstmt, err = tx.Prepare(`{{.SQLInsert}}`)\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"query\": `{{.SQLInsert}}`, \"error\": err}).Error(\"repo.{{.Name}}.Insert query error\")\n\t\treturn errors.WithStack(err)\n\t}\n\tlog.WithFields(log.Fields{\"entity\": entity}).Debug(\"repo.{{.Name}}.Insert query done\")\n\n\t{{range .Fields}}{{range .GetAfter \"insert\"}}\n\t{{end}}{{end}}\n\n\t{{if .CrudHooks.PreSave}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Insert context error\")\n\t\treturn errors.WithStack(err)\n\t}\n\t\n\tif err = repo.preSave(ctx, tx, models.Insert, entity); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Insert hook preSave error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\tlog.WithFields(log.Fields{\"entity\": entity}).Debug(\"repo.{{.Name}}.Insert hook preSave executed\")\n\t{{end}}\n\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Insert context error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\t{{if eq .PrimaryKey \"uuid\" -}}\n\tentity.ID = uuid.NewV4().String()\n\t{{- end}}\n\n\t_, err = stmt.Exec({{.GetStruct \"insert\"}})\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Insert query exec error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\t{{if .CrudHooks.PostSave}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Insert context error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\tif err := repo.postSave(ctx, \"INSERT\", entity, tx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Insert hook postSave error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\tlog.WithFields(log.Fields{\"entity\": entity}).Debug(\"repo.{{.Name}}.Insert hook postSave executed\")\n\t{{end}}\n\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Insert context error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif autocommit {\n\t\terr = tx.Commit()\n\t\tif err != nil {\n\t\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Insert commit error\")\n\t\t\ttx.Rollback()\n\t\t}\n\t}\n\n\treturn errors.WithStack(err)\n}\n\n// InsertWithRel performs an SQL insert for {{.Name}} record and update instance with inserted id; including related entities. Prefer using Save instead of Insert directly.\nfunc (repo {{.Name}}Repositorium) InsertWithRel(ctx context.Context, entity *{{.Name}}, tx *sql.Tx, autocommit bool) error{\n\tvar (\n\t\t{{- if pkeyIsAuto .PrimaryKey -}}\n\t\tid  string\n\t\t{{- end}}\n\t\terr  error\n\t\tstmt *sql.Stmt\n\t)\n\t\n\tlog.WithFields(log.Fields{\"entity\": entity}).Debug(\"repo.{{.Name}}.InsertWithRel entered\")\n\tif entity == nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity}).Info(\"repo.{{.Name}}.InsertWithRel Entity empty error\")\n\t\treturn moderrors.SaveEmptyEntityError\n\t}\n\n\tif tx == nil {\n\t\tif err = util.CheckContext(ctx); err != nil {\n\t\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.InsertWithRel context error\")\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t\t\n\t\ttx, err = StartTransaction(ctx)\n\t\tif err != nil {\n\t\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.InsertWithRel StartTransaction error\")\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t}\n\t{{range .Fields}}{{range .GetBefore \"insert\"}}\n\t{{end}}{{end}}\n\n\tstmt, err = tx.Prepare(`{{.SQLInsert}}`)\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"query\": `{{.SQLInsert}}`, \"error\": err}).Error(\"repo.{{.Name}}.InsertWithRel query error\")\n\t\treturn errors.WithStack(err)\n\t}\n\n\t{{range .Fields}}{{range .GetAfter \"insert\"}}\n\t{{end}}{{end}}\n\n\t{{if .CrudHooks.PreSave}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.InsertWithRel context error\")\n\t\treturn errors.WithStack(err)\n\t}\n\t\n\tif err = repo.preSave(ctx, tx, models.Insert, entity); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.InsertWithRel hook preSave error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\tlog.WithFields(log.Fields{\"entity\": entity}).Debug(\"repo.{{.Name}}.InsertWithRel hook preSave executed\")\n\t{{end}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.InsertWithRel context error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t{{if eq .PrimaryKey \"uuid\" -}}\n\tidUUID := uuid.NewV4()\n\tid = idUUID.String()\n\tentity.ID = id\n\t{{- end}}\n\n\t_, err = stmt.Exec({{.GetStruct \"get\"}})\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.InsertWithRel query exec error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\t{{range .Relationships}}{{if (eq \"many-many-owner\" .Type) }}\n\terr = repo.Save{{.Name}}(ctx, tx, false, entity.ID, entity.{{$.Name}}...)\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{$.Name}}.InsertWithRel save related {{.Name}} error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{$.Name}}.InsertWithRel context error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t{{end}}{{end}}\n\n\t{{if .CrudHooks.PostSave}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.InsertWithRel context error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\tif err := repo.postSave(ctx, \"INSERT\", entity, tx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.InsertWithRel hook postSave error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\tlog.WithFields(log.Fields{\"entity\": entity}).Debug(\"repo.{{.Name}}.InsertWithRel hook postSave executed\")\n\t{{end}}\n\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.InsertWithRel context error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif autocommit {\n\t\terr = tx.Commit()\n\t\tif err != nil {\n\t\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.InsertWithRel commit error\")\n\t\t\ttx.Rollback()\n\t\t}\n\t}\n\n\treturn errors.WithStack(err)\n}\n\n// Get returns a single {{.Name}} from database by primary key\nfunc (repo {{.Name}}Repositorium) Get(ctx context.Context, id string) (*{{.Name}}, error) {\n\tvar (\n\t\trows   *sql.Rows\n\t\terr    error\n\t\tentity {{.Name}}\n\t)\n\n\tlog.WithFields(log.Fields{\"id\": id}).Debug(\"repo.{{.Name}}.Get entered\")\n\t{{if .CrudHooks.PreRead}}\n    if err = repo.preGet(ctx, id); err != nil {\n\t\tlog.WithFields(log.Fields{\"id\": id, \"error\": err}).Info(\"repo.{{.Name}}.Get hook preGet error\")\n\t\treturn nil, err\n\t}\n\tlog.WithFields(log.Fields{\"id\": id}).Debug(\"repo.{{.Name}}.Get hook preGet executed\")\n    {{end}}\n\t\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"id\": id, \"error\": err}).Info(\"repo.{{.Name}}.Get context error\")\n\t\treturn nil, err\n\t}\n\n\trows, err = repo.db.QueryContext(ctx, `{{.SQLGet}}`, id)\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"id\": id, \"query\": `{{.SQLGet}}`, \"error\": err}).Error(\"repo.{{.Name}}.Get query error\")\n\t\treturn nil, err\n\t}\n\tlog.WithFields(log.Fields{\"id\": id}).Debug(\"repo.{{.Name}}.Get query done\")\n\n\tdefer rows.Close()\n\tif rows.Next() {\n\t\tlog.WithFields(log.Fields{\"id\": id}).Debug(\"repo.{{.Name}}.Get row found\")\n\t\tif err = util.CheckContext(ctx); err != nil {\n\t\t\tlog.WithFields(log.Fields{\"id\": id, \"error\": err}).Info(\"repo.{{.Name}}.Get context error\")\n\t\t\treturn nil, err\n\t\t}\n\n\t\t{{range .Fields}}{{range .GetBefore \"get\"}}\t\n\t\t{{end}}{{end}}\n\n\t\terr = rows.Scan({{.GetStruct \"get\"}})\n\t\tif err != nil {\n\t\t\tlog.WithFields(log.Fields{\"id\": id, \"query\": `{{.SQLGet}}`, \"fields\": \"{{.StructGet}}\", \"error\": err}).Error(\"repo.{{.Name}}.Get scan error\")\n\t\t\treturn nil, err\n\t\t}\n\t\t\n\t\t{{range .Fields}}{{range .GetAfter \"get\"}}\n\t\t{{end}}{{end}}\n\n\t\tlog.WithFields(log.Fields{\"id\": id}).Debug(\"repo.{{.Name}}.Get data scan done\")\n\t} else {\n\t\tlog.WithFields(log.Fields{\"id\": id}).Debug(\"repo.{{.Name}}.Get data not found\")\n\t\treturn nil, moderrors.RecordNotFoundError\n\t}\n\t{{if .CrudHooks.PostRead}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"id\": id, \"error\": err}).Info(\"repo.{{.Name}}.Get context error\")\n\t\treturn nil, err\n\t}\n\n\tif err = repo.postGet(ctx, &entity); err != nil {\n\t\tlog.WithFields(log.Fields{\"id\": id, \"error\": err}).Info(\"repo.{{.Name}}.Get hook postGet error\")\n\t\treturn nil, err\n\t}\n\tlog.WithFields(log.Fields{\"id\": id}).Debug(\"repo.{{.Name}}.Get hook postGet executed\")\n\t{{end}}\n\n\treturn &entity, nil\n}\n\n// GetWithRel returns a single {{.Name}} from database by primary key; loads related entities\nfunc (repo {{.Name}}Repositorium) GetWithRel(ctx context.Context, id string) (*{{.Name}}, error) {\n\tlog.WithFields(log.Fields{\"id\": id}).Debug(\"repo.{{.Name}}.GetWithRel entered\")\n\tentity, err := repo.Get(ctx, id)\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"id\": id, \"error\": err}).Error(\"repo.{{.Name}}.GetWithRel get entity error\")\n\t\treturn nil, err\n\t}\n\tlog.WithFields(log.Fields{\"id\": id}).Debug(\"repo.{{.Name}}.GetWithRel entity loaded\")\n\n\t{{range .Relationships}}\n\terr = repo.Load{{.Name}}(ctx, entity)\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"id\": id, \"error\": err}).Error(\"repo.{{$.Name}}.Get load related {{.Name}} error\")\n\t\treturn nil, err\n\t}\n\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"id\": id, \"error\": err}).Info(\"repo.{{$.Name}}.Get context error\")\n\t\treturn nil, err\n\t}\n\tlog.WithFields(log.Fields{\"id\": id}).Debug(\"repo.{{$.Name}}.GetWithRel related {{.Name}} loaded\")\n\t{{end}}\n\n\treturn entity, nil\n}\n\n// List returns a slice containing {{.Name}} records\nfunc (repo {{.Name}}Repositorium) List(ctx context.Context, opts *ListOpts, filters ...*Filter) ([]*{{.Name}}, error) {\n\tvar (\n\t\tlist\t []*{{.Name}}\n\t\tsegments []string\n\t\tvalues\t []interface{}\n\t\terr\t\t error\n\t\trows\t *sql.Rows\n\t\tindex\t int = 0\n\t)\n\n\tlog.WithFields(log.Fields{\"opts\": opts, \"filters\": filters}).Debug(\"repo.{{.Name}}.List entered\")\n\tquery := `{{.SQLList}}`\n\t{{if .CrudHooks.PreList}}\n    if filters, err = repo.preList(ctx, filters); err != nil {\n\t\tlog.WithFields(log.Fields{\"opts\": opts, \"filters\": filters, \"error\": err}).Info(\"repo.{{.Name}}.List hook preList error\")\n\t\treturn nil, err\n\t}\n\tlog.WithFields(log.Fields{\"opts\": opts, \"filters\": filters}).Debug(\"repo.{{.Name}}.List hook preGet executed\")\n\t{{end}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"opts\": opts, \"filters\": filters, \"error\": err}).Info(\"repo.{{.Name}}.List context error\")\n\t\treturn nil, err\n\t}\n\n\tfor _, filter := range filters {\n\t\tif filter.Operation == \"IN\" || filter.Operation == \"NOT IN\" { //TODO SQL-dialect sensitive\n\t\t\tseg, val, err := QueryAddIN(segments, values, &index, filter.Field, filter.Value, \"NOT IN\" == filter.Operation)\n\t\t\tif err != nil {\n\t\t\t\tlog.WithFields(log.Fields{\"opts\": opts, \"filters\": filters, \"error\": err}).Error(\"repo.{{.Name}}.List QueryAddIN error\")\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tsegments = seg\n\t\t\tvalues = val\n\t\t} else {\n\t\t\tindex += 1\n\t\t\tsegments = append(segments, filter.Field+\" \"+filter.Operation+\" $\"+strconv.Itoa(index))\n\t\t\tvalues = append(values, filter.Value)\n\t\t}\n\t}\n\n\tif len(segments) != 0 {\n\t\tquery += \" WHERE \" + strings.Join(segments, \" AND \")\n\t}\n\t\n\tif opts != nil && opts.Sort != \"\" { //TODO SQL-dialect sensitive\n\t\tquery += \" ORDER BY \" + opts.Sort\n\t}{{if .DefaultSort}} else {\n\t\tquery += ` ORDER BY {{.DefaultSort}}`\n\t}\n\t{{- end}}\n\n\tif opts != nil && opts.Offset > 0 { //TODO SQL-dialect sensitive\n\t\tquery += \" OFFSET \" + strconv.FormatInt(opts.Offset, 10)\n\t}\n\n\tif opts != nil && opts.Limit > 0 { //TODO SQL-dialect sensitive\n\t\tquery += \" LIMIT \" + strconv.FormatInt(opts.Limit, 10)\n\t}\n\n\trows, err = repo.db.QueryContext(ctx, query, values...)\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"opts\": opts, \"filters\": filters, \"query\": query, \"error\": err}).Error(\"repo.{{.Name}}.List query error\")\n\t\treturn nil, err\n\t}\n\tlog.WithFields(log.Fields{\"opts\": opts, \"filters\": filters}).Debug(\"repo.{{.Name}}.List query done\")\n\n\tdefer rows.Close()\n\tfor rows.Next() {\n\t\tlog.WithFields(log.Fields{\"opts\": opts, \"filters\": filters}).Debug(\"repo.{{.Name}}.List row found\")\n\t\tif err = util.CheckContext(ctx); err != nil {\n\t\t\tlog.WithFields(log.Fields{\"opts\": opts, \"filters\": filters, \"error\": err}).Info(\"repo.{{.Name}}.List context error\")\n\t\t\treturn nil, err\n\t\t}\n\n\t\tvar entity {{.Name}}\n\t\t{{range .Fields}}{{range .GetBefore \"list\"}}\t\n\t\t{{end}}{{end}}\n\n\t\terr = rows.Scan({{.GetStruct \"list\"}})\n\t\tif err != nil {\n\t\t\tlog.WithFields(log.Fields{\"opts\": opts, \"filters\": filters, \"query\": query, \"fields\": \"{{.StructList}}\", \"error\": err}).Error(\"repo.{{.Name}}.List scan error\")\n\t\t\treturn nil, err\n\t\t}\n\t\t\n\t\t{{range .Fields}}{{range .GetAfter \"list\"}}\n\t\t{{end}}{{end}}\n\n\t\tlog.WithFields(log.Fields{\"opts\": opts, \"filters\": filters}).Debug(\"repo.{{.Name}}.List data scan done\")\n\t\tlist = append(list, &entity)\n\t\t\n\t}\n\t{{if .CrudHooks.PostList}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"opts\": opts, \"filters\": filters, \"error\": err}).Info(\"repo.{{.Name}}.List context error\")\n\t\treturn nil, err\n\t}\n\n\tif list, err = repo.postList(ctx, list); err != nil {\n\t\tlog.WithFields(log.Fields{\"opts\": opts, \"filters\": filters, \"error\": err}).Info(\"repo.{{.Name}}.List hook postList error\")\n\t\treturn nil, err\n\t}\n\tlog.WithFields(log.Fields{\"opts\": opts, \"filters\": filters}).Debug(\"repo.{{.Name}}.List hook postList executed\")\n\t{{end}}\n\n\treturn list, nil\n}\n\n// ListWithRel returns a slice containing {{.Name}} records; will also load related entities.\nfunc (repo {{.Name}}Repositorium) ListWithRel(ctx context.Context, opts *ListOpts, filters ...*Filter) ([]*{{.Name}}, error) {\n\tvar (\n\t\terr error\n\t\tentities []*{{.Name}}\n\t)\n\n\tlog.WithFields(log.Fields{\"opts\": opts, \"filters\": filters}).Debug(\"repo.{{.Name}}.ListWithRel entered\")\n\tentities, err = repo.List(ctx, opts, filters...)\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"opts\": opts, \"filters\": filters, \"error\": err}).Error(\"repo.{{.Name}}.ListWithRel get entity error\")\n\t\treturn nil, err\n\t}\n\n\t{{range .Relationships}}\n\terr = repo.Load{{.Name}}(ctx, entities...)\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"opts\": opts, \"filters\": filters, \"error\": err}).Error(\"repo.{{$.Name}}.ListWithRel list related {{.Name}} error\")\n\t\treturn nil, err\n\t}\n\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"opts\": opts, \"filters\": filters, \"error\": err}).Info(\"repo.{{$.Name}}.ListWithRel context error\")\n\t\treturn nil, err\n\t}\n\tlog.WithFields(log.Fields{\"opts\": opts, \"filters\": filters}).Debug(\"repo.{{$.Name}}.ListWithRel related {{.Name}} listed\")\n\t{{end}}\n\n\treturn entities, nil\n}\n\n// Select returns a slice containing {{.Name}} records according to a custom SQL condition\nfunc (repo {{.Name}}Repositorium) Select(ctx context.Context, opts *ListOpts, condition string, values ...interface{}) ([]*{{.Name}}, error) {\n\tvar (\n\t\tlist     []*{{.Name}}\n\t\terr      error\n\t\trows     *sql.Rows\n\t)\n\n\tlog.WithFields(log.Fields{\"opts\": opts, \"condition\": condition, \"values\": values}).Debug(\"repo.{{.Name}}.Select entered\")\n\tquery := `{{.SQLList}}` + condition\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"opts\": opts, \"condition\": condition, \"values\": values, \"error\": err}).Info(\"repo.{{.Name}}.Select context error\")\n\t\treturn nil, err\n\t}\n\n\tif opts != nil {\n\t\tswitch opts.Sort { //TODO SQL-dialect sensitive\n\t\tcase {{.OrderList}}: \n\t\t\tquery += ` ORDER BY t.\"` + opts.Sort + `\"`\n\t\t}\n\t}\n\n\tif opts != nil && opts.Offset > 0 { //TODO SQL-dialect sensitive\n\t\tquery += \" OFFSET \" + strconv.FormatInt(opts.Offset, 10)\n\t}\n\n\tif opts != nil && opts.Limit > 0 { //TODO SQL-dialect sensitive\n\t\tquery += \" LIMIT \" + strconv.FormatInt(opts.Limit, 10)\n\t}\n\n\trows, err = repo.db.QueryContext(ctx, query, values...)\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"opts\": opts, \"condition\": condition, \"values\": values, \"query\": query, \"error\": err}).Error(\"repo.{{.Name}}.Select query error\")\n\t\treturn nil, err\n\t}\n\tlog.WithFields(log.Fields{\"opts\": opts, \"condition\": condition, \"values\": values}).Debug(\"repo.{{.Name}}.Select query done\")\n\n\tdefer rows.Close()\n\tfor rows.Next() {\n\t\tif err = util.CheckContext(ctx); err != nil {\n\t\t\tlog.WithFields(log.Fields{\"opts\": opts, \"condition\": condition, \"values\": values, \"error\": err}).Info(\"repo.{{.Name}}.Select context error\")\n\t\t\treturn nil, err\n\t\t}\n\n\t\tvar entity {{.Name}}\n\t\t{{range .Fields}}{{range .GetBefore \"list\"}}\t\n\t\t{{end}}{{end}}\n\n\t\terr = rows.Scan({{.GetStruct \"list\"}})\n\t\tif err != nil {\n\t\t\tlog.WithFields(log.Fields{\"opts\": opts, \"condition\": condition, \"values\": values, \"query\": query, \"fields\": \"{{.StructList}}\", \"error\": err}).Error(\"repo.{{.Name}}.Select scan error\")\n\t\t\treturn nil, err\n\t\t}\n\t\t\n\t\t{{range .Fields}}{{range .GetAfter \"list\"}}\n\t\t{{end}}{{end}}\n\n\t\tlog.WithFields(log.Fields{\"opts\": opts, \"condition\": condition, \"values\": values}).Debug(\"repo.{{.Name}}.Select data scan done\")\n\t\tlist = append(list, &entity)\n\t}\n\n\treturn list, nil\n}\n\n// SelectWithRel returns a slice containing {{.Name}} records according to a custom SQL condition; will also load related entities.\nfunc (repo {{.Name}}Repositorium) SelectWithRel(ctx context.Context, opts *ListOpts, condition string, values ...interface{}) ([]*{{.Name}}, error) {\n\tvar (\n\t\terr error\n\t\tentities []*{{.Name}}\n\t)\n\n\tlog.WithFields(log.Fields{\"opts\": opts, \"condition\": condition, \"values\": values}).Debug(\"repo.{{.Name}}.SelectWithRel entered\")\n\tentities, err = repo.Select(ctx, opts, condition, values...)\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"opts\": opts, \"condition\": condition, \"values\": values, \"error\": err}).Error(\"repo.{{.Name}}.SelectWithRel get entity error\")\n\t\treturn nil, err\n\t}\n\n\t{{range .Relationships}}\n\terr = repo.Load{{.Name}}(ctx, entities...)\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"opts\": opts, \"condition\": condition, \"values\": values, \"error\": err}).Error(\"repo.{{$.Name}}.SelectWithRel list related {{.Name}} error\")\n\t\treturn nil, err\n\t}\n\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"opts\": opts, \"condition\": condition, \"values\": values, \"error\": err}).Info(\"repo.{{$.Name}}.SelectWithRel context error\")\n\t\treturn nil, err\n\t}\n\tlog.WithFields(log.Fields{\"opts\": opts, \"condition\": condition, \"values\": values}).Debug(\"repo.{{$.Name}}.SelectWithRel related {{.Name}} listed\")\n\t{{end}}\n\n\treturn entities, nil\n}\n\n// Delete deletes a {{.Name}} record from database and sets id to nil\nfunc (repo {{.Name}}Repositorium) Delete(ctx context.Context, entity *{{.Name}}, tx *sql.Tx, autocommit bool) error {\n\tvar (\n\t\terr  error\n\t\tstmt *sql.Stmt\n\t)\n\tid := entity.ID\n\n\tlog.WithFields(log.Fields{\"entity\": entity}).Debug(\"repo.{{.Name}}.Delete entered\")\n\tif tx == nil {\n\t\tif err = util.CheckContext(ctx); err != nil {\n\t\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Delete context error\")\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\n\t\ttx, err = StartTransaction(ctx)\n\t\tif err != nil {\n\t\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Delete StartTransaction error\")\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t}\n\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Delete context error\")\n\t\treturn errors.WithStack(err)\n\t}\n\n\tstmt, err = tx.Prepare(\"{{.SQLDeleteSingle}}\")\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"query\": `{{.SQLDeleteSingle}}`, \"error\": err}).Error(\"repo.{{.Name}}.Delete query error\")\n\t\treturn errors.WithStack(err)\n\t}\n\t{{if .CrudHooks.PreDeleteSingle}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Delete context error\")\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif err = repo.preDelete(ctx, tx, id); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Delete hook preDelete error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\tlog.WithFields(log.Fields{\"entity\": entity}).Debug(\"repo.{{.Name}}.Delete hook preDelete executed\")\n\t{{end}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Delete context error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t\n\t_, err = stmt.Exec(id)\n\tif err == nil {\n\t\tentity.ID = {{pkeyPropertyEmptyVal .PrimaryKey}}\n\t} else {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Delete query exec error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t\n\t{{range .Relationships}}{{if (eq \"many-many-owner\" .Type) }}\n\terr = repo.Save{{.Name}}(ctx, tx, false, entity.ID)\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{$.Name}}.Delete save related {{.Name}} error\")\n\t\t{# tx.Rollback() #}\n\t\t{# return errors.WithStack(err) #}\n\t}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{$.Name}}.Delete context error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t{{end}}{{end}}\n\n\t{{if .CrudHooks.PostDeleteSingle}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Delete context error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t\n\tif err = repo.postDelete(ctx, tx, id); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Delete hook postDelete error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\tlog.WithFields(log.Fields{\"entity\": entity}).Debug(\"repo.{{.Name}}.Delete hook postDelete executed\")\n\t{{end}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Delete context error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif autocommit {\n\t\terr = tx.Commit()\n\t\tif err != nil {\n\t\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Delete commit error\")\n\t\t\ttx.Rollback()\n\t\t}\n\t}\n\n\treturn errors.WithStack(err)\n}\n\n// DeleteMany deletes many {{.Name}} records from database using filter\nfunc (repo {{.Name}}Repositorium) DeleteMany(ctx context.Context, tx *sql.Tx, autocommit bool, filters ...*Filter) error {\n\tvar (\n\t\terr      error\n\t\tstmt     *sql.Stmt\n\t\tsegments []string\n\t\tvalues   []interface{}\n\t\tquery    string\n\t)\n\n\tlog.WithFields(log.Fields{\"filters\": filters}).Debug(\"repo.{{.Name}}.DeleteMany entered\")\n\tif tx == nil {\n\t\tif err = util.CheckContext(ctx); err != nil {\n\t\t\tlog.WithFields(log.Fields{\"filters\": filters, \"error\": err}).Info(\"repo.{{.Name}}.DeleteMany context error\")\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t\t\n\t\ttx, err = StartTransaction(ctx)\n\t\tif err != nil {\n\t\t\tlog.WithFields(log.Fields{\"filters\": filters, \"error\": err}).Info(\"repo.{{.Name}}.DeleteMany StartTransaction error\")\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t}\n\n\t{{if .CrudHooks.PreDeleteMany}}\n    if filters, err = repo.preDeleteMany(ctx, tx, filters); err != nil {\n\t\tlog.WithFields(log.Fields{\"filters\": filters, \"error\": err}).Info(\"repo.{{.Name}}.DeleteMany hook preDelete error\")\n\t\treturn errors.WithStack(err)\n\t}\n\tlog.WithFields(log.Fields{\"filters\": filters}).Debug(\"repo.{{.Name}}.DeleteMany hook preDelete executed\")\n\t{{end}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"filters\": filters, \"error\": err}).Info(\"repo.{{.Name}}.DeleteMany context error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\tfor i, filter := range filters {\n\t\tsegments = append(segments, filter.Field+\" \"+filter.Operation+\" $\"+strconv.Itoa(i+1))\n\t\tvalues = append(values, filter.Value)\n\t}\n\n\tif len(segments) != 0 { //TODO SQL-dialect sensitive\n\t\tquery = \" WHERE \" + strings.Join(segments, \" AND \")\n\t}\n\n\t{{range .SQLDeleteManyJoin}}\n\tstmt, err = tx.Prepare(\"{{.}}\"+query+\")\")\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"filters\": filters, \"query\": {{.}}\"+query+\")\", \"error\": err}).Error(\"repo.{{.Name}}.DeleteMany query error\")\n\t\treturn errors.WithStack(err)\n\t}\n\n\t_, err = stmt.Exec(values...)\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"filters\": filters, \"error\": err}).Info(\"repo.{{.Name}}.DeleteMany query exec error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t{{end}}\n\n\tstmt, err = tx.Prepare(\"{{.SQLDeleteMany}}\"+query)\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"filters\": filters, \"query\": \"{{.SQLDeleteMany}}\"+query+\")\", \"error\": err}).Error(\"repo.{{.Name}}.DeleteMany query error\")\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"filters\": filters, \"error\": err}).Info(\"repo.{{.Name}}.DeleteMany context error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\t_, err = stmt.Exec(values...)\n\tif err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\t{{if .CrudHooks.PostDeleteMany}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"filters\": filters, \"error\": err}).Info(\"repo.{{.Name}}.DeleteMany context error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif err = repo.postDeleteMany(ctx, tx, filters); err != nil {\n\t\tlog.WithFields(log.Fields{\"filters\": filters, \"error\": err}).Info(\"repo.{{.Name}}.DeleteMany hook postDeleteMany error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\tlog.WithFields(log.Fields{\"filters\": filters}).Debug(\"repo.{{.Name}}.DeleteMany hook postDeleteMany executed\")\n\t{{end}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"filters\": filters, \"error\": err}).Info(\"repo.{{.Name}}.DeleteMany context error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif autocommit {\n\t\terr = tx.Commit()\n\t\tif err != nil {\n\t\t\tlog.WithFields(log.Fields{\"filters\": filters, \"error\": err}).Info(\"repo.{{.Name}}.DeleteMany commit error\")\n\t\t\ttx.Rollback()\n\t\t}\n\t}\n\n\treturn errors.WithStack(err)\n}\n\n// Save either inserts or updates a {{.Name}} record based on whether or not id is nil\nfunc (repo {{.Name}}Repositorium) Save(ctx context.Context, entity *{{.Name}}, tx *sql.Tx, autocommit bool) error {\n\tif entity == nil {\n\t\treturn moderrors.SaveEmptyEntityError\n\t}\n\n\tlog.WithFields(log.Fields{\"entity\": entity}).Debug(\"repo.{{.Name}}.Save entered\")\n\t{{if pkeyIsAuto .PrimaryKey -}}\n\tif entity.ID == {{pkeyPropertyEmptyVal .PrimaryKey}} {\n\t\treturn repo.Insert(ctx, entity, tx, autocommit)\n\t}\n\treturn repo.Update(ctx, entity, tx, autocommit)\n\t{{- else -}}\n\tif entity.ID == {{pkeyPropertyEmptyVal .PrimaryKey}} {\n\t\treturn entity, errors.New(\"primary key cannot be nil\")\n\t}\n\treturn repo.Merge(ctx, entity, tx, autocommit)\n\t{{end -}}\n}\n\n// SaveWithRel either inserts or updates a {{.Name}} record based on whether or not id is nil; will also save related entities\nfunc (repo {{.Name}}Repositorium) SaveWithRel(ctx context.Context, entity *{{.Name}}, tx *sql.Tx, autocommit bool) error {\n\tif entity == nil {\n\t\treturn moderrors.SaveEmptyEntityError\n\t}\n\n\tlog.WithFields(log.Fields{\"entity\": entity}).Debug(\"repo.{{.Name}}.SaveWithRel entered\")\n\t{{if pkeyIsAuto .PrimaryKey -}}\n\tif entity.ID == {{pkeyPropertyEmptyVal .PrimaryKey}} {\n\t\treturn repo.InsertWithRel(ctx, entity, tx, autocommit)\n\t}\n\treturn repo.UpdateWithRel(ctx, entity, tx, autocommit)\n\t{{- else -}}\n\tif entity.ID == {{pkeyPropertyEmptyVal .PrimaryKey}} {\n\t\treturn entity, errors.New(\"primary key cannot be nil\")\n\t}\n\treturn repo.MergeWithRel(ctx, entity, tx, autocommit)\n\t{{end -}}\n}\n\n// Update Will execute an SQLUpdate Statement for {{.Name}} in the database. Prefer using Save instead of Update directly.\nfunc (repo {{.Name}}Repositorium) Update(ctx context.Context, entity *{{.Name}}, tx *sql.Tx, autocommit bool) error {\n\tvar (\n\t\terr error\n\t\tstmt *sql.Stmt\n\t)\n\n\tlog.WithFields(log.Fields{\"entity\": entity}).Debug(\"repo.{{.Name}}.Update entered\")\n\tif entity == nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity}).Info(\"repo.{{.Name}}.Update Entity empty error\")\n\t\treturn moderrors.SaveEmptyEntityError\n\t}\n\n\tif tx == nil {\n\t\tif err = util.CheckContext(ctx); err != nil {\n\t\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Update context error\")\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\n\t\ttx, err = StartTransaction(ctx)\n\t\tif err != nil {\n\t\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Update StartTransaction error\")\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t}\n\t\n\t{{range .Fields}}{{range .GetBefore \"update\"}}\n\t{{end}}{{end}}\n\n\tstmt, err = tx.Prepare(`{{.SQLUpdate}}`)\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"query\": `{{.SQLUpdate}}`, \"error\": err}).Error(\"repo.{{.Name}}.Update query error\")\n\t\treturn errors.WithStack(err)\n\t}\n\tlog.WithFields(log.Fields{\"entity\": entity}).Debug(\"repo.{{.Name}}.Update query done\")\n\n\t{{range .Fields}}{{range .GetAfter \"update\"}}\n\t{{end}}{{end}}\n\n\t{{if .CrudHooks.PreSave}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Update context error\")\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif err = repo.preSave(ctx, tx, models.Update, entity); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Update hook preSave error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\tlog.WithFields(log.Fields{\"entity\": entity}).Debug(\"repo.{{.Name}}.Update hook preSave executed\")\n\t{{end}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Update context error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t_, err = stmt.Exec({{.GetStruct \"update\"}})\n\tif err != nil {\n\t\ttx.Rollback()\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Update query exec error\")\n\t\treturn errors.WithStack(err)\n\t}\n\n\t{{if .CrudHooks.PostSave}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Update context error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif err = repo.postSave(ctx, \"UPDATE\", entity, tx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Update hook postSave error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\tlog.WithFields(log.Fields{\"entity\": entity}).Debug(\"repo.{{.Name}}.Update hook postSave executed\")\n\t{{end}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Update context error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif autocommit {\n\t\terr = tx.Commit()\n\t\tif err != nil {\n\t\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Update commit error\")\n\t\t\ttx.Rollback()\n\t\t}\n\t}\n\n\treturn errors.WithStack(err)\n}\n\n// UpdateWithRel Will execute an SQLUpdate Statement for {{.Name}} in the database; including related entities. Prefer using Save instead of Update directly.\nfunc (repo {{.Name}}Repositorium) UpdateWithRel(ctx context.Context, entity *{{.Name}}, tx *sql.Tx, autocommit bool) error {\n\tvar (\n\t\terr error\n\t\tstmt *sql.Stmt\n\t)\n\n\tlog.WithFields(log.Fields{\"entity\": entity}).Debug(\"repo.{{.Name}}.UpdateWithRel entered\")\n\tif entity == nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity}).Info(\"repo.{{.Name}}.UpdateWithRel Entity empty error\")\n\t\treturn moderrors.SaveEmptyEntityError\n\t}\n\n\tif tx == nil {\n\t\tif err = util.CheckContext(ctx); err != nil {\n\t\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.UpdateWithRel context error\")\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\n\t\ttx, err = StartTransaction(ctx)\n\t\tif err != nil {\n\t\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.UpdateWithRel StartTransaction error\")\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t}\n\t\n\t{{range .Fields}}{{range .GetBefore \"update\"}}\n\t{{end}}{{end}}\n\n\tstmt, err = tx.Prepare(`{{.SQLUpdate}}`)\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"query\": `{{.SQLUpdate}}`, \"error\": err}).Error(\"repo.{{.Name}}.UpdateWithRel query error\")\n\t\treturn errors.WithStack(err)\n\t}\n\n\t{{range .Fields}}{{range .GetAfter \"update\"}}\n\t{{end}}{{end}}\n\n\t{{if .CrudHooks.PreSave}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.UpdateWithRel context error\")\n\t\treturn errors.WithStack(err)\n\t}\n\n    if err = repo.preSave(ctx, tx, models.Update, entity); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.UpdateWithRel hook preSave error\")\n\t\ttx.Rollback()\n        return errors.WithStack(err)\n\t}\n\tlog.WithFields(log.Fields{\"entity\": entity}).Debug(\"repo.{{.Name}}.UpdateWithRel hook preSave executed\")\n\t{{end}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.UpdateWithRel context error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t_, err = stmt.Exec({{.GetStruct \"update\"}})\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.UpdateWithRel query exec error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\t{{range .Relationships}}{{if (eq \"many-many-owner\" .Type) }}\n\terr = repo.Save{{.Name}}(ctx, tx, false, entity.ID, entity.{{$.Name}}...)\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{$.Name}}.UpdateWithRel save related {{.Name}} error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{$.Name}}.UpdateWithRel context error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t{{end}}{{end}}\n\n\t{{if .CrudHooks.PostSave}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.UpdateWithRel context error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif err = repo.postSave(ctx, \"UPDATE\", entity, tx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.UpdateWithRel hook postSave error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\tlog.WithFields(log.Fields{\"entity\": entity}).Debug(\"repo.{{.Name}}.UpdateWithRel hook postSave executed\")\n\t{{end}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.UpdateWithRel context error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif autocommit {\n\t\terr = tx.Commit()\n\t\tif err != nil {\n\t\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.UpdateWithRel commit error\")\n\t\t\ttx.Rollback()\n\t\t}\n\t}\n\n\treturn errors.WithStack(err)\n}\n\n// Merge performs an SQL merge for {{.Name}} record.\nfunc (repo {{.Name}}Repositorium) Merge(ctx context.Context, entity *{{.Name}}, tx *sql.Tx, autocommit bool) error {\n\tvar (\n\t\terr error\n\t\tstmt *sql.Stmt\n\t)\n\n\tlog.WithFields(log.Fields{\"entity\": entity}).Debug(\"repo.{{.Name}}.Merge entered\")\n\tif entity == nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity}).Info(\"repo.{{.Name}}.Merge Entity empty error\")\n\t\treturn moderrors.SaveEmptyEntityError\n\t}\n\n\tif tx == nil {\n\t\tif err = util.CheckContext(ctx); err != nil {\n\t\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Merge context error\")\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t\t\n\t\ttx, err = StartTransaction(ctx)\n\t\tif err != nil {\n\t\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Merge StartTransaction error\")\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t}\n\n\tif entity.ID == {{pkeyPropertyEmptyVal .PrimaryKey}} {\n\t\treturn {{.Name}}Repo.Insert(ctx, entity, tx, autocommit)\n\t}\n\n\t{{range .Fields}}{{range .GetBefore \"merge\"}}\n\t{{end}}{{end}}\n\n\tstmt, err = tx.Prepare(`{{.SQLMerge}}`)\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"query\": `{{.SQLMerge}}`, \"error\": err}).Error(\"repo.{{.Name}}.Merge query error\")\n\t\treturn errors.WithStack(err)\n\t}\n\tlog.WithFields(log.Fields{\"entity\": entity}).Debug(\"repo.{{.Name}}.Merge query done\")\n\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Merge context error\")\n\t\treturn errors.WithStack(err)\n\t}\n\t{{if .CrudHooks.PreSave}}\n    if err = repo.preSave(ctx, tx, models.Merge, entity); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Merge hook preSave error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\tlog.WithFields(log.Fields{\"entity\": entity}).Debug(\"repo.{{.Name}}.Merge hook preSave executed\")\n\t{{end}}\n\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Merge context error\")\n\t\treturn errors.WithStack(err)\n\t}\n\t_, err = stmt.Exec({{.GetStruct \"merge\"}})\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Merge query exec error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\t{{if .CrudHooks.PostSave}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Merge context error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\tif err = repo.postSave(ctx, \"MERGE\", entity, tx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Merge hook postSave error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\tlog.WithFields(log.Fields{\"entity\": entity}).Debug(\"repo.{{.Name}}.Merge hook postSave executed\")\n\t{{end}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Merge context error\")\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif autocommit {\n\t\terr = tx.Commit()\n\t\tif err != nil {\n\t\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Merge commit error\")\n\t\t\ttx.Rollback()\n\t\t}\n\t}\n\n\treturn errors.WithStack(err)\n}\n\n// MergeWithRel performs an SQL merge for {{.Name}} record.\nfunc (repo {{.Name}}Repositorium) MergeWithRel(ctx context.Context, entity *{{.Name}}, tx *sql.Tx, autocommit bool) error {\n\tvar (\n\t\terr error\n\t\tstmt *sql.Stmt\n\t)\n\n\tlog.WithFields(log.Fields{\"entity\": entity}).Debug(\"repo.{{.Name}}.MergeWithRel entered\")\n\tif entity == nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity}).Info(\"repo.{{.Name}}.MergeWithRel Entity empty error\")\n\t\treturn moderrors.SaveEmptyEntityError\n\t}\n\n\tif tx == nil {\n\t\tif err = util.CheckContext(ctx); err != nil {\n\t\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.Merge context error\")\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t\t\n\t\ttx, err = StartTransaction(ctx)\n\t\tif err != nil {\n\t\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.MergeWithRel StartTransaction error\")\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t}\n\n\tif entity.ID == {{pkeyPropertyEmptyVal .PrimaryKey}} {\n\t\treturn {{.Name}}Repo.Insert(ctx, entity, tx, autocommit)\n\t}\n\n\t{{range .Fields}}{{range .GetBefore \"merge\"}}\n\t{{end}}{{end}}\n\n\tstmt, err = tx.Prepare(`{{.SQLMerge}}`)\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"query\": `{{.SQLMerge}}`, \"error\": err}).Error(\"repo.{{.Name}}.MergeWithRel query error\")\n\t\treturn errors.WithStack(err)\n\t}\n\n\t{{if .CrudHooks.PreSave}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.MergeWithRel context error\")\n\t\treturn errors.WithStack(err)\n\t}\n\n    if err = repo.preSave(ctx, tx, models.Merge, entity); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.MergeWithRel hook preSave error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t{{end}}\n\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.MergeWithRel context error\")\n\t\treturn errors.WithStack(err)\n\t}\n\t_, err = stmt.Exec({{.GetStruct \"merge\"}})\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.MergeWithRel query exec error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\t{{range .Relationships}}{{if (eq \"many-many-owner\" .Type) }}\n\terr = repo.Save{{.Name}}(ctx, tx, false, entity.ID, entity.{{$.Name}}...)\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Error(\"repo.{{$.Name}}.MergeWithRel load related {{.Name}} error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{$.Name}}.MergeWithRel context error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t{{end}}{{end}}\n\n\t{{if .CrudHooks.PostSave}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.MergeWithRel context error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\tif err = repo.postSave(ctx, \"MERGE\", entity, tx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.MergeWithRel hook postSave error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\tlog.WithFields(log.Fields{\"entity\": entity}).Debug(\"repo.{{.Name}}.MergeWithRel hook postSave executed\")\n\t{{end}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.MergeWithRel context error\")\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif autocommit {\n\t\terr = tx.Commit()\n\t\tif err != nil {\n\t\t\tlog.WithFields(log.Fields{\"entity\": entity, \"error\": err}).Info(\"repo.{{.Name}}.MergeWithRel commit error\")\n\t\t\ttx.Rollback()\n\t\t}\n\t}\n\n\treturn errors.WithStack(err)\n}\n\n{{range .Relationships}}\n{{if or (eq \"many-many-owner\" .Type) (eq \"many-many-inverse\" .Type) }}\n// Load{{.Name}} is a helper function to load related {{.Name}} entities\nfunc (repo {{$.Name}}Repositorium) Load{{.Name}}(ctx context.Context, entities ...*{{$.Name}}) error {\n\tvar (\n\t\terr error\n\t\tplaceholder string\n\t\tvalues  []interface{}\n\t\tindices = make(map[{{.ThisType}}][]*{{$.Name}})\n\t)\n\n\tlog.WithFields(log.Fields{\"entities\": entities}).Debug(\"repo.{{$.Name}}.Load entered\")\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entities\": entities, \"error\": err}).Info(\"repo.{{$.Name}}.Load context error\")\n\t\treturn errors.WithStack(err)\n\t} else if len(entities) == 0 {\n\t\treturn nil\n\t}\n\n\tc := 1\n\tfor _, entity := range entities {\n\t\tplaceholder += \"$\" + strconv.Itoa(c) + \",\"\n\t\tindices[entity.ID] = append(indices[entity.ID], entity)\n\t\tvalues = append(values, entity.ID)\n\t\tc++\n\t}\n\tplaceholder = strings.TrimRight(placeholder, \",\")\n\n\trows, err := repo.db.QueryContext(ctx, `\n\t\t{{$.SQLLoadManyMany .related}} (`+placeholder+`)\n\t`, values...)\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"entities\": entities, \"query\": `{{$.SQLLoadManyMany .related}} (`+placeholder+`)`, \"error\": err}).Error(\"repo.{{$.Name}}.Load query error\")\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entities\": entities, \"error\": err}).Info(\"repo.{{$.Name}}.Load context error\")\n\t\treturn errors.WithStack(err)\n\t}\n\n\tfor rows.Next() {\n\t\tvar (\n\t\t\tthisID {{.ThisType}}\n\t\t\tentity {{.related.Name}}\n\t\t)\n\t\t{{range .related.Fields}}{{range .GetBefore \"list\"}}\n\t\t{{end}}{{end}}\n\t\terr = rows.Scan(&thisID, {{.related.GetStruct \"list\"}})\n\t\tif err != nil {\n\t\t\tlog.WithFields(log.Fields{\"entities\": entities, \"query\": `{{$.SQLLoadManyMany .related}} (`+placeholder+`)`, \"fields\": \"{{.related.GetStruct \"list\"}}\", \"error\": err}).Error(\"repo.{{$.Name}}.Load scan error\")\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t\t{{range .related.Fields}}{{range .GetAfter \"list\"}}\n\t\t{{end}}{{end}}\n\t\t\n\t\tfor i := range indices[thisID] {\n\t\t\tindices[thisID][i].{{.Name}} = append(indices[thisID][i].{{.Name}}, &entity)\n\t\t}\n\t\t\n\t\tif err = util.CheckContext(ctx); err != nil {\n\t\t\tlog.WithFields(log.Fields{\"entities\": entities, \"error\": err}).Info(\"repo.{{$.Name}}.Load context error\")\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t}\n\n\treturn nil\n}\n{{else if (eq \"many-one\" .Type) }}\n// Load{{.Name}} is a helper function to load related {{.Name}} entities\nfunc (repo {{$.Name}}Repositorium) Load{{.Name}}(ctx context.Context, entities ...*{{$.Name}}) error {\n\tvar (\n\t\terr error\n\t\tplaceholder string\n\t\tvalues  []interface{}\n\t\tindices = make(map[string][]*{{$.Name}})\n\t)\n\n\tlog.WithFields(log.Fields{\"entities\": entities}).Debug(\"repo.{{$.Name}}.Load entered\")\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entities\": entities, \"error\": err}).Info(\"repo.{{$.Name}}.Load context error\")\n\t\treturn errors.WithStack(err)\n\t} else if len(entities) == 0 {\n\t\treturn nil\n\t}\n\n\tc := 1\n\tfor _, entity := range entities {\n\t\tplaceholder += \"$\" + strconv.Itoa(c) + \",\"\n\t\tindices[entity.{{.ThisID}}] = append(indices[entity.{{.ThisID}}], entity)\n\t\tvalues = append(values, entity.{{.ThisID}})\n\t\tc++\n\t}\n\tplaceholder = strings.TrimRight(placeholder, \",\")\n\trows, err := repo.db.QueryContext(ctx, `\n\t\t{{$.SQLLoadManyOne .related}} (`+placeholder+`)\n\t`, values...)\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"entities\": entities, \"query\": `{{$.SQLLoadManyOne .related}} (`+placeholder+`)`, \"error\": err}).Error(\"repo.{{$.Name}}.Load query error\")\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entities\": entities, \"error\": err}).Info(\"repo.{{$.Name}}.Load context error\")\n\t\treturn errors.WithStack(err)\n\t}\n\n\tfor rows.Next() {\n\t\tvar (\n\t\t\tthatID string\n\t\t\tthatEntity {{.related.Name}}\n\t\t)\n\t\t{{range .related.Fields}}{{range .GetBefore \"list\"}}\n\t\t{{end}}{{end}}\n\t\terr = rows.Scan(&thatID, {{.related.GetStruct \"list\"}})\n\t\tif err != nil {\n\t\t\tlog.WithFields(log.Fields{\"entities\": entities, \"query\": `{{$.SQLLoadManyOne .related}} (`+placeholder+`)`, \"fields\": \"{{.related.GetStruct \"list\"}}\", \"error\": err}).Error(\"repo.{{$.Name}}.Load scan error\")\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t\t{{range .related.Fields}}{{range .GetAfter \"list\"}}\n\t\t{{end}}{{end}}\n\n\t\tfor i := range indices[thatID] {\n\t\t\tindices[thatID][i].{{.Name}} = &thatEntity\n\t\t}\n\t\t\n\t\tif err = util.CheckContext(ctx); err != nil {\n\t\t\tlog.WithFields(log.Fields{\"entities\": entities, \"error\": err}).Info(\"repo.{{$.Name}}.Load context error\")\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t}\n\n\treturn nil\n}\n{{else if (eq \"one-many\" .Type) }}\n// Load{{.Name}} is a helper function to load related {{.Name}} entities\nfunc (repo {{$.Name}}Repositorium) Load{{.Name}}(ctx context.Context, entities ...*{{$.Name}}) error {\n\tvar (\n\t\terr error\n\t\tplaceholder string\n\t\tvalues  []interface{}\n\t\tindices = make(map[{{.ThisType}}][]*{{$.Name}})\n\t)\n\n\tlog.WithFields(log.Fields{\"entities\": entities}).Debug(\"repo.{{$.Name}}.Load entered\")\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entities\": entities, \"error\": err}).Info(\"repo.{{$.Name}}.Load context error\")\n\t\treturn errors.WithStack(err)\n\t} else if len(entities) == 0 {\n\t\treturn nil\n\t}\n\n\tc := 1\n\tfor _, entity := range entities {\n\t\tplaceholder += \"$\" + strconv.Itoa(c) + \",\"\n\t\tindices[entity.ID] = append(indices[entity.ID], entity)\n\t\tvalues = append(values, entity.ID)\n\t\tc++\n\t}\n\tplaceholder = strings.TrimRight(placeholder, \",\")\n\n\trows, err := repo.db.QueryContext(ctx, `\n\t\t{{$.SQLLoadOneMany .related}} (`+placeholder+`)\n\t`, values...)\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"entities\": entities, \"query\": `{{$.SQLLoadOneMany .related}} (`+placeholder+`)`, \"error\": err}).Error(\"repo.{{$.Name}}.Load query error\")\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"entities\": entities, \"error\": err}).Info(\"repo.{{$.Name}}.Load context error\")\n\t\treturn errors.WithStack(err)\n\t}\n\n\tfor rows.Next() {\n\t\tvar (\n\t\t\tthisID {{.ThisType}}\n\t\t\tentity {{.related.Name}}\n\t\t)\n\t\t\n\t\t{{range .related.Fields}}{{range .GetBefore \"list\"}}\n\t\t{{end}}{{end}}\n\t\terr = rows.Scan(&thisID, {{.related.GetStruct \"list\"}})\n\t\tif err != nil {\n\t\t\tlog.WithFields(log.Fields{\"entities\": entities, \"query\": `{{$.SQLLoadOneMany .related}} (`+placeholder+`)`, \"fields\": \"{{.related.GetStruct \"list\"}}\", \"error\": err}).Error(\"repo.{{$.Name}}.Load scan error\")\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t\t{{range .related.Fields}}{{range .GetAfter \"list\"}}\n\t\t{{end}}{{end}}\n\t\t\n\t\tfor i := range indices[thisID] {\n\t\t\tindices[thisID][i].{{.Name}} = append(indices[thisID][i].{{.Name}}, &entity)\n\t\t}\n\t\t\n\t\tif err = util.CheckContext(ctx); err != nil {\n\t\t\tlog.WithFields(log.Fields{\"entities\": entities, \"error\": err}).Info(\"repo.{{$.Name}}.Load context error\")\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t}\n\n\treturn nil\n}\n{{end}}\n{{end}}\n\n{{range .Relationships}}\n{{if or (eq \"many-many-owner\" .Type) }}\n// Save{{.Name}} is a helper function to save related {{.Name}} in a pivot table (many-many-owner relationship)\nfunc (repo {{$.Name}}Repositorium) Save{{.Name}}(ctx context.Context, tx *sql.Tx, autocommit bool, idthis string, relatives ...string) error {\n\tvar (\n\t\tstmt *sql.Stmt\n\t\terr  error\n\t)\n\n\tlog.WithFields(log.Fields{\"id\": idthis, \"relatives\": relatives}).Debug(\"repo.{{$.Name}}.Save entered\")\n\tif tx == nil {\n\t\tif err = util.CheckContext(ctx); err != nil {\n\t\t\tlog.WithFields(log.Fields{\"id\": idthis, \"relatives\": relatives}).Info(\"repo.{{$.Name}}.Save context error\")\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\n\t\ttx, err = StartTransaction(ctx)\n\t\tif err != nil {\n\t\t\tlog.WithFields(log.Fields{\"id\": idthis, \"relatives\": relatives, \"error\": err}).Info(\"repo.{{$.Name}}.Save StartTransaction error\")\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t}\n\n\tstmt, err = tx.Prepare(\"{{$.SQLSaveManyManyOwnerDelete .related}}\")\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"id\": idthis, \"relatives\": relatives, \"query\": \"{{$.SQLSaveManyManyOwnerDelete .related}}\", \"error\": err}).Error(\"repo.{{$.Name}}.Save query error\")\n\t\treturn errors.WithStack(err)\n\t}\n\n\t_, err = stmt.Exec(idthis)\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"id\": idthis, \"relatives\": relatives, \"error\": err}).Info(\"repo.{{$.Name}}.Save query exec error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"id\": idthis, \"relatives\": relatives}).Info(\"repo.{{$.Name}}.Save context error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\tstmt, err = tx.Prepare(\"{{$.SQLSaveManyManyOwnerInsert .related}}\")\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"id\": idthis, \"relatives\": relatives, \"query\": \"{{$.SQLSaveManyManyOwnerInsert .related}}\", \"error\": err}).Error(\"repo.{{$.Name}}.Save query error\")\n\t\treturn errors.WithStack(err)\n\t}\n\n\tfor _, rel := range relatives {\n\t\tif err = util.CheckContext(ctx); err != nil {\n\t\t\tlog.WithFields(log.Fields{\"id\": idthis, \"relatives\": relatives}).Info(\"repo.{{$.Name}}.Save context error\")\n\t\t\ttx.Rollback()\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\n\t\t_, err = stmt.Exec(idthis, rel.ID)\n\t\tif err != nil {\n\t\t\tlog.WithFields(log.Fields{\"id\": idthis, \"relatives\": relatives, \"error\": err}).Info(\"repo.{{$.Name}}.Save query exec \" + rel.Name + \" error\")\n\t\t\ttx.Rollback()\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t}\n\n\tif autocommit {\n\t\terr = tx.Commit()\n\t\tif err != nil {\n\t\t\tlog.WithFields(log.Fields{\"id\": idthis, \"relatives\": relatives, \"error\": err}).Info(\"repo.{{$.Name}}.Save commit error\")\n\t\t\ttx.Rollback()\n\t\t}\n\t}\n\n\treturn errors.WithStack(err)\n}\n\n// Save{{.Name}}IDs is a helper function to save related {{.Name}} IDs in a pivot table (many-many-owner relationship)\nfunc (repo {{$.Name}}Repositorium) Save{{.Name}}IDs(ctx context.Context, tx *sql.Tx, autocommit bool, idthis string, relatives ... string) error {\n\tvar (\n\t\tstmt *sql.Stmt\n\t\terr  error\n\t)\n\n\tlog.WithFields(log.Fields{\"id\": idthis, \"relatives\": relatives}).Debug(\"repo.{{$.Name}}.Save{{.Name}}IDs entered\")\n\tif tx == nil {\n\t\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"id\": idthis, \"relatives\": relatives}).Info(\"repo.{{$.Name}}.Save{{.Name}}IDs context error\")\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\n\t\ttx, err = StartTransaction(ctx)\n\t\tif err != nil {\n\t\t\tlog.WithFields(log.Fields{\"id\": idthis, \"relatives\": relatives, \"error\": err}).Info(\"repo.{{$.Name}}.Save{{.Name}}IDs StartTransaction error\")\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t}\n\t\n\tstmt, err = tx.Prepare(\"{{$.SQLSaveManyManyOwnerDelete .related}}\")\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"id\": idthis, \"relatives\": relatives, \"query\": \"{{$.SQLSaveManyManyOwnerDelete .related}}\", \"error\": err}).Error(\"repo.{{$.Name}}.Save{{.Name}}IDs query error\")\n\t\treturn errors.WithStack(err)\n\t}\n\n\t_, err = stmt.Exec(idthis)\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"id\": idthis, \"relatives\": relatives, \"error\": err}).Info(\"repo.{{$.Name}}.Save{{.Name}}IDs query exec error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif err = util.CheckContext(ctx); err != nil {\n\t\tlog.WithFields(log.Fields{\"id\": idthis, \"relatives\": relatives}).Info(\"repo.{{$.Name}}.Save{{.Name}}IDs context error\")\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\tstmt, err = tx.Prepare(\"{{$.SQLSaveManyManyOwnerInsert .related}}\")\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"id\": idthis, \"relatives\": relatives, \"query\": \"{{$.SQLSaveManyManyOwnerInsert .related}}\", \"error\": err}).Error(\"repo.{{$.Name}}.Save{{.Name}}IDs query error\")\n\t\treturn errors.WithStack(err)\n\t}\n\n\tfor _, relid := range relatives {\n\t\tif err = util.CheckContext(ctx); err != nil {\n\t\t\tlog.WithFields(log.Fields{\"id\": idthis, \"relatives\": relatives}).Info(\"repo.{{$.Name}}.Save{{.Name}}IDs context error\")\n\t\t\ttx.Rollback()\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\n\t\t_, err = stmt.Exec(idthis, relid)\n\t\tif err != nil {\n\t\t\tlog.WithFields(log.Fields{\"id\": idthis, \"relatives\": relatives, \"error\": err}).Info(\"repo.{{$.Name}}.Save{{.Name}}IDs query exec \" + relid + \" error\")\n\t\t\ttx.Rollback()\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t}\n\n\tif autocommit {\n\t\terr = tx.Commit()\n\t\tif err != nil {\n\t\t\tlog.WithFields(log.Fields{\"id\": idthis, \"relatives\": relatives, \"error\": err}).Info(\"repo.{{$.Name}}.Save{{.Name}}IDs commit error\")\n\t\t\ttx.Rollback()\n\t\t}\n\t}\n\n\treturn errors.WithStack(err)\n}\n{{end}}\n{{end}}\n\n{# {{range .LoadRelated}}{{.}}{{end}}\n{{range .SaveRelated}}{{.}}{{end}} #}\n\n//[END] {{.Name}}\n{{end}}"),
	}
	filel := &embedded.EmbeddedFile{
		Filename:    "crud/hooks.go.tmpl",
		FileModTime: time.Unix(1539936852, 0),
		Content:     string("package models\nimport (\n\t\"database/sql\"\n)\n\n{{if .CrudHooks.PreRead}}\nfunc crudPreGet(id string) error {\n\treturn nil\n}\n{{end}}\n{{if .CrudHooks.PostRead}}\nfunc crudPostGet(entity *{{.Name}}) error {\n\treturn nil\n}\n{{end}}\n\n{{if .CrudHooks.PreList}}\nfunc crudPreList(filters []models.ListFilter) ([]ListFilter, error) {\n\treturn filters, nil\n}\n{{end}}\n{{if .CrudHooks.PostList}}\nfunc crudPostList(list []*{{.Name}}) ([]*{{.Name}}, error) {\n\treturn list, nil\n}\n{{end}}\n\n{{if .CrudHooks.PreDelete}}\nfunc crudPreDelete(id string, tx *sql.Tx) error {\n\treturn nil\n}\n{{end}}\n{{if .CrudHooks.PostDelete}}\nfunc crudPostDelete(id string, tx *sql.Tx) error {\n\treturn nil\n}\n{{end}}\n\n\n{{if .CrudHooks.PreSave }}\nfunc crudPreSave(op string, entity *{{.Name}}, tx *sql.Tx) error {\n\treturn nil\n}\n{{end}}\n{{if .CrudHooks.PreSave }}\nfunc crudPostSave(op string, entity *{{.Name}}, tx *sql.Tx) error {\n\treturn nil\n}\n{{end}}\n\n"),
	}
	filem := &embedded.EmbeddedFile{
		Filename:    "crud/models.go.tmpl",
		FileModTime: time.Unix(1539936852, 0),
		Content:     string("package models\n\nvar (\n\tdb *sql.DB\n\t{{range .Entities}}\n\t// {{.Name}}Repo provides interaction with database content repository for {{.Name}}\n\t{{.Name}}Repo {{.Name}}Repository\n\t{{- end}}\n)\n\nconst (\n\t// OperationMerge indicates a Merge save operation is under way\n\tOperationMerge  byte = 'M'\n\t// OperationInsert indicates a Insert save operation is under way\n\tOperationInsert byte = 'I'\n\t// OperationUpdate indicates a Update save operation is under way\n\tOperationUpdate byte = 'U'\n\n\t// NoOffset indicates List/Select queries without offset clause\n\tNoOffset = -1\n\t// NoLimit indicates List/Select queries without limit clause\n\tNoLimit  = -1\n)\n\n// Filter represents a filter to apply during listing (crud)\ntype Filter struct {\n\tField     string\n\tOperation string\n\tValue     interface{}\n}\n\n// Init is responsible to initialize all repositories\nfunc Init(database *sql.DB) {\n\tdb = database\n\t{{range .Entities}}\n\t{{.Name}}Repo = {{.Name}}Repositorium{db: database}\n\t{{- end}}\n}\n\n// StartTransaction initiates a database transaction\nfunc StartTransaction(ctx context.Context) (*sql.Tx, error) {\n\treturn db.BeginTx(ctx, nil)\n}\n\n{{- $Entities := .Entities -}}\n{{range .Entities }}\n// {{.Name}}Repository encapsulates operations that may be performed on the entity {{.Name}}\ntype {{.Name}}Repository interface {\n{{if $.Crud -}}\n\t// Insert performs an SQL insert for {{.Name}} record and update instance with inserted id.\n\tInsert(ctx context.Context, entity *{{.Name}}, tx *sql.Tx, autocommit bool) error\t\n\t// InsertWithRel performs an SQL insert for {{.Name}} record and update instance with inserted id; including related entities. Prefer using Save instead of Insert directly.\n\tInsertWithRel(ctx context.Context, entity *{{.Name}}, tx *sql.Tx, autocommit bool) error\n\t\n\t// Get returns a single {{.Name}} from database by primary key\n\tGet(ctx context.Context, id string) (*{{.Name}}, error)\n\t// GetWithRel returns a single {{.Name}} from database by primary key; loads related entities\n\tGetWithRel(ctx context.Context, id string) (*{{.Name}}, error)\n\t\n\t// List returns a slice containing {{.Name}} records\n\tList(ctx context.Context, opts *ListOpts, filters ...*Filter) ([]*{{.Name}}, error)\n\t// ListWithRel returns a slice containing {{.Name}} records; will also load related entities.\n\tListWithRel(ctx context.Context, opts *ListOpts, filters ...*Filter) ([]*{{.Name}}, error)\n\t\n\t// Select returns a slice containing {{.Name}} records according to a custom SQL condition\n\tSelect(ctx context.Context, opts *ListOpts, condition string, values ...interface{}) ([]*{{.Name}}, error)\n\t// SelectWithRel returns a slice containing {{.Name}} records according to a custom SQL condition; will also load related entities.\n\tSelectWithRel(ctx context.Context, opts *ListOpts, condition string, values ...interface{}) ([]*{{.Name}}, error)\n\t\n\t// Update Will execute an SQLUpdate Statement for {{.Name}} in the database. Prefer using Save instead of Update directly.\n\tUpdate(ctx context.Context, entity *{{.Name}}, tx *sql.Tx, autocommit bool) error\n\t// UpdateWithRel Will execute an SQLUpdate Statement for {{.Name}} in the database; including related entities. Prefer using Save instead of Update directly.\n\tUpdateWithRel(ctx context.Context, entity *{{.Name}}, tx *sql.Tx, autocommit bool) error\n\t// DeleteMany deletes many {{.Name}} records from database using filter\n\tDeleteMany(ctx context.Context, tx *sql.Tx, autocommit bool, filters ...*Filter) error\n\t// Delete deletes a {{.Name}} record from database and sets id to nil\n\tDelete(ctx context.Context, entity *{{.Name}}, tx *sql.Tx, autocommit bool) error\n\t\n\t// Merge performs an SQL merge for {{.Name}} record.\n\tMerge(ctx context.Context, entity *{{.Name}}, tx *sql.Tx, autocommit bool) error\n\t// Save either inserts or updates a {{.Name}} record based on whether or not id is nil\n\tSave(ctx context.Context, entity *{{.Name}}, tx *sql.Tx, autocommit bool) error\n\t// SaveWithRel either inserts or updates a {{.Name}} record based on whether or not id is nil; will also save related entities\n\tSaveWithRel(ctx context.Context, entity *{{.Name}}, tx *sql.Tx, autocommit bool) error\n{{end -}}\n\n{{- $ThisEntity := . -}}\n{{range .Relationships -}}\n{{if eq .Type \"many-many-inverse\" -}}\n\t// Load{{RelFuncName .}} is a helper function to load related {{.Name}} entities\n\tLoad{{RelFuncName .}}(ctx context.Context, entities ...*{{$ThisEntity.Name}}) error\n{{end -}}\n{{if or (eq .Type \"many-many\") (eq .Type \"many-many-owner\") -}}\n\t// Load{{RelFuncName .}} is a helper function to load related {{.Name}} entities\n\tLoad{{RelFuncName .}}(ctx context.Context, entities ...*{{$ThisEntity.Name}}) error\n\t// Save{{RelFuncName .}} is a helper function to save related {{.Name}} in a pivot table (many-many relationship)\n\tSave{{RelFuncName .}}(ctx context.Context, tx *sql.Tx, autocommit bool, idthis string, relatives ...*{{fkeyPropertyTypeName $Entities .}}) error\n\t// Save{{RelFuncName .}}IDs is a helper function to save related {{.Name}} IDs in a pivot table (many-many relationship)\n\tSave{{RelFuncName .}}IDs(ctx context.Context, tx *sql.Tx, autocommit bool, idthis string, relatives ...) error\n{{end -}}\n{{if eq .Type \"one-many\" -}}\n\t// Load{{RelFuncName .}} is a helper function to load related {{.Name}} entities\n\tLoad{{RelFuncName .}}(ctx context.Context, entities ...*{{$ThisEntity.Name}}) error\n{{end -}}\n{{if eq .Type \"many-one\" -}}\n\t// Load{{RelFuncName .}} is a helper function to load related {{.Name}} entities\n\tLoad{{RelFuncName .}}(ctx context.Context, entities ...*{{$ThisEntity.Name}}) error\n{{end -}}\n{{end -}}\n}\n\n// {{.Name}}Repositorium implements {{.Name}}Repository\ntype {{.Name}}Repositorium struct {\n\tdb *sql.DB\n}\n{{end}}\n\n// QueryAddIN adds IN condition to query\nfunc QueryAddIN(segments []string, values []interface{}, index *int, fieldname string, val interface{}, not bool) ([]string, []interface{}, error) {\n\tvar subsegments []string\n\n\tif data, ok := val.([]bool); ok {\n\t\tfor d := range data {\n\t\t\t*index += 1\n\t\t\tsubsegments = append(subsegments, \"$\"+strconv.Itoa(*index))\n\t\t\tvalues = append(values, data[d])\n\t\t}\n\t} else if data, ok := val.([]byte); ok {\n\t\tfor d := range data {\n\t\t\t*index += 1\n\t\t\tsubsegments = append(subsegments, \"$\"+strconv.Itoa(*index))\n\t\t\tvalues = append(values, data[d])\n\t\t}\n\t} else if data, ok := val.([]complex64); ok {\n\t\tfor d := range data {\n\t\t\t*index += 1\n\t\t\tsubsegments = append(subsegments, \"$\"+strconv.Itoa(*index))\n\t\t\tvalues = append(values, data[d])\n\t\t}\n\t} else if data, ok := val.([]complex128); ok {\n\t\tfor d := range data {\n\t\t\t*index += 1\n\t\t\tsubsegments = append(subsegments, \"$\"+strconv.Itoa(*index))\n\t\t\tvalues = append(values, data[d])\n\t\t}\n\t} else if data, ok := val.([]float32); ok {\n\t\tfor d := range data {\n\t\t\t*index += 1\n\t\t\tsubsegments = append(subsegments, \"$\"+strconv.Itoa(*index))\n\t\t\tvalues = append(values, data[d])\n\t\t}\n\t} else if data, ok := val.([]float64); ok {\n\t\tfor d := range data {\n\t\t\t*index += 1\n\t\t\tsubsegments = append(subsegments, \"$\"+strconv.Itoa(*index))\n\t\t\tvalues = append(values, data[d])\n\t\t}\n\t} else if data, ok := val.([]int); ok {\n\t\tfor d := range data {\n\t\t\t*index += 1\n\t\t\tsubsegments = append(subsegments, \"$\"+strconv.Itoa(*index))\n\t\t\tvalues = append(values, data[d])\n\t\t}\n\t} else if data, ok := val.([]int8); ok {\n\t\tfor d := range data {\n\t\t\t*index += 1\n\t\t\tsubsegments = append(subsegments, \"$\"+strconv.Itoa(*index))\n\t\t\tvalues = append(values, data[d])\n\t\t}\n\t} else if data, ok := val.([]int16); ok {\n\t\tfor d := range data {\n\t\t\t*index += 1\n\t\t\tsubsegments = append(subsegments, \"$\"+strconv.Itoa(*index))\n\t\t\tvalues = append(values, data[d])\n\t\t}\n\t} else if data, ok := val.([]int32); ok {\n\t\tfor d := range data {\n\t\t\t*index += 1\n\t\t\tsubsegments = append(subsegments, \"$\"+strconv.Itoa(*index))\n\t\t\tvalues = append(values, data[d])\n\t\t}\n\t} else if data, ok := val.([]int64); ok {\n\t\tfor d := range data {\n\t\t\t*index += 1\n\t\t\tsubsegments = append(subsegments, \"$\"+strconv.Itoa(*index))\n\t\t\tvalues = append(values, data[d])\n\t\t}\n\t} else if data, ok := val.([]rune); ok {\n\t\tfor d := range data {\n\t\t\t*index += 1\n\t\t\tsubsegments = append(subsegments, \"$\"+strconv.Itoa(*index))\n\t\t\tvalues = append(values, data[d])\n\t\t}\n\t} else if data, ok := val.([]string); ok {\n\t\tfor d := range data {\n\t\t\t*index += 1\n\t\t\tsubsegments = append(subsegments, \"$\"+strconv.Itoa(*index))\n\t\t\tvalues = append(values, data[d])\n\t\t}\n\t} else if data, ok := val.([]uint); ok {\n\t\tfor d := range data {\n\t\t\t*index += 1\n\t\t\tsubsegments = append(subsegments, \"$\"+strconv.Itoa(*index))\n\t\t\tvalues = append(values, data[d])\n\t\t}\n\t} else if data, ok := val.([]uint8); ok {\n\t\tfor d := range data {\n\t\t\t*index += 1\n\t\t\tsubsegments = append(subsegments, \"$\"+strconv.Itoa(*index))\n\t\t\tvalues = append(values, data[d])\n\t\t}\n\t} else if data, ok := val.([]uint16); ok {\n\t\tfor d := range data {\n\t\t\t*index += 1\n\t\t\tsubsegments = append(subsegments, \"$\"+strconv.Itoa(*index))\n\t\t\tvalues = append(values, data[d])\n\t\t}\n\t} else if data, ok := val.([]uint32); ok {\n\t\tfor d := range data {\n\t\t\t*index += 1\n\t\t\tsubsegments = append(subsegments, \"$\"+strconv.Itoa(*index))\n\t\t\tvalues = append(values, data[d])\n\t\t}\n\t} else if data, ok := val.([]uint64); ok {\n\t\tfor d := range data {\n\t\t\t*index += 1\n\t\t\tsubsegments = append(subsegments, \"$\"+strconv.Itoa(*index))\n\t\t\tvalues = append(values, data[d])\n\t\t}\n\t} else if data, ok := val.([]uintptr); ok {\n\t\tfor d := range data {\n\t\t\t*index += 1\n\t\t\tsubsegments = append(subsegments, \"$\"+strconv.Itoa(*index))\n\t\t\tvalues = append(values, data[d])\n\t\t}\t} else {\n\t\treturn nil, nil, moderrors.InFilterValueUnknownError\n\t}\n\n\tif len(subsegments) == 0 {\n\t\treturn nil, nil, moderrors.InFilterValueEmptyError\n\t}\n\n\tcondition := \" IN\"\n\tif not {\n\t\tcondition = \" NOT\" + condition\n\t}\n\n\tsegments = append(segments, fieldname+condition+\" (\"+strings.Join(subsegments, \",\")+\")\")\n\treturn segments, values, nil\n}\n"),
	}
	filen := &embedded.EmbeddedFile{
		Filename:    "crud/models.proto.tmpl",
		FileModTime: time.Unix(1539936852, 0),
		Content:     string("syntax = \"proto3\";\n\npackage models;\noption go_package = \"{{.AppImportPath}}/models\";\n\nimport \"google/protobuf/timestamp.proto\";\n\n//ListOpts contains options for listing, including Offset, Limit and Sort\nmessage ListOpts {\n\tint64 Offset = 1;\n\tint64 Limit = 2;\n\tstring Sort = 3;\n}\n\n{{ range .Entities -}}\n// {{.Name}} {{.Description}}\nmessage {{.Name}} { {{ range .GetProtoFields }}\n\t{{.}}\n{{- end}}\n}\n\n{{end}}\n"),
	}
	fileo := &embedded.EmbeddedFile{
		Filename:    "crud/moderrors.go.tmpl",
		FileModTime: time.Unix(1538482115, 0),
		Content:     string("package moderrors\n\nvar (\n\t// RecordNotFoundError indicates record not found when using Repository.Get()\n\tRecordNotFoundError = errors.New(\"record not found\")\n\n\t// InFilterValueUnknownError indicates that value for IN condition is not known\n\tInFilterValueUnknownError = errors.New(\"unknown filter value type for IN condition\")\n\n\t// InFilterValueEmptyError indicates that slice of values provided for IN condition is empty\n\tInFilterValueEmptyError = errors.New(\"filter values for IN condition empty\")\n\n\t// SaveEmptyEntityError indicates trying to save an empty entity\n\tSaveEmptyEntityError = errors.New(\"attempt to save an empty entity\")\n)\n"),
	}
	fileq := &embedded.EmbeddedFile{
		Filename:    "schema/schema.sql.tmpl",
		FileModTime: time.Unix(1539936852, 0),
		Content:     string("{{- range .Entities}}\nDROP TABLE IF EXISTS {{.Table}};\n\nCREATE TABLE {{.Table}} (\n\t{{- range .Fields}}\n\t{{.SchemaDefinition}},\n\t{{- end}}\n\t{{- range .GetForeignKeyFields}}\n\t{{.}},\n\t{{- end}}\n\t{{- range .TableConstraints}}\n\t{{.}},\n\t{{- end}}\n\tPRIMARY KEY (\"id\")\n);\n\n{{- range .GetRelatedTables}}\nDROP TABLE IF EXISTS {{.JoinTable}};\n\nCREATE TABLE {{.JoinTable}} (\n\t\"{{.ThisID}}\" TEXT NOT NULL,\n\t\"{{.ThatID}}\" TEXT NOT NULL\n);\n\nDROP INDEX IF EXISTS {{.JoinTable}}_{{.ThisID}};\nDROP INDEX IF EXISTS {{.JoinTable}}_{{.ThatID}};\n\nCREATE INDEX {{.JoinTable}}_{{.ThisID}} ON {{.JoinTable}} ({{.ThisID}});\nCREATE INDEX {{.JoinTable}}_{{.ThatID}} ON {{.JoinTable}} ({{.ThatID}});\n{{- end}}\n{{end}}"),
	}
	files := &embedded.EmbeddedFile{
		Filename:    "util/credentials.go.tmpl",
		FileModTime: time.Unix(1538482115, 0),
		Content:     string("package credentials\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\n// Credentials represents connection to a service having a protocol, identifier, password, host and port\ntype Credentials struct {\n\tProtocol   string\n\tIdentifier string\n\tPassword   string\n\tHost       string\n\tPort       string\n}\n\n// String returns a human friendly representation of the credentials\nfunc (c *Credentials) String() string {\n\treturn fmt.Sprintf(\"Protocol: %s Identifier: %s Password: %s Host: %s Port: %s\", c.Protocol, c.Identifier, c.Password, c.Host, c.Port)\n}\n\n// getProtocol returns Protocol portion of the credentials\nfunc (c *Credentials) GetProtocol() string {\n\treturn c.Protocol\n}\n\n// getIdentifier returns Identifier portion of the credentials\nfunc (c *Credentials) GetIdentifier() string {\n\treturn c.Identifier\n}\n\n// getPassword returns Password portion of the credentials\nfunc (c *Credentials) GetPassword() string {\n\treturn c.Password\n}\n\n// getHost returns Host portion of the credentials\nfunc (c *Credentials) GetHost() string {\n\treturn c.Host\n}\n\n// getPort returns Port portion of the credentials\nfunc (c *Credentials) GetPort() string {\n\treturn c.Port\n}\n\n\n// NewCredentials returns a connection from string in the format protocol://username:password@host:port\nfunc NewCredentials(conn string, defaults ...*Credentials) *Credentials {\n\tvar (\n\t\tcredentials   *Credentials\n\t\tcreds, server string\n\t)\n\n\tif len(defaults) == 1 {\n\t\tcredentials = defaults[0]\n\t} else {\n\t\tcredentials = new(Credentials)\n\t}\n\n\tif i := strings.Index(conn, \"://\"); i != -1 {\n\t\tcredentials.Protocol = conn[:i]\n\t\tconn = conn[i+3:]\n\t}\n\n\tif i := strings.Index(conn, \"@\"); i == -1 { //no username password\n\t\tserver = conn\n\t} else {\n\t\tcreds = conn[:i]\n\t\tserver = conn[i+1:]\n\t}\n\n\tif creds == \"\" {\n\t\t//do nothing\n\t} else if i := strings.Index(creds, \":\"); i != -1 { //both id and password\n\t\tcredentials.Identifier = creds[:i]\n\t\tcredentials.Password = creds[i+1:]\n\t} else { //only id\n\t\tcredentials.Identifier = creds\n\t}\n\n\tif server == \"\" {\n\t\t//do nothing\n\t} else if i := strings.Index(server, \":\"); i != -1 { //both host and port\n\t\tcredentials.Host = server[:i]\n\t\tcredentials.Port = server[i+1:]\n\t} else { //only host\n\t\tcredentials.Host = conn\n\t}\n\n\treturn credentials\n}\n"),
	}
	filet := &embedded.EmbeddedFile{
		Filename:    "util/files.go.tmpl",
		FileModTime: time.Unix(1539936849, 0),
		Content:     string("package files\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"time\"\n\n\t\"{{.AppImportPath}}/util\"\n\t\"{{.AppImportPath}}/util/web\"\n\t\"{{.AppImportPath}}/util/imagist\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/gosimple/slug\"\n)\n\n// Constants for files package\nconst (\n\t_fileMode = os.FileMode(0644)\n)\n\n// UploadOptions holds file upload options\ntype UploadOptions struct {\n\tDir            string\n\tDestination    string\n\tMediaPrefixURL string\n\tFileType       int\n\tMaxSize        int\n\tConvertTo      string\n\tImgDimensions  *imagist.ImageDimensions\n}\n\n// supported file types by fileupload\nconst (\n\tTypeInvalid = iota\n\tTypeImage\n\tTypeVideo\n)\n\nvar (\n\t// DefaultUploadOptions holds default upload options\n\tDefaultUploadOptions = &UploadOptions{\n\t\tFileType:      TypeImage,\n\t\tMaxSize:       util.NoLimit,\n\t\tImgDimensions: &imagist.DefaultDimensions,\n\t}\n\n\t_imagist *imagist.Imagist\n)\n\nfunc init() {\n\t_imagist = imagist.New()\n}\n\n// Upload validates and saves create file\nfunc Upload(fileName string, fileContent []byte, options *UploadOptions) (string, string, error) {\n\tdirPath := path.Join(options.Dir, options.Destination)\n\tfileName = buildFileName(fileName)\n\tfilePath := path.Join(options.MediaPrefixURL, options.Destination, fileName)\n\tfileDiskPath := filepath.Join(dirPath, fileName)\n\n\t// Create full directory structure to store image\n\tif err := os.MkdirAll(dirPath, os.ModePerm); err != nil {\n\t\tlog.Printf(\"error creating directories: %v\\n\", err)\n\t\treturn fileDiskPath, filePath, err\n\t}\n\n\t// Create file on disk if it does not exist\n\tif _, err := os.Stat(fileDiskPath); os.IsNotExist(err) {\n\t\tif err := ioutil.WriteFile(fileDiskPath, fileContent, _fileMode); err != nil {\n\t\t\tlog.Printf(\"error writing %v: %v\\n\", fileDiskPath, err)\n\t\t\treturn fileDiskPath, filePath, err\n\t\t}\n\t}\n\n\tfile, err := os.Open(fileDiskPath)\n\tif err != nil {\n\t\tlog.Printf(\"error opening %v: %v\\n\", fileDiskPath, err)\n\t\treturn fileDiskPath, filePath, err\n\t}\n\tdefer file.Close()\n\n\tbuf, err := ioutil.ReadFile(fileDiskPath)\n\tif err != nil {\n\t\tlog.Printf(\"error reading %v: %v\\n\", fileDiskPath, err)\n\t\treturn fileDiskPath, filePath, err\n\t}\n\n\tfileSize := len(buf)\n\tif options.MaxSize != util.NoLimit && fileSize > options.MaxSize {\n\t\tlog.Printf(\"file %v greater than max file size: %v\\n\", fileName, options.MaxSize)\n\t\treturn fileDiskPath, filePath, fmt.Errorf(\"file max size error\")\n\t}\n\n\tif options.ConvertTo != \"\" {\n\t\tfileDiskPath, filePath, err = changeExt(fileDiskPath, filePath, options.ConvertTo)\n\t\tif err != nil {\n\t\t\treturn fileDiskPath, filePath, err\n\t\t}\n\t}\n\n\tswitch options.FileType {\n\tcase TypeImage:\n\t\terr := _imagist.Add(buf, fileDiskPath, options.ImgDimensions, true)\n\t\treturn fileDiskPath, filePath, err\n\tcase TypeVideo:\n\t\t// TODO: Not yet implemented\n\tdefault:\n\t\t// Invalid file type in config\n\t\t// Do nothing\n\t}\n\n\treturn fileDiskPath, filePath, nil\n}\n\n// Delete deletes one file\nfunc Delete(fp string) error {\n\tif err := os.Remove(fp); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc buildFileName(oldFilename string) string {\n\toldExt := filepath.Ext(oldFilename)\n\tnewFilename := strings.TrimSuffix(oldFilename, oldExt)\n\treturn slug.Make(newFilename) + \"_\" + time.Now().Format(\"20060102150405\") + oldExt\n}\n\nfunc changeExt(fileDiskPath, filepath string, newExt string) (string, string, error) {\n\toldExt := path.Ext(fileDiskPath)\n\tnewExt = \".\" + newExt\n\tnewfileDiskPath := strings.TrimSuffix(fileDiskPath, oldExt) + newExt\n\tnewfilePath := strings.TrimSuffix(filepath, oldExt) + newExt\n\n\tif err := os.Rename(fileDiskPath, newfileDiskPath); err != nil {\n\t\treturn fileDiskPath, filepath, fmt.Errorf(\"image ext change to %v failed\", newExt)\n\t}\n\n\treturn newfileDiskPath, newfilePath, nil\n}\n\n// httpImageDirHandler is an http.Handler that serves a directory.\n// If a generated file is missing, it yields a temporary redirect to the original file.\ntype httpImageDirHandler struct {\n\troot   http.FileSystem\n\tprefix string\n\topts   *UploadOptions\n}\n\nfunc (s httpImageDirHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tp := r.URL.Path\n\n\tvar suffix string\n\tfor _, format := range s.opts.ImgDimensions.Formats {\n\t\tformatSuffix := \":\" + format.Name\n\t\tif strings.HasSuffix(p, formatSuffix) {\n\t\t\tsuffix = formatSuffix\n\t\t}\n\t}\n\n\tif suffix == \"\" {\n\t\t//a previous attempt to lookup the file resulted into a call to this function\n\t\t//do not attempt to look up again\n\t\tw.WriteHeader(http.StatusNotFound)\n\t\tw.Write([]byte(\"Not found\"))\n\t\treturn\n\t}\n\n\tnoSuffix := strings.TrimSuffix(p, suffix)\n\tp = path.Join(s.prefix, noSuffix)\n\n\tgo func() {\n\t\tvar buf []byte\n\n\t\tdirPath := path.Join(s.opts.Dir, s.opts.Destination)\n\t\tfileName := strings.TrimPrefix(noSuffix, \"/\"+s.opts.Destination)\n\t\tfileDiskPath := filepath.Join(dirPath, fileName)\n\n\t\tbuf, err := ioutil.ReadFile(fileDiskPath)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"error opening %v: %v\\n\", fileDiskPath, err)\n\t\t}\n\n\t\t_imagist.Add(buf, fileDiskPath, s.opts.ImgDimensions, false)\n\n\t}()\n\thttp.Redirect(w, r, p, http.StatusTemporaryRedirect)\n}\n\n//HTTPImageDirHandler serves images from a directory with imagist fallback\nfunc HTTPImageDirHandler(router *mux.Router, root http.FileSystem, prefix string, paths map[string]*UploadOptions) {\n\tfor path, opts := range paths {\n\t\th := web.FileServerWithNotFoundHandler(root, httpImageDirHandler{root: root, prefix: prefix, opts: opts})\n\t\trouter.PathPrefix(prefix + \"/\" + path).Handler(http.StripPrefix(prefix, h))\n\t}\n}\n"),
	}
	fileu := &embedded.EmbeddedFile{
		Filename:    "util/imagist.go.tmpl",
		FileModTime: time.Unix(1539936852, 0),
		Content:     string("package imagist\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"image\"\n\t\"image/color\"\n\t\"image/gif\"\n\t\"image/jpeg\"\n\t\"image/png\"\n\t\"log\"\n\t\"os\"\n\n\trice \"github.com/GeertJohan/go.rice\"\n\t\"github.com/disintegration/imaging\"\n\t\"github.com/pkg/errors\"\n\tfiletype \"gopkg.in/h2non/filetype.v1\"\n\t\"{{.AppImportPath}}/core\"\n\t\"{{.AppImportPath}}/util\"\n)\n\nconst (\n\t//TypeImageJPG denotes image of file type jpg\n\tTypeImageJPG = \"jpg\"\n\t//TypeImageJPEG denotes image of file type jpeg\n\tTypeImageJPEG = \"jpeg\"\n\t//TypeImagePNG denotes image of file type png\n\tTypeImagePNG = \"png\"\n)\n\n// Anchor points for X,Y\nconst (\n\tLeft = iota\n\tRight\n\tTop\n\tBottom\n\tCenter\n)\n\nvar (\n\t//DefaultDimensions represent default dimensions to use, they have no limit (preserve original)\n\tDefaultDimensions = ImageDimensions{\n\t\tMinWidth:  util.NoLimit,\n\t\tMinHeight: util.NoLimit,\n\t}\n\n\t// Disk paths to static assets\n\t_diskPathWatermark string\n\t_diskPathBackdrop  string\n\n\t// TopLeft is the top-left position for watermark\n\tTopLeft = &WatermarkPosition{Horizontal: Left, Vertical: Top}\n\t// TopCenter is the top-center position for watermark\n\tTopCenter = &WatermarkPosition{Horizontal: Center, Vertical: Top}\n\t// TopRight is the top-right position for watermark\n\tTopRight = &WatermarkPosition{Horizontal: Right, Vertical: Top}\n\t// CenterRight is the center-right position for watermark\n\tCenterRight = &WatermarkPosition{Horizontal: Right, Vertical: Center}\n\t// BottomRight is the bottom-right position for watermark\n\tBottomRight = &WatermarkPosition{Horizontal: Right, Vertical: Bottom}\n\t// BottomCenter is the bottom-center position for watermark\n\tBottomCenter = &WatermarkPosition{Horizontal: Center, Vertical: Bottom}\n\t// BottomLeft is the bottom-left position for watermark\n\tBottomLeft = &WatermarkPosition{Horizontal: Left, Vertical: Bottom}\n\t// CenterLeft is the center-left position for watermark\n\tCenterLeft = &WatermarkPosition{Horizontal: Left, Vertical: Center}\n)\n\n//Imagist is an image processing mechanism\ntype Imagist struct {\n\tjobs chan Job\n\tdone chan string\n}\n\n//Job represents an image processing task\ntype Job struct {\n\tFileDiskPath string\n\tConfig       *image.Config\n\tDimensions   *ImageDimensions\n}\n\n//ImageDimensions holds dimensions options\ntype ImageDimensions struct {\n\tMinWidth  int\n\tMinHeight int\n\tFormats   []FormatDimensions\n}\n\n//FormatDimensions holds dimensions options for format\ntype FormatDimensions struct {\n\tName      string\n\tWidth     int\n\tHeight    int\n\tBackdrop  bool               // (default: false) If true, will add a backdrop\n\tWatermark *WatermarkPosition // (default: nil) If not nil, will overlay an image as watermark at X,Y pos +-OffsetX,OffsetY\n}\n\n// WatermarkPosition holds the watermark position\ntype WatermarkPosition struct {\n\tHorizontal int\n\tVertical   int\n\tOffsetX    int\n\tOffsetY    int\n}\ntype subImager interface {\n\tSubImage(r image.Rectangle) image.Image\n}\n\nfunc init() {\n\timage.RegisterFormat(\"jpeg\", \"jpeg\", jpeg.Decode, jpeg.DecodeConfig)\n\timage.RegisterFormat(\"png\", \"png\", png.Decode, png.DecodeConfig)\n\timage.RegisterFormat(\"gif\", \"gif\", gif.Decode, gif.DecodeConfig)\n}\n\n// SetBackdropImage sets the disk path for backdrop images\nfunc SetBackdropImage(path string) {\n\t_diskPathBackdrop = path\n}\n\n// SetWatermarkImage sets the disk path for watermark images\nfunc SetWatermarkImage(path string) {\n\t_diskPathWatermark = path\n}\n\n//New returns an instance of imagist, with the internal go routine awaiting jobs over the channel\nfunc New(chansize ...int) *Imagist {\n\tvar s int\n\n\tif len(chansize) == 0 {\n\t\ts = 10\n\t} else {\n\t\ts = chansize[0]\n\t}\n\n\ti := Imagist{\n\t\tjobs: make(chan Job, s),\n\t\tdone: make(chan string, s),\n\t}\n\n\tgo i.listen()\n\n\treturn &i\n}\n\n//listen starts listening for jobs on the internal channel\nfunc (i Imagist) listen() {\n\tjobs := make(map[string]interface{})\n\n\tfor {\n\t\tselect {\n\t\tcase done := <-i.done:\n\t\t\tdelete(jobs, done)\n\t\tcase job := <-i.jobs:\n\t\t\tif _, exists := jobs[job.FileDiskPath]; !exists {\n\t\t\t\tjobs[job.FileDiskPath] = nil\n\t\t\t\tgo i.execute(job)\n\t\t\t}\n\t\t}\n\t}\n}\n\n//Add creates a job entry for processing\nfunc (i Imagist) Add(buf []byte, fileDiskPath string, dimensions *ImageDimensions, validate bool) error {\n\tif !filetype.IsImage(buf) {\n\t\treturn fmt.Errorf(\"image type invalid\")\n\t}\n\n\tif dimensions == nil {\n\t\tdimensions = &DefaultDimensions\n\t}\n\n\tconfig, imgType, err := image.DecodeConfig(bytes.NewReader(buf))\n\tif err != nil {\n\t\tlog.Printf(\"error decoding image: %v\", err)\n\t\treturn err\n\t}\n\n\tswitch imgType {\n\tcase TypeImageJPG, TypeImageJPEG, TypeImagePNG:\n\t\t//all ok\n\tdefault:\n\t\treturn fmt.Errorf(\"image type %s invalid\", imgType)\n\t}\n\n\tif validate {\n\t\t// Check min width and height\n\t\tif dimensions.MinWidth != util.NoLimit && config.Width < dimensions.MinWidth {\n\t\t\tlog.Printf(\"image %v lower than min width: %v\\n\", fileDiskPath, dimensions.MinWidth)\n\t\t\treturn fmt.Errorf(\"image width less than %dpx\", dimensions.MinWidth)\n\t\t}\n\n\t\tif dimensions.MinHeight != util.NoLimit && config.Height < dimensions.MinHeight {\n\t\t\tlog.Printf(\"image %v lower than min height: %v\\n\", fileDiskPath, dimensions.MinHeight)\n\t\t\treturn fmt.Errorf(\"image height less than %dpx\", dimensions.MinHeight)\n\t\t}\n\t}\n\n\tjob := Job{\n\t\tFileDiskPath: fileDiskPath,\n\t\tConfig:       &config,\n\t\tDimensions:   dimensions,\n\t}\n\ti.jobs <- job\n\n\treturn nil\n}\n\nfunc (i Imagist) execute(j Job) {\n\tfor _, format := range j.Dimensions.Formats {\n\t\tif format.Name == \"\" || format.Width <= 0 || format.Height <= 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tnewWidth := format.Width\n\t\tnewHeight := format.Height\n\n\t\t// Do not upscale\n\t\tif j.Config.Width < format.Width {\n\t\t\tnewWidth = j.Config.Width\n\t\t}\n\t\tif j.Config.Height < j.Config.Height {\n\t\t\tnewHeight = j.Config.Height\n\t\t}\n\n\t\tlandscape := j.Config.Height < j.Config.Width\n\n\t\timageProcess(j.FileDiskPath, newWidth, newHeight, landscape, format)\n\t}\n\n\ti.done <- j.FileDiskPath\n}\n\nfunc imageProcess(imgDiskPath string, newWidth, newHeight int, landscape bool, format FormatDimensions) error {\n\tvar (\n\t\timg image.Image\n\t\terr error\n\t)\n\n\timg, err = imaging.Open(imgDiskPath)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"image open error\")\n\t}\n\n\t// Do not crop and resize when using backdrop but downscale\n\tif format.Backdrop && !landscape {\n\t\t// Scale down srcImage to fit the bounding box\n\t\timg = imaging.Fit(img, newWidth, newHeight, imaging.Lanczos)\n\n\t\t// Open a new image to use as backdrop layer\n\t\tvar back image.Image\n\t\tif core.Env == core.EnvironmentDev {\n\t\t\tback, err = imaging.Open(\"../assets/\" + _diskPathBackdrop)\n\t\t} else {\n\t\t\tvar staticAsset *rice.File\n\t\t\tstaticAsset, err = core.Assets.Open(_diskPathBackdrop)\n\t\t\tif err != nil {\n\t\t\t\t// if err, fall back to a blue background backdrop\n\t\t\t\tback = imaging.New(format.Width, format.Height, color.NRGBA{0, 29, 56, 0})\n\t\t\t}\n\t\t\tdefer staticAsset.Close()\n\t\t\tback, _, err = image.Decode(staticAsset)\n\t\t}\n\n\t\tif err != nil {\n\t\t\t// if err, fall back to a blue background backdrop\n\t\t\tback = imaging.New(format.Width, format.Height, color.NRGBA{0, 29, 56, 0})\n\t\t} else {\n\t\t\t// Resize and crop backdrop accordingly\n\t\t\tback = imaging.Fill(back, format.Width, format.Height, imaging.Center, imaging.Lanczos)\n\t\t}\n\n\t\t// Overlay image in center on backdrop layer\n\t\timg = imaging.OverlayCenter(back, img, 1.0)\n\t} else {\n\t\t// Resize and crop the image to fill the [newWidth x newHeight] area\n\t\timg = imaging.Fill(img, newWidth, newHeight, imaging.Center, imaging.Lanczos)\n\t}\n\n\tif format.Watermark != nil {\n\t\tvar watermark image.Image\n\t\tif core.Env == core.EnvironmentDev {\n\t\t\twatermark, err = imaging.Open(\"../assets/\" + _diskPathWatermark + \":\" + format.Name)\n\t\t} else {\n\t\t\tvar staticAsset *rice.File\n\t\t\tstaticAsset, err = core.Assets.Open(_diskPathWatermark + \":\" + format.Name)\n\t\t\tif err != nil {\n\t\t\t\treturn errors.Wrap(err, \"watermark not found\")\n\t\t\t}\n\t\t\tdefer staticAsset.Close()\n\t\t\twatermark, _, err = image.Decode(staticAsset)\n\t\t}\n\t\tif err == nil {\n\t\t\tbgBounds := img.Bounds()\n\t\t\tbgW := bgBounds.Dx()\n\t\t\tbgH := bgBounds.Dy()\n\n\t\t\twatermarkBounds := watermark.Bounds()\n\t\t\twatermarkW := watermarkBounds.Dx()\n\t\t\twatermarkH := watermarkBounds.Dy()\n\n\t\t\tvar watermarkPos image.Point\n\n\t\t\tswitch format.Watermark.Horizontal {\n\t\t\tdefault:\n\t\t\t\tformat.Watermark.Horizontal = Left\n\t\t\t\tfallthrough\n\t\t\tcase Left:\n\t\t\t\twatermarkPos.X += format.Watermark.OffsetX\n\t\t\tcase Right:\n\t\t\t\tRightX := bgBounds.Min.X + bgW - watermarkW\n\t\t\t\twatermarkPos.X = RightX - format.Watermark.OffsetX\n\t\t\tcase Center:\n\t\t\t\tCenterX := bgBounds.Min.X + bgW/2\n\t\t\t\twatermarkPos.X = CenterX - watermarkW/2 + format.Watermark.OffsetX\n\t\t\t}\n\n\t\t\tswitch format.Watermark.Vertical {\n\t\t\tdefault:\n\t\t\t\tformat.Watermark.Vertical = Top\n\t\t\t\tfallthrough\n\t\t\tcase Top:\n\t\t\t\twatermarkPos.Y += format.Watermark.OffsetY\n\t\t\tcase Bottom:\n\t\t\t\tBottomY := bgBounds.Min.Y + bgH - watermarkH\n\t\t\t\twatermarkPos.Y = BottomY - format.Watermark.OffsetY\n\t\t\tcase Center:\n\t\t\t\tCenterY := bgBounds.Min.Y + bgH/2\n\t\t\t\twatermarkPos.Y = CenterY - watermarkH/2 + format.Watermark.OffsetY\n\t\t\t}\n\n\t\t\timg = imaging.Overlay(img, watermark, watermarkPos, 1.0)\n\t\t}\n\t}\n\n\timagingFormat, err := imaging.FormatFromFilename(imgDiskPath)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"image get format error\")\n\t}\n\n\tnewDiskPath := imgDiskPath + \":\" + format.Name\n\n\toutputFile, err := os.Create(newDiskPath)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"image create error\")\n\t}\n\tdefer outputFile.Close()\n\n\treturn imaging.Encode(outputFile, img, imagingFormat)\n}"),
	}
	filev := &embedded.EmbeddedFile{
		Filename:    "util/rice.go.tmpl",
		FileModTime: time.Unix(1538482115, 0),
		Content:     string("package util\n\nimport (\n\t\"net/http\"\n\t\"strings\"\n\n\trice \"github.com/GeertJohan/go.rice\"\n)\n\n// WebBox implements http.FileSystem which allows the use of Box with a http.FileServer.\n//   e.g.: http.Handle(\"/\", http.FileServer(rice.MustFindBox(\"http-files\").HTTPBox()))\ntype WebBox struct {\n\tBox  *rice.Box\n\tApp  string\n\tPath string\n}\n\n// NewWebBoxHandler returns a new WebBox File Server Handler\nfunc NewWebBoxHandler(box *rice.Box, app, path string) http.Handler {\n\treturn http.FileServer(WebBox{Box: box, App: app, Path: \"/\" + path})\n}\n\n// Open returns a File using the http.File interface\nfunc (b WebBox) Open(name string) (http.File, error) {\n\tname = strings.TrimPrefix(name, b.Path)\n\treturn b.Box.Open(b.App + name)\n}\n"),
	}
	filew := &embedded.EmbeddedFile{
		Filename:    "util/util.go.tmpl",
		FileModTime: time.Unix(1539416325, 0),
		Content:     string("package util\n\nimport (\n\t\"context\"\n)\n\nconst (\n\t// NoLimit is used to indicate no restriction (on dimensions or size)\n\tNoLimit = -1\n)\n\n// CheckContext returns an error if context is done\nfunc CheckContext(ctx context.Context) error {\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn ctx.Err()\n\tdefault:\n\t\treturn nil\n\t}\n}"),
	}
	filex := &embedded.EmbeddedFile{
		Filename:    "util/web.go.tmpl",
		FileModTime: time.Unix(1539869977, 0),
		Content:     string("package web\n\nimport (\n\t\"bytes\"\n\t\"html/template\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httputil\"\n\t\"net/url\"\n\t\"os\"\n\t\"path\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gorilla/mux\"\n\tlog \"github.com/sirupsen/logrus\"\n)\n\nfunc lookupContent(root http.FileSystem, upath string) (http.File, os.FileInfo, bool) {\n\tvar (\n\t\terr  error\n\t\tfile http.File\n\t\tinfo os.FileInfo\n\t)\n\n\tif !strings.HasPrefix(upath, \"/\") {\n\t\tupath = \"/\" + upath\n\t}\n\n\tupath = path.Clean(upath)\n\n\tif file, err = root.Open(upath); err != nil {\n\t\treturn nil, nil, false\n\t}\n\n\tif info, err = file.Stat(); err != nil {\n\t\treturn nil, nil, false\n\t}\n\n\tif info.IsDir() {\n\t\tupath += \"/index.html\"\n\t\treturn lookupContent(root, upath+\"/index.html\")\n\t}\n\n\treturn file, info, true\n}\n\ntype fileHandlerWithFallback struct {\n\troot     http.FileSystem\n\tfallback http.File\n}\n\n// FileServerWithFallback returns an HTTP static fileserver with a default file fallback if requested url was not found\nfunc FileServerWithFallback(root http.FileSystem, fallback http.File) http.Handler {\n\treturn &fileHandlerWithFallback{root: root, fallback: fallback}\n}\n\nfunc (f *fileHandlerWithFallback) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tvar (\n\t\tfile http.File\n\t\tinfo os.FileInfo\n\t\tok   bool\n\t\terr  error\n\t)\n\n\tfile, info, ok = lookupContent(f.root, r.URL.Path)\n\n\tif !ok {\n\t\tfile = f.fallback\n\t\tif info, err = file.Stat(); err == nil {\n\t\t\tok = true\n\t\t}\n\t}\n\n\tif ok {\n\t\thttp.ServeContent(w, r, info.Name(), info.ModTime(), file)\n\t} else {\n\t\tw.Header().Set(\"Content-Type\", \"text/plain; charset=utf-8\")\n\t\tw.Header().Set(\"X-Content-Type-Options\", \"nosniff\")\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\tw.Write([]byte(\"File not found and default could not be served.\"))\n\t}\n}\n\ntype fileHandlerWithFallbackContent struct {\n\troot        http.FileSystem\n\tfallback    io.ReadSeeker\n\tfilename    string\n\tcontentType string\n\tmodtime     time.Time\n}\n\n// FileServerWithFallbackContent returns an HTTP static fileserver with a default content fallback if requested url was not found\nfunc FileServerWithFallbackContent(root http.FileSystem, fallback io.ReadSeeker, filename, contentType string, modtime time.Time) http.Handler {\n\treturn &fileHandlerWithFallbackContent{root: root, fallback: fallback, filename: filename, contentType: contentType, modtime: modtime}\n}\n\nfunc (f *fileHandlerWithFallbackContent) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", f.contentType)\n\thttp.ServeContent(w, r, f.filename, f.modtime, f.fallback)\n}\n\ntype fileHandlerWithNotFoundHandler struct {\n\troot    http.FileSystem\n\thandler http.Handler\n}\n\n// FileServerWithNotFoundHandler returns an HTTP static fileserver with a custom http.Handler if requested url was not found\nfunc FileServerWithNotFoundHandler(root http.FileSystem, handler http.Handler) http.Handler {\n\treturn &fileHandlerWithNotFoundHandler{root: root, handler: handler}\n}\n\nfunc (f *fileHandlerWithNotFoundHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tif file, info, ok := lookupContent(f.root, r.URL.Path); ok {\n\t\thttp.ServeContent(w, r, info.Name(), info.ModTime(), file)\n\t} else {\n\t\tf.handler.ServeHTTP(w, r)\n\t}\n}\n\n// VueAppRouting returns a new subrouter\nfunc VueAppRouting(router *mux.Router, prefix string, appName string, fallbackParams interface{}, mwf ...mux.MiddlewareFunc) error {\n\tfileSystem := util.WebBox{Box: core.Assets, App: \"web/\" + appName, Path: \"/\" + appName}\n\n\tif fallbackParams == nil {\n\t\tfallbackFile, err := core.Assets.Open(\"web/\" + appName + \"/index.html\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\trouter.PathPrefix(prefix).Handler(\n\t\t\thttp.StripPrefix(\n\t\t\t\tprefix,\n\t\t\t\tFileServerWithFallback(fileSystem, fallbackFile),\n\t\t\t),\n\t)\n\n\t\treturn nil\n\t}\n\n\traw, err := core.Assets.String(\"web/\" + appName + \"/index.html\")\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttpl, err := template.New(appName).Parse(raw)\n\tif err != nil {\n\t\treturn err\n\t}\n\t\n\tb := bytes.NewBuffer([]byte{})\n\terr = tpl.Execute(b, fallbackParams)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\trouter.PathPrefix(prefix).Handler(\n\t\thttp.StripPrefix(\n\t\t\tprefix,\n\t\t\tFileServerWithNotFoundHandler(fileSystem, FileServerWithFallbackContent(fileSystem, bytes.NewReader(b.Bytes()), \"index.html\", \"text/html\", time.Now())),\n\t\t),\n\t)\n\n\treturn nil\n}\n\n// DevRouting returns a new subrouter\nfunc DevRouting(router *mux.Router, prefix string, app string, port string, mwf ...mux.MiddlewareFunc) error {\n\tvar (\n\t\turl    = &url.URL{Scheme: \"http\", Host: \"localhost:\" + port}\n\t\twsprox = NewWSReverseProxy(url)\n\t\thtprox = httputil.NewSingleHostReverseProxy(url)\n\t)\n\n\trouter.PathPrefix(prefix).HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif IsWebsocket(r) {\n\t\t\twsprox.ServeHTTP(w, r)\n\t\t} else {\n\t\t\thtprox.ServeHTTP(w, r)\n\t\t}\n\t})\n\n\treturn nil\n}\n"),
	}
	filey := &embedded.EmbeddedFile{
		Filename:    "util/ws.go.tmpl",
		FileModTime: time.Unix(1538482115, 0),
		Content:     string("package web\n\n// WSReverseProxy implements http.HandlerFunc to reverse proxy websocket requests\ntype WSReverseProxy struct {\n\tTarget string\n}\n\n// NewWSReverseProxy creates a new websocket reverse proxy\nfunc NewWSReverseProxy(url *url.URL) *WSReverseProxy {\n\tvar proxy = new(WSReverseProxy)\n\tproxy.Target = fmt.Sprintf(\"%s:%s\", url.Hostname(), url.Port())\n\n\treturn proxy\n}\n\nfunc (ws *WSReverseProxy) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\td, err := net.Dial(\"tcp\", ws.Target)\n\tif err != nil {\n\t\thttp.Error(w, \"Error contacting backend server.\", http.StatusBadGateway)\n\t\tlog.Printf(\"Error dialing websocket backend %s: %s\", ws.Target, err)\n\t\treturn\n\t}\n\n\thj, ok := w.(http.Hijacker)\n\tif !ok {\n\t\thttp.Error(w, \"Not a hijacker?\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tnc, _, err := hj.Hijack()\n\tif err != nil {\n\t\tlog.Printf(\"Hijack error: %v\", err)\n\t\treturn\n\t}\n\n\tdefer nc.Close()\n\tdefer d.Close()\n\n\terr = r.Write(d)\n\tif err != nil {\n\t\tlog.Printf(\"Error copying request to target: %v\", err)\n\t\treturn\n\t}\n\n\terrc := make(chan error, 2)\n\tcp := func(dst io.Writer, src io.Reader) {\n\t\t_, err := io.Copy(dst, src)\n\n\t\tif err != nil {\n\t\t\terrc <- err\n\t\t}\n\t}\n\tgo cp(d, nc)\n\tgo cp(nc, d)\n\t<-errc\n}\n\n// IsWebsocket determines whether or not an http request is using websocket\nfunc IsWebsocket(r *http.Request) bool {\n\tconnHdr := \"\"\n\tconnHdrs := r.Header[\"Connection\"]\n\tif len(connHdrs) > 0 {\n\t\tconnHdr = connHdrs[0]\n\t}\n\n\tupgradeWs := false\n\tif strings.ToLower(connHdr) == \"upgrade\" {\n\t\tupgradeHdrs := r.Header[\"Upgrade\"]\n\t\tif len(upgradeHdrs) > 0 {\n\t\t\tupgradeWs = (strings.ToLower(upgradeHdrs[0]) == \"websocket\")\n\t\t}\n\t}\n\n\treturn upgradeWs\n}\n"),
	}
	file11 := &embedded.EmbeddedFile{
		Filename:    "vuetify/forms/edit.vue.tmpl",
		FileModTime: time.Unix(1539938148, 0),
		Content:     string("<template>\n    <div>\n        <div class=\"listing--container\">\n            <!-- Normal Toolbar -->\n            <v-toolbar class=\"transparent listing-toolbar blue-grey darken-3 px-3\" dark flat ml-0 v-if=\"!nested\">\n                <v-btn icon :to=\"{name: '{{- plural (lower .Entity.Name) -}}_list'}\">\n                    <v-icon>arrow_back</v-icon>\n                </v-btn>\n                <v-toolbar-title>Edit {{.Entity.Name}} </v-toolbar-title>\n\n                <v-spacer></v-spacer>\n                \n                {{- if .Entity.ContentBuilder }}\n                <v-tabs\n                    centered\n                    v-model=\"tab\"\n                    color=\"transparent\"\n                    align-with-title\n                    :grow=\"false\"\n                >\n                    <v-tabs-slider color=\"primary\"></v-tabs-slider>\n                    <v-tab v-for=\"item in items\" :key=\"item.id\">\n                        {{ \"{{ item.text }}\" }}\n                    </v-tab>\n                </v-tabs>\n                \n                <v-spacer></v-spacer>\n\n                <v-btn-toggle :disabled=\"tab === 0\" flat class=\"transparent\" v-model=\"viewport\">\n                    <v-btn :disabled=\"tab === 0\" flat small icon :color=\"getViewport === 'mobile' ? 'primary' : ''\" @click=\"changeViewport('mobile')\">\n                        <v-icon small dark>phone_iphone</v-icon>\n                    </v-btn>\n                    <v-btn :disabled=\"tab === 0\" flat small icon :color=\"getViewport === 'tablet' ? 'primary' : ''\" @click=\"changeViewport('tablet')\">\n                        <v-icon small dark>tablet_mac</v-icon>\n                    </v-btn>\n                    <v-btn :disabled=\"tab === 0\" flat small icon :color=\"getViewport === 'desktop' ? 'primary' : ''\" @click=\"changeViewport('desktop')\">\n                        <v-icon small dark>desktop_mac</v-icon>\n                    </v-btn>\n                </v-btn-toggle>\n                {{- end }}\n                \n                <v-btn color=\"primary\"  @click=\"update\">\n                    Save\n                    <v-icon right>save</v-icon>\n                </v-btn>\n            </v-toolbar>\n            <!-- Nested Form Toolbar -->\n            <v-toolbar class=\"primary listing-toolbar px-3\" dense dark v-else>\n                <v-toolbar-title>\n                    <h3>Edit {{.Entity.Name}} </h3>\n                </v-toolbar-title>\n                <v-spacer></v-spacer>\n                <v-btn flat @click.stop=\"emitCloseForm\">\n                    <v-icon dark>close</v-icon> Close\n                </v-btn>\n            </v-toolbar>\n        </div>\n\n        {{- if .Entity.ContentBuilder }}\n\n        <v-tabs-items v-model=\"tab\">\n            <v-tab-item key=\"info\">\n                <v-card-text>\n\n        {{- end }}\n\n        <div v-if=\"loading\" centered>\n            <v-progress-linear :indeterminate=\"true\"></v-progress-linear>\n            <p class=\"text-xs-center\">contacting server...</p>\n        </div>\n\n        <v-card v-else>\n            <v-card-text>\n                <v-form>\n                    <div class=\"gocipe-form-grid\" v-if=\"entity\">\n                    {{- $EntityName := .Entity.Name -}} \n                    {{- range .Entity.Fields -}} \n                        {{- if not .EditWidget.Hide }} \n                        {{- if not (eq .EditWidget.Type \"status\") }} \n                            <div class=\"gocipe-field-container\">\n                                <component  :is=\"'EditWidget{{ucfirst .EditWidget.Type }}'\"\n                                            :label=\"'{{ .Label }}'\"\n                                            :hint=\"'{{ .EditWidget.Description }}'\" \n                                            :value=\"this.entity.get{{ucfirst .Name}}()\" \n                                            @gocipe=\"(e) => this.entity.set{{ucfirst .Name}}(e)\" \n                                            \n                                            {{- /* SELECTBOX */ -}}\n                                            {{- if eq .EditWidget.Type \"select\" }} \n                                            :options='{{ .GetEditWidgetOptionsJSON }}' \n                                            {{- end -}}\n                                            \n                                            {{- /* IMAGEFIELD */ -}}\n                                            {{- if eq .EditWidget.Type \"imagefield\" }}\n                                            :field=\"'{{ .Name}}'\" \n                                            :rpc=\"'upload{{ $EntityName }}'\" \n                                            :entityid=\"id\"\n                                            {{- end -}}\n                                ></component>\n                            </div>\n                        {{- end }} \n                        {{- end }} \n                    {{- end -}}\n\n                    {{- range .Entity.Relationships -}}\n                        {{- if not .EditWidget.Hide }}\n                        <template v-if=\"componentLoaded\">\n                        {{- if eq .Type \"one-many\" }}\n                            <div class=\"data-table-responsive-wrapper\">\n                                <component\n                                    :is=\"'{{plural .Entity }}List'\"\n                                    :key=\"'{{plural .Entity }}_key'\"\n                                    :filter_id=\"id\" \n                                    :filter_field=\"'{{lower $.Entity.Name}}_id'\"\n                                    :rpc=\"'set{{$.Entity.Name }}id'\"\n                                    :nested=\"true\" \n                                />\n                            </div>\n                        {{- else if or (eq .Type \"many-many\") (eq .Type \"many-many-owner\")}}\n                                <component  :is=\"'EditWidgetSelectRel'\"\n                                    :label=\"'{{ .Name }}'\"\n                                    :hint=\"'widget: select rel'\" \n                                    :value=\"this.entity.get{{ucfirst .Name}}List()\" \n                                    :rpc=\"'lookup{{plural .Entity}}'\"\n                                    :multiple=\"true\"\n                                    @gocipe=\"(e) => this.setRelated{{.Name}}(e)\"\n                                    {{- /* SELECTREL */ -}}\n                                ></component>\n                        {{- else if eq .Type \"many-one\" }}\n                                <component  :is=\"'EditWidgetSelectRel'\"\n                                    :label=\"'{{ .Name }}'\"\n                                    :hint=\"'widget: select rel'\" \n                                    :value=\"this.entity.get{{ucfirst .Name}}()\" \n                                    :rpc=\"'lookup{{plural .Entity}}'\"\n                                    :multiple=\"false\"\n                                    @gocipe=\"(e) => this.entity.set{{ucfirst .Entity}}id(e)\"\n                                    {{- /* SELECTREL */ -}}\n                                ></component>\n                        {{- end }}\n                        </template>\n                        {{- end }}\n                    {{- end }}\n\n                    {{- range .Entity.References -}}\n                        {{- if not .TypeField.EditWidget.Hide }}\n                        <template v-if=\"componentLoaded\">\n                            <div class=\"gocipe-field-container\">\n                                <component  :is=\"'EditWidgetSelect'\"\n                                    :label=\"'{{ .TypeField.Label }}'\"\n                                    :hint=\"'{{ .TypeField.EditWidget.Description }}'\" \n                                    :value=\"this.entity.get{{ucfirst .TypeField.Name}}()\" \n                                    @gocipe=\"(e) => this.change{{ucfirst .TypeField.Name}}(e)\" \n                                    :options='{{ .TypeField.GetEditWidgetOptionsJSON }}'\n                                    :multiple=\"false\"\n                                    {{- /* SELECTBOX */ -}}\n                                ></component>\n                            </div>\n                        </template>\n                        {{- end }}\n                        {{- if not .IDField.EditWidget.Hide }}\n                        <template v-if=\"componentLoaded\">\n                            <div class=\"gocipe-field-container\">\n                                <component  :is=\"'EditWidgetSelectRel'\"\n                                    :label=\"'{{ .IDField.Label }}'\"\n                                    :hint=\"'{{ .IDField.EditWidget.Description }}'\" \n                                    :value=\"this.entity.get{{ucfirst .IDField.Name}}()\" \n                                    :rpc=\"lookup{{ucfirst .TypeField.Name}}RPC\"\n                                    @gocipe=\"(e) => this.entity.set{{ucfirst .IDField.Name}}(e)\"\n                                    :multiple=\"false\"\n                                    {{- /* SELECTREL */ -}}\n                                ></component>\n                            </div>\n                        </template>\n                        {{- end }}\n                    {{- end }}\n\n                    <component  :is=\"'EditWidgetStatus'\"\n                        :label=\"'Status'\"\n                        :value=\"this.entity.getStatus()\" \n                        @gocipe=\"(e) => this.entity.setStatus(e)\" >\n                    </component>\n\n                    </div>\n                </v-form>\n            </v-card-text>\n        </v-card>\n        \n        {{ if .Entity.ContentBuilder }}\n\n                </v-card-text>\n            </v-tab-item>\n            <v-tab-item key=\"builder\">\n                <Lardwaz :information=\"getInformation()\"/>\n            </v-tab-item>\n        </v-tabs-items>\n\n        {{ end }}\n        \n         \n        <v-toolbar class=\"transparent listing-toolbar blue-grey darken-4 px-3\" dark flat ml-0  v-if=\"!nested\">\n            <v-spacer></v-spacer>\n            <v-btn color=\"primary\" @click=\"update\">\n                Save\n                <v-icon right>save</v-icon>\n            </v-btn>\n        </v-toolbar>\n        <v-toolbar class=\"transparent listing-toolbar blue-grey darken-4 px-3\" dark flat ml-0  v-else>\n            <v-btn color=\"gray\" @click=\"emitCloseForm\">\n                Cancel\n                <v-icon right>close</v-icon>\n            </v-btn>\n            <v-spacer></v-spacer>\n            <v-btn color=\"primary\" @click=\"emitSaveAndCloseForm\">\n                Save &amp; Close\n                <v-icon right>assignment_return</v-icon>\n            </v-btn>\n        </v-toolbar>\n\n        <v-snackbar v-model=\"snackbar.show\" :bottom=\"true\" :right=\"true\" auto-height :color=\"snackbar.color\" :timeout=\"6000\">\n            {{ printf `{{ snackbar.text }}` }}\n            <v-btn dark flat v-if=\"snackbar.color !== 'error'\" :to=\"{name: '{{- plural (lower .Entity.Name) -}}_list', params : { track : id}}\">\n                <v-icon>arrow_back</v-icon>\n            </v-btn>\n            <v-btn dark flat @click=\"snackbarHide\">\n                <v-icon>close</v-icon>\n            </v-btn>\n        </v-snackbar>\n    </div>\n</template>\n\n\n<script>\nimport { AdminClient } from \"@/services/service_admin_pb_service\";\nimport { GetRequest } from \"@/services/service_admin_pb\";\nimport { Update{{ .Entity.Name}}Request } from \"@/services/service_admin_pb\";\nimport { mapGetters } from 'vuex'\n\n{{- range .Entity.Relationships -}}{{- if or (eq .Type \"many-many\") (eq .Type \"many-many-owner\") }}\nimport { {{.Entity}} } from \"@/services/models_pb\"\n{{end}}{{end -}}\n\n{{- if .Entity.ContentBuilder }}\nimport Lardwaz from '@/modules/lardwaz/views/Lardwaz'\n{{- end }}\n\nlet cli = new AdminClient(\"/api\");\nexport default {\n  data() {\n    return {\n      messages: [],   \n      snackbar: {\n          show: false, \n          text: ''\n      },\n      entity: null,\n      loading: false,\n      id: null,\n      componentLoaded: false,\n      {{- if .Entity.ContentBuilder }}\n      tab: null,\n      items: [{ id: 'info', text: 'Information'}, { id: 'builder', text: 'Content Builder'}],\n      viewport: null,\n      {{ end }}\n      {{ range .Entity.References -}}\n      lookup{{ucfirst .TypeField.Name}}RPC: null,\n      {{- end }}\n    };\n  },\n  {{/*\n    The Code below tranforms into something like this. A computed property with custom getter and setters\n    computed: {\n        name: {\n        get: function() {\n            return this.entity.getName();\n        },\n        set: function(value) {\n            this.entity.setName(value);\n        }\n        }\n    },\n  */}}\n  {{- if .Entity.ContentBuilder }}\n  components: {\n    Lardwaz\n  },\n  {{ end }}\n  props: [\"filter_id\", \"nested\", \"visible\"],\n  mounted() {\n    this.request()  \n  },\n  {{- if .Entity.ContentBuilder }}\n  computed: {\n    ...mapGetters({\n        getLardwaz: 'lardwaz/getBlocks',\n        getViewport: 'lardwaz/getViewport'\n    })\n  },\n  {{ end }}\n  methods: {\n        {{- range .Entity.Relationships -}}\n        {{- if or (eq .Type \"many-many\") (eq .Type \"many-many-owner\") }}\n        setRelated{{.Name}}: function(values) {\n            this.entity.set{{ucfirst (plural .Entity)}}List(\n                values.map((value) => { \n                    let related = new {{.Entity}}();\n                    related.setId(value);\n                    return related; \n                })\n            );\n        },\n        {{- end -}}\n        {{- end }}\n        {{ range .Entity.References -}}\n        change{{ucfirst .TypeField.Name}}: function(e){\n            this.entity.setEntitytype(e);\n            this.lookup{{ucfirst .TypeField.Name}}RPC = 'lookup'+this.entity.get{{ucfirst .TypeField.Name}}();\n        },\n        {{- end }}\n        log: function(e) {\n            console.log(e)\n        },\n        request: function() {\n            if (this.filter_id) {\n                this.id = this.filter_id\n            } else {\n                this.id = this.$route.params.id;\n            }\n            let req = new GetRequest();\n            req.setId(this.id);\n\n            this.loading = true;\n\n            cli.get{{ .Entity.Name}}(req, (err, resp) => {\n                if (err) {\n                    console.log(err);\n                    this.snackbarShow(err.message, \"error\");\n                    return;\n                }\n                this.loading = false;\n                this.entity = resp.get{{ucfirst .Entity.Name}}();\n                this.componentLoaded = true;\n\n                {{ range .Entity.References -}}\n                this.lookup{{ucfirst .TypeField.Name}}RPC = 'lookup'+this.entity.get{{ucfirst .TypeField.Name}}();\n                {{- end }}\n                {{- if .Entity.ContentBuilder -}}\n                // Set Lardwaz content only when there is data\n                this.$store.dispatch('lardwaz/setBlocks', { data: [] })\n                if (this.entity.getContent() && (this.entity.getContent() !== \"{}\" && this.entity.getContent().length > 0)) {\n                    this.$store.dispatch('lardwaz/setBlocks', { data: JSON.parse(this.entity.getContent()) })\n                }\n\n                this.viewport = this.getViewport\n                {{- end }}\n            });\n        },\n        update: function() {\n    \n            let req = new Update{{.Entity.Name}}Request();\n\n            {{- if .Entity.ContentBuilder }}\n            // Save Lardwaz content only if there are blocks\n            if (this.getLardwaz.length) {\n                this.entity.setContent(JSON.stringify(this.getLardwaz));\n            }\n            {{- end -}}\n\n            req.set{{ ucfirst .Entity.Name}}(this.entity);\n            // this.loading = true;\n\n            this.snackbarShow('{{ucfirst .Entity.Name}} Saved');\n            /* this.debug(); */\n\n            cli.update{{.Entity.Name}}(req, (err, resp) => {\n                if (err) {\n                    console.log(err);\n                    this.snackbarShow(err.message, \"error\");\n                    return;\n                }\n\n                // this.loading = false;\n                if (this.nested) {\n                    this.$emit(\"closeform\", true);\n                }\n            });\n        },\n        emitSaveAndCloseForm: function() {\n            /* console.log(\"emitting close form to parent\"); */\n            this.update();\n        },\n        emitCloseForm: function() {\n            /* console.log(\"emitting close form to parent\"); */\n            this.$emit(\"closeform\", true);\n        },\n        debug: function() {\n            {{- range .Entity.Fields }}\n            console.log(\"{{.Name}}\", this.entity.get{{ ucfirst .Name }}());\n            {{- end}}\n            {{- range .Entity.References }}\n            console.log(\"{{.IDField.Name}}\", this.entity.get{{ ucfirst .IDField.Name }}());\n            console.log(\"{{.TypeField.Name}}\", this.entity.get{{ ucfirst .TypeField.Name }}());\n            {{- end}}\n        },\n        snackbarShow: function(text, color) {\n            this.snackbar.show = true;\n            this.snackbar.color = color || 'info';\n            this.snackbar.text = text || 'something happened';\n        },\n        snackbarHide: function() {\n            this.snackbar.show = false\n            },\n            {{ if .Entity.ContentBuilder -}}\n            getInformation: function () {\n                let information = {};\n                information.title = this.entity && this.entity.getTitle() && this.entity.getTitle().length > 0 ? this.entity.getTitle() : null;\n                return information;\n            },\n            changeViewport: function (value) {\n              this.$store.dispatch('lardwaz/setViewport', { data: value })\n            },\n            {{- end }}\n  }\n  /* watch: {\n    visible: function(val) {\n      if (val) {\n        console.log(\"watching\");\n        this.request();\n      }\n    }\n  } */\n};\n</script>\n\n<style lang=\"scss\" scoped>\n.gocipe-form-grid {\n  width: 100%;\n  //   max-width: 800px;\n  margin: 0 auto;\n  display: grid;\n  grid-template-columns: repeat(auto-fill, minmax(650px, 1fr));\n  grid-column-gap: var(--gutter, 60px);\n  .gocipe-field-container {\n    // grid-column: 1/2;\n  }\n}\n\n.data-table-responsive-wrapper {\n  max-width: 100%;\n  overflow-y: auto;\n  /* padding: 5px; */\n}\n</style>\n"),
	}
	file12 := &embedded.EmbeddedFile{
		Filename:    "vuetify/forms/list.vue.tmpl",
		FileModTime: time.Unix(1539937047, 0),
		Content:     string("<template>\n  <div :class=\"{ 'px-3' : !nested }\" class=\"listing--container\">\n    <v-toolbar color=\"transparent\" class=\"listing-toolbar blue-grey darken-3 px-3\" dark flat ml-0 v-if=\"!nested\">\n      <v-btn icon>\n        <v-icon>{{.Entity.Vuetify.Icon}}</v-icon>\n      </v-btn>\n      <v-toolbar-title class=\"ml-0 pl-0\">{{.Entity.Name}} </v-toolbar-title>\n      <v-spacer></v-spacer>\n      <v-text-field class=\"mb-3\" prepend-inner-icon=\"search\" label=\"Search\"\n        single-line hide-details small v-model=\"search\"></v-text-field>\n      <v-btn-toggle flat class=\"transparent\" v-model=\"toggle_status\">\n        <v-btn icon small :color=\"toggle_status === 0 ? 'success' : ''\" flat>\n          <v-icon small dark>check_circle</v-icon>\n        </v-btn>\n        <v-btn icon small :color=\"toggle_status === 1 ? 'info' : ''\" flat>\n          <v-icon small dark>bookmark</v-icon>\n        </v-btn>\n        <v-btn icon small :color=\"toggle_status === 2 ? 'warning' : ''\" flat>\n          <v-icon small dark>rowing</v-icon>\n        </v-btn>\n        <v-btn icon small :color=\"toggle_status === 3 ? 'error' : ''\" flat>\n          <v-icon small dark>visibility_off</v-icon>\n        </v-btn>\n      </v-btn-toggle>\n      <v-spacer></v-spacer>\n      <v-btn mr-0 class=\"success\" color=\"white\" small flat @click=\"create\">\n        <v-icon dark>add</v-icon> Add\n      </v-btn>\n    </v-toolbar>\n\n    <v-toolbar color=\"transparent\" class=\"listing-toolbar\" flat ml-0 v-else>\n      <v-btn icon>\n        <v-icon>{{.Entity.Vuetify.Icon}}</v-icon>\n      </v-btn>\n      <v-toolbar-title>{{.Entity.Name}} </v-toolbar-title>\n      <v-spacer></v-spacer>\n      <v-btn mr-0 class=\"success\" color=\"white\" small flat @click=\"create\">\n        <v-icon dark>add</v-icon> Add\n      </v-btn>\n    </v-toolbar>\n\n    <!-- Error Messages -->\n    <v-alert :type=\"message.type==='E' ? 'error' : message.type\" :value=\"true\" v-for=\"(message, index) in messages\" :key=\"index\">\n      {{ \"{{ message.text }}\" }}\n    </v-alert>\n\n    <!-- Empty Check -->\n    <div v-if=\"loading\" centered>\n      <v-progress-linear :indeterminate=\"true\"></v-progress-linear>\n      <p class=\"text-xs-center\">contacting server...</p>\n    </div>\n    <v-alert type=\"info\" value=\"true\" color=\"primary\" outline icon=\"info\" v-else-if=\"entities.length===0 && !loading\">\n      No {{.Entity.Name}} exist. Would you like to create one now?\n      <v-btn color=\"primary\" @click=\"create\">create new</v-btn>\n    </v-alert>\n\n    <!-- Table form listing -->\n    <v-card v-else>\n        <v-data-table :headers=\"headers\" max :items=\"entities\" class=\"elevation-0\" :search=\"search\">\n          <template slot=\"items\" slot-scope=\"props\">\n            <tr :class=\"{'highlight': recentlySaved(props.item.id)}\" :key=\"props.item.id\">\n              <td class=\"justify-center layout\">\n                <v-btn icon class=\"mx-0\" @click.stop=\"deleteTry(props.item.id, props.item.Name)\">\n                  <v-icon>delete</v-icon>\n                </v-btn>\n                <v-btn icon class=\"mx-0\" @click.stop=\"duplicate(props.item.id)\">\n                  <v-icon>file_copy</v-icon>\n                </v-btn>\n                <v-tooltip top v-if=\"nested\">\n                  <v-btn slot=\"activator\" icon class=\"mx-0\" @click=\"nestedFormEdit(props.item.id, props.item.Name)\">\n                    <v-icon>edit</v-icon>\n                  </v-btn>\n                  <span>Edit</span>\n                </v-tooltip>\n                <v-tooltip top v-else>\n                  <v-btn slot=\"activator\" icon class=\"mx-0\" :to=\"{name: '{{plural (lower .Entity.Name )}}_edit', params:{ id: props.item.id }}\">\n                    <v-icon>edit</v-icon>\n                  </v-btn>\n                  <span>Edit</span>\n                </v-tooltip>\n              </td>\n              <!-- Check if it should appear in the list -->\n              {{ range .Entity.Fields }} {{if not .ListWidget.Hide}}\n              <!-- Use different rendering for dates -->\n              {{ if eq .ListWidget.Type \"time\" }}\n              <td>\n                <component :is=\"'ListWidget{{ucfirst .ListWidget.Type}}'\" :time=\"{{ printf \" props.item.%s \" (ucfirst .Name) }}\" />\n              </td>\n              {{- else -}}\n              <!-- Use different rendering for dates -->\n              {{if eq .ListWidget.Type \"image\"}}\n              <td>\n                <v-img :src=\"{{ printf \" props.item.%s+':thumb' \" (ucfirst .Name) }}\" width=\"50\" max-width=\"50\" contain height=\"40\" max-height=\"40\"></v-img>\n              </td>\n              {{- else -}}\n              <!-- Use different rendering for select types -->\n              {{if eq .ListWidget.Type \"select\"}}\n              <td>\n                <component :is=\"'ListWidget{{ucfirst .ListWidget.Type}}'\" :field=\"'{{ .Name }}'\" :status=\"{{ printf \" props.item.%s \" (ucfirst .Name) }}\" />\n              </td>\n              {{- else -}}\n              <!-- Use different rendering for dates -->\n              {{if eq .ListWidget.Type \"icon\"}}\n              <td>\n                <v-icon>{{ printf \"{{ props.item.%s }}\" (ucfirst .Name) }}</v-icon>\n              </td>\n              {{else}}\n              <!-- Use different rendering for toggles -->\n              {{if eq .ListWidget.Type \"toggle\"}}\n              <td>\n                <component :is=\"'ListWidget{{ucfirst .ListWidget.Type}}'\" :value=\"{{ printf \" props.item.%s \" (ucfirst .Name) }}\" />\n              </td>\n              {{else}}\n              <td>\n                <v-tooltip top>\n                  <span slot=\"activator\">\n                    {{ printf \"{{ props.item.%s}}\" (ucfirst .Name) }}\n\n                  </span>\n                  <span>Widget Type : {{ ucfirst .Type}}</span>\n                </v-tooltip>\n              </td>\n              {{end}} {{end}} {{end}} {{end}} {{end}} {{end}} {{end}}\n            </tr>\n          </template>\n\n          <template slot=\"no-data\">\n            <v-flex ma-4>\n              <v-alert slot=\"no-results\" :value=\"true\" color=\"primary\" outline icon=\"info\" v-if=\"search.length> 0\"> Your search for \"{{ \"{{ search }}\" }}\" found no results.\n              </v-alert>\n              <v-alert slot=\"no-results\" :value=\"true\" color=\"primary\" outline icon=\"info\" v-else>\n                No {{.Entity.Name}} found.\n              </v-alert>\n            </v-flex>\n          </template>\n        </v-data-table>\n    </v-card>\n\n    <v-dialog v-model=\"dialog\" persistent max-width=\"300\">\n      <v-card dark>\n        <v-card-title class=\"headline\">Confirm Delete</v-card-title>\n        <v-card-text>\n          You are about to delete\n          <strong>\"{{ printf \"{{deleteItemId.label}}\" }}\"</strong>\n        </v-card-text>\n        <v-card-actions>\n          <v-btn flat @click.native=\"dialog = false;\">Cancel</v-btn>\n          <v-spacer></v-spacer>\n          <v-btn color=\"error\" dark @click.native=\"deleteConfirm\">Yes, Delete</v-btn>\n        </v-card-actions>\n      </v-card>\n    </v-dialog>\n\n    <!-- Edit In Place -->\n    <v-dialog :persistent=\"true\" :lazy=\"true\" v-model=\"nestedForm.visible\" width=\"auto\" class=\"pa-4\" max-width=\"1000px\">\n      <component :is=\"'{{plural .Entity.Name}}Edit'\" :key=\"nestedForm.id\" @closeform=\"nestedFormClose\" :visible=\"nestedForm.visible\" :filter_id=\"nestedForm.id\" :nested=\"true\" />\n    </v-dialog>\n    <!-- !# Edit In Place -->\n\n\n    <v-snackbar v-model=\"snackbar.show\"  :bottom=\"true\"  color=\"primary\" auto-height :timeout=\"2000\">\n      {{ printf `{{ snackbar.text }}` }}\n      <v-btn dark flat @click=\"snackbarHide\">\n        <v-icon>close</v-icon>\n      </v-btn>\n    </v-snackbar>\n  </div>\n</template>\n\n<script>\nimport { AdminClient } from \"@/services/service_admin_pb_service\";\nimport { ListRequest, GetRequest, Filter} from \"@/services/service_admin_pb\";\nimport { Create{{ .Entity.Name}}Request } from \"@/services/service_admin_pb\";\nimport { DeleteRequest } from \"@/services/service_admin_pb\";\nimport { mapGetters } from 'vuex';\n\nimport { {{ .Entity.Name }} } from \"@/services/models_pb.js\";\n\nlet cli = new AdminClient(\"/api\");\n\nexport default {\n  data() {\n    return {\n      messages: [],\n      track: null,\n      search: \"\",\n      toggle_status:null,\n      snackbar: {\n          show: false, \n          text: ''\n      },\n      dialog: null,\n      deleteItemId: {\n        id: null,\n        label: null\n      },\n      nestedForm: {\n        visible: null,\n        id: null,\n        label: null\n      },\n      text: \"\",\n      headers: [\n        {'text': 'Action', 'value': null, sortable: false, 'width': '80px'},\n\t\t    {{- range .Entity.Fields }}\n        {{- if not .ListWidget.Hide}}\n        {text: \"{{.Label}}\", value: \"{{.Name}}\"},\n        {{- end}}\n        {{- end}}\n      ],\n      entities: [],\n      loading: false\n    };\n  },\n  components: {\n  },\n  computed: {\n    ...mapGetters({\n      'token': 'auth/getToken'\n    })\n  },\n  props: [\"filter_id\", \"filter_field\", \"nested\", \"rpc\"],\n  mounted() {\n    this.loading = true;\n    this.getList();\n    this.track = this.$route.params.track;\n\n  },\n  methods: {    \n      recentlySaved(id) {\n          if (this.track === id) {\n              return true;\n          }\n          return false;\n      },\n      nestedFormEdit(editid, name) {\n        this.nestedForm = {\n          visible: true,\n          id: editid,\n          label: name\n        };\n      },\n      nestedFormClose() {\n        // clear and reset nested form\n        this.getList();\n        this.nestedForm = {\n          visible: false,\n          id: \"\",\n          label: \"\"\n        };\n      },\n      getList: function(){\n        let req = new ListRequest();\n\n        if (this.filter_id) {\n          let filter = new Filter();\n          filter.setField(this.filter_field);\n          filter.setOperation(\"=\");\n          filter.setValue(this.filter_id);\n\n          req.addFilters(filter);\n        }\n\n        req.setKey(this.token);\n\n        cli.list{{plural .Entity.Name}}(req, (err, resp) => {\n          if (err) {\n            console.log(err);\n            this.snackbarShow(err.message, \"error\");\n            return;\n          }\n          this.loading = false;\n          this.snackbarShow('{{ucfirst (plural .Entity.Name)}} Loaded');\n\n          this.entities = resp.get{{ucfirst (plural .Entity.Name)}}List().map(entity => {\n            return {\n              {{ range .Entity.Fields }}\n                {{- if eq .ListWidget.Type \"time\" -}}\n                  {{ucfirst .Name}}: {{- printf \" entity.get%s().toDate()\" (ucfirst .Name)}},\n                {{- else -}}\n                  {{ucfirst .Name}}: {{- printf \" entity.get%s()\" (ucfirst .Name)}},\n                {{- end }}\n              {{ end }}\n            }\n          })\n        });\n       },\n      duplicate(id) {\n        let toBeDuplicatedId = id;\n        let toBeDuplicatedEntity = null;\n        // Get the entity\n        let req = new GetRequest();\n        req.setId(toBeDuplicatedId);\n\n        this.loading = true;\n\n        cli.get{{.Entity.Name}}(req, (err, resp) => {\n          if (err) {\n            console.log(err);\n            this.snackbarShow(err.message, \"error\");\n            return;\n          }\n          this.loading = false;\n          ///\n          toBeDuplicatedEntity = resp.get{{ucfirst .Entity.Name}}();\n          this.create(\"existing\", toBeDuplicatedEntity);\n        });\n      },\n      create: function(from, existingEntity) {\n        let req = new Create{{.Entity.Name}}Request();\n        req.setKey(this.token);\n\n        if (from === \"existing\" && existingEntity) {\n          req.set{{ucfirst .Entity.Name}}(existingEntity);\n        } else if (this.nested) {\n          let entity = new {{.Entity.Name}}();\n          entity[this.rpc](this.filter_id);\n          req.set{{ucfirst .Entity.Name}}(entity);\n        }\n\n        this.snackbarShow('Loading {{ucfirst (plural .Entity.Name)}}');\n        this.loading = true;\n\n        cli.create{{.Entity.Name}}(req, (err, resp) => {\n          if (err) {\n            console.log(err);\n\n            this.snackbarShow(\"Create Error \" + err.message, \"error\");\n\n            this.loading = false;\n            return;\n          }\n          this.loading = false;\n          if (this.nested) {\n            this.nestedForm = {\n              visible: true,\n              id: resp.get{{ucfirst .Entity.Name}}().getId(),\n              label: \"\"\n            };\n          } else {\n            this.$router.push({\n              name: \"{{lower (plural .Entity.Name)}}_edit\",\n              params: { id: resp.get{{ucfirst .Entity.Name}}().getId() }\n            });\n          }\n        });\n      },\n      deleteTry: function(id, label) {\n          this.deleteItemId = { id: id, label, label };\n          this.dialog = true;\n      },\n      deleteConfirm: function() {\n\n          let req = new DeleteRequest();\n          req.setKey(this.token);\n          req.setId(this.deleteItemId.id)\n\n          cli.delete{{.Entity.Name}}(req, (err, resp) => {\n            if (err) {\n                console.log(err);\n                this.snackbarShow(\"Delete error: \" + err.message, \"error\");\n\n                this.loading = false;\n                return;\n            } else {\n              this.snackbarShow('Deleted', this.deleteItemId.label);\n              this.getList();\n            }\n          })\n\n          this.dialog = false;\n\n      },\n      snackbarShow: function(text, color) {\n          this.snackbar.show = true;\n          this.snackbar.color = color || 'info';\n          this.snackbar.text = text || 'something happened';\n      },\n      snackbarHide: function() {\n          this.snackbar.show = false\n      }\n  }\n};\n</script>\n\n<style lang=\"scss\">\n.listing-toolbar .v-toolbar__content {\n  padding: 0;\n}\n\n.listing--container td {\n  img {\n    display: block !important;\n    height: 48px;\n    width: auto;\n  }\n}\n</style>\n\n\n<style lang=\"scss\" scoped>\n.bounce-enter-active {\n  animation: bounce-in 0.5s;\n}\n.bounce-leave-active {\n  animation: bounce-in 0.5s reverse;\n}\n@keyframes bounce-in {\n  0% {\n    transform: scale(0);\n  }\n  50% {\n    transform: scale(1.5);\n  }\n  100% {\n    transform: scale(1);\n  }\n}\n\n.highlight {\n  animation: highlight 10s 1 ease-in-out;\n}\n\n@keyframes highlight {\n  0% {\n    background: #b9f6ca;\n  }\n  100% {\n    background: transparent;\n  }\n}\n</style>\n"),
	}
	file14 := &embedded.EmbeddedFile{
		Filename:    "vuetify/js/actions.js.tmpl",
		FileModTime: time.Unix(1538482115, 0),
		Content:     string("import types from \"./types\";\n\nexport default {}"),
	}
	file15 := &embedded.EmbeddedFile{
		Filename:    "vuetify/js/components-registration.js.tmpl",
		FileModTime: time.Unix(1538482115, 0),
		Content:     string("import Vue from \"vue\";\n{{range $name, $file := .Widgets -}}\nimport {{ $name }} from \"@/gocipe/widgets/{{ $file }}\";\n{{ end }}\n\n{{range .Forms -}}\nimport {{ . }} from \"@/gocipe/forms/{{.}}.vue\"\n{{ end }}\n\n{{range $name, $file := .Widgets -}}\nVue.component(\"{{$name}}\", {{$name}});\n{{ end }}\n\n{{range .Forms -}}\nVue.component(\"{{.}}\", {{.}});\n{{ end }}"),
	}
	file16 := &embedded.EmbeddedFile{
		Filename:    "vuetify/js/getters.js.tmpl",
		FileModTime: time.Unix(1538482115, 0),
		Content:     string("export default {}\n"),
	}
	file17 := &embedded.EmbeddedFile{
		Filename:    "vuetify/js/index.js.tmpl",
		FileModTime: time.Unix(1538482115, 0),
		Content:     string("import actions from \"./actions\";\nimport getters from \"./getters\";\nimport mutations from \"./mutations\";\nimport routes from \"./routes\";\n\nconst namespaced = true;\n\nconst state = {\n  entities: routes.routes\n};\n\nexport default {\n  namespaced,\n  state,\n  actions,\n  getters,\n  mutations\n};"),
	}
	file18 := &embedded.EmbeddedFile{
		Filename:    "vuetify/js/mutations.js.tmpl",
		FileModTime: time.Unix(1538482115, 0),
		Content:     string("import types from \"./types\";\n\nexport default {}\n"),
	}
	file19 := &embedded.EmbeddedFile{
		Filename:    "vuetify/js/routes.js.tmpl",
		FileModTime: time.Unix(1538482115, 0),
		Content:     string("{{range .Entities}}\n// {{.Name}} {{.Description}}\nimport {{.Name}}List from \"./forms/{{plural .Name}}List.vue\";\nimport {{.Name}}Edit from \"./forms/{{plural .Name}}Edit.vue\";\n{{end}}\n\nlet routes = [\n  {{range $i, $v := .Entities}}\n  {\n    path: \"{{lower (plural .Name)}}\",\n    name: \"{{lower (plural .Name)}}_list\",\n    component: {{.Name}}List,\n    meta: {\n      icon: \"{{.Vuetify.Icon}}\",\n      entity: \"{{plural .Name}}\",\n      showInMenu: {{if .Vuetify.NotInMenu}}false{{else}}true{{end}}\n    }\n  },\n  {\n    path: \"{{lower (plural .Name)}}/edit/:id\",\n    name: \"{{lower (plural .Name)}}_edit\",\n    component: {{.Name}}Edit,\n    meta: {\n      icon: \"{{.Vuetify.Icon}}\",\n      entity: \"{{plural .Name}}\",\n      showInMenu: false\n    }\n  }{{if ne (plus1 $i) (len $.Entities)}},{{end}}\n  {{end}}\n];\n\nexport default routes;"),
	}
	file1a := &embedded.EmbeddedFile{
		Filename:    "vuetify/js/types.js.tmpl",
		FileModTime: time.Unix(1538482115, 0),
		Content:     string("export default {}\n"),
	}
	file1c := &embedded.EmbeddedFile{
		Filename:    "vuetify/old/vuetify_edit.vue.tmpl",
		FileModTime: time.Unix(1538482115, 0),
		Content:     string("<template>\n    <div class=\"container\">\n\t\t<v-toolbar color=\"transparent\" flat>\n            <v-toolbar-title class=\"grey--text text--darken-4 ml-0\"><h2>{{.Entity.Name}}</h2></v-toolbar-title>\n            <v-spacer></v-spacer>\n            <v-btn ml-0 small color=\"grey\" flat :to=\"{name: '{{.Endpoint}}List'}\">\n                <v-icon dark>arrow_back</v-icon> Back\n            </v-btn>\n        </v-toolbar>\n\t\t<v-alert :type=\"message.type\" :value=\"true\" v-for=\"(message, index) in messages\" :key=\"index\">\n\t\t{{ \"{{ message.text }}\" }}\n\t\t</v-alert>\n  \n        {{range .Entity.Fields -}}\n        {{widget_field \"vuetify\" .Widget.Type .}}\n        {{- end}}\n\n        <v-btn color=\"primary\" @click=\"save()\">Save</v-btn>\n        <v-btn color=\"gray\" :to=\"{name: '{{.Endpoint}}List'}\">Cancel</v-btn>\n\t</div>\n</template>\n  \n<script>\nimport axios from \"axios\"\n\nexport default {\n    props: [\"id\"],\n    created() {\n        if (!this.id) {\n            return\n        }\n\n        axios.get(\"/api/{{.Endpoint}}/\" + this.id).then(response => {\n            this.id = response.data.entity.id\n            {{range .Entity.Fields}}{{if ne .Serialized \"id\"}}\n            this.entity.{{.Serialized}} = response.data.entity.{{.Serialized}}\n            {{if eq .Widget.Type \"date\"}}this.dates.{{.Serialized}}.value = response.data.entity.{{.Serialized}}.substr(0,10){{end}}\n            {{end}}{{end}}\n        })\n    },\n    data() {\n        return {\n            select: {\n                {{range $i, $v := .Entity.Fields}}{{if eq .Widget.Type \"date\"}}\n                {{.Serialized}}: {\n                    items:[\n                        {{range $j, $u := .Widget.Options}}\n                        {text: \"{{.Label}}\", value: \"{{.Value}}\"}{{if eq (plus1 $j) (len $u)}},{{end}}\n                        {{end}}\n                    ]\n                }{{if ne (plus1 $i) (len $.Entity.Fields)}},{{end}}\n                {{end}}{{end}}\n\t\t\t},\n\t\t\tdates: {\n                {{range $i, $v := .Entity.Fields}}{{if eq .Widget.Type \"date\"}}\n\t\t\t\t{{.Serialized}}: {value: null, menuAppear: false}{{if ne (plus1 $i) (len $.Entity.Fields)}},{{end}}\n                {{end}}{{end}}\n\t\t\t},\n            messages: [],\n            entity: {\n                {{range $i, $e := .Entity.Fields}}{{if ne .Serialized \"id\"}}\n                {{.Serialized}} : null{{if ne (plus1 $i) (len $.Entity.Fields)}},{{end}}\n                {{end}}{{end}}\n            }\n        }\n    },\n    watch: {\n        {{range $i, $e := .Entity.Fields}}\n        \"select.{{.Serialized}}.search\": function(val) {\n            val && this.querySelections(\"{{.Serialized}}\", \"{{$.Endpoint}}\", \"{{$.Prefix}}{{.Relationship.Target.Endpoint}}\", val)\n        }{{if ne (plus1 $i) (len $.Entity.Fields)}},{{end}}\n        {{end}}\n    },\n    methods: {\n        querySelections(fieldname, endpoint, filter, val) {\n            this.select[fieldname].loading = true\n            axios.get(\"/api/\" + endpoint + \"?\" + filter + \"-lk=\" + encodeURIComponent(val)).then(response => {\n                this.select[fieldname].loading = false\n                this.select[fieldname].items = response.data.entities.map(function(e) {\n                    return { text: e[filter], value: e.id }\n                })\n            })\n        },\n        save() {\n            if (this.id) {\n                axios.put(\"/api/{{.Endpoint}}/\" + this.id, this.entity).then(this.saved)\n            } else {\n                axios.post(\"/api/{{.Endpoint}}\", this.entity).then(this.saved)\n            }\n\t\t},\n\t\tsaved(response) {\n\t\t\tthis.id = response.data.entity.id\n\t\t\t{{range .Entity.Fields}}{{if ne .Serialized \"id\"}}\n            this.entity.{{.Serialized}} = response.data.entity.{{.Serialized}}\n            {{end}}{{end}}\n\n\t\t\tthis.messages.push({\n\t\t\t\ttype: \"success\",\n\t\t\t\ttext: \"{{.Entity.Name}} saved successfully\"\n\t\t\t})\n\t\t}\n    }\n}\n</script>"),
	}
	file1d := &embedded.EmbeddedFile{
		Filename:    "vuetify/old/vuetify_editor-field-checkbox.vue.tmpl",
		FileModTime: time.Unix(1538482115, 0),
		Content:     string("<v-checkbox label=\"{{.Label}}\" v-model=\"entity.{{.Serialized}}\"></v-checkbox>"),
	}
	file1e := &embedded.EmbeddedFile{
		Filename:    "vuetify/old/vuetify_editor-field-date.vue.tmpl",
		FileModTime: time.Unix(1538482115, 0),
		Content:     string("<v-menu\n\tref=\"menu_{{.Serialized}}\"\n\tlazy\n\t:close-on-content-click=\"false\"\n\tv-model=\"dates.{{.Serialized}}.menuAppear\"\n\ttransition=\"scale-transition\"\n\toffset-y\n\tfull-width\n\t:nudge-right=\"40\"\n\tmin-width=\"290px\"\n\t:return-value.sync=\"dates.{{.Serialized}}.value\"\n\t>\n\t<v-text-field\n\t\tslot=\"activator\"\n\t\tlabel=\"{{.Label}}\"\n\t\tv-model=\"dates.{{.Serialized}}.value\"\n\t\tprepend-icon=\"event\"\n\t\treadonly\n\t\t></v-text-field>\n\t\t<v-date-picker v-model=\"dates.{{.Serialized}}.value\" @change=\"entity.{{.Serialized}} = dates.{{.Serialized}}.value + 'T00:00:00Z'\" no-title scrollable>\n\t\t<v-spacer></v-spacer>\n\t\t<v-btn flat color=\"primary\" @click=\"menu_{{.Serialized}} = false\">Cancel</v-btn>\n\t\t<v-btn flat color=\"primary\" @click=\"$refs.menu_{{.Serialized}}.save(dates.{{.Serialized}}.value)\">OK</v-btn>\n\t\t</v-date-picker>\n</v-menu>"),
	}
	file1f := &embedded.EmbeddedFile{
		Filename:    "vuetify/old/vuetify_editor-field-number.vue.tmpl",
		FileModTime: time.Unix(1538482115, 0),
		Content:     string("<v-text-field v-model=\"entity.{{.Serialized}}\" label=\"{{.Label}}\" type=\"number\" />"),
	}
	file1g := &embedded.EmbeddedFile{
		Filename:    "vuetify/old/vuetify_editor-field-password.vue.tmpl",
		FileModTime: time.Unix(1538482115, 0),
		Content:     string("<v-text-field\n\tv-model=\"entity.{{.Serialized}}\"\n\t:append-icon=\"e1 ? 'visibility' : 'visibility_off'\"\n\t:append-icon-cb=\"() => (e1 = !e1)\"\n\t:type=\"e1 ? 'password' : 'text'\"\n\tcounter\n  ></v-text-field>"),
	}
	file1h := &embedded.EmbeddedFile{
		Filename:    "vuetify/old/vuetify_editor-field-select-rel.vue.tmpl",
		FileModTime: time.Unix(1538482115, 0),
		Content:     string("<v-select\n    autocomplete\n    cache-items\n    required\n    label=\"{{.Label}}\"\n    :loading=\"select.{{.Serialized}}.isloading\"\n    :items=\"select.{{.Serialized}}.items\"\n\t:search-input.sync=\"select.{{.Serialized}}.search\"\n\tv-model=\"entity.{{.Serialized}}\"\n\t{{if .Widget.Multiple}}multiple chips{{end}}\n></v-select>"),
	}
	file1i := &embedded.EmbeddedFile{
		Filename:    "vuetify/old/vuetify_editor-field-select.vue.tmpl",
		FileModTime: time.Unix(1538482115, 0),
		Content:     string("<v-select\n\tautocomplete\n\tcache-items\n\trequired\n\tlabel=\"{{.Label}}\"\n\t:items=\"select.{{.Serialized}}.items\"\n\tv-model=\"entity.{{.Serialized}}\"\n\t{{if .Widget.Multiple}}multiple chips{{end}}\n></v-select>"),
	}
	file1j := &embedded.EmbeddedFile{
		Filename:    "vuetify/old/vuetify_editor-field-textarea.vue.tmpl",
		FileModTime: time.Unix(1538482115, 0),
		Content:     string("<v-text-field v-model=\"entity.{{.Serialized}}\" label=\"{{.Label}}\" multiline />"),
	}
	file1k := &embedded.EmbeddedFile{
		Filename:    "vuetify/old/vuetify_editor-field-textfield.vue.tmpl",
		FileModTime: time.Unix(1538482115, 0),
		Content:     string("<v-text-field v-model=\"entity.{{.Serialized}}\" label=\"{{.Label}}\" />"),
	}
	file1l := &embedded.EmbeddedFile{
		Filename:    "vuetify/old/vuetify_editor-field-time.vue.tmpl",
		FileModTime: time.Unix(1538482115, 0),
		Content:     string("<div>\n\t<v-time-picker v-model=\"entity.{{.Serialized}}\" label=\"{{.Label}}\" :landscape=\"landscape\"></v-time-picker>\n</div>"),
	}
	file1m := &embedded.EmbeddedFile{
		Filename:    "vuetify/old/vuetify_editor-field-toggle.vue.tmpl",
		FileModTime: time.Unix(1538482115, 0),
		Content:     string("<v-switch\n\tlabel=\"{{.Label}}\"\n\tv-model=\"entity.{{.Serialized}}\"\n></v-switch>"),
	}
	file1p := &embedded.EmbeddedFile{
		Filename:    "vuetify/widgets/edit/Icon.vue.tmpl",
		FileModTime: time.Unix(1538482115, 0),
		Content:     string("<template>\n  <div>\n    <v-autocomplete @change=\"$emit('gocipe', icon)\" v-model=\"icon\" :items=\"available\" :loading=\"isLoading\" :item-text=\"$attrs.label\" item-value=\"API\" :label=\"$attrs.label\" placeholder=\"Start typing to Search\" :prepend-icon=\"icon\" return-object></v-autocomplete>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      icon: \"\",\n      isLoading: false,\n      available: [\n        \"3d_rotation\",\n        \"accessibility\",\n        \"accessibility_new\",\n        \"accessible\",\n        \"accessible_forward\",\n        \"account_balance\",\n        \"account_balance_wallet\",\n        \"account_box\",\n        \"account_circle\",\n        \"add_shopping_cart\",\n        \"alarm\",\n        \"alarm_add\",\n        \"alarm_off\",\n        \"alarm_on\",\n        \"all_inbox\",\n        \"all_out\",\n        \"android\",\n        \"announcement\",\n        \"arrow_right_alt\",\n        \"aspect_ratio\",\n        \"assessment\",\n        \"assignment\",\n        \"assignment_ind\",\n        \"assignment_late\",\n        \"assignment_return\",\n        \"assignment_returned\",\n        \"assignment_turned_in\",\n        \"autorenew\",\n        \"backup\",\n        \"book\",\n        \"bookmark\",\n        \"bookmark_border\",\n        \"bookmarks\",\n        \"bug_report\",\n        \"build\",\n        \"cached\",\n        \"calendar_today\",\n        \"calendar_view_day\",\n        \"camera_enhance\",\n        \"card_giftcard\",\n        \"card_membership\",\n        \"card_travel\",\n        \"change_history\",\n        \"check_circle\",\n        \"check_circle_outline\",\n        \"chrome_reader_mode\",\n        \"class\",\n        \"code\",\n        \"commute\",\n        \"compare_arrows\",\n        \"contact_support\",\n        \"copyright\",\n        \"credit_card\",\n        \"dashboard\",\n        \"date_range\",\n        \"delete\",\n        \"delete_forever\",\n        \"delete_outline\",\n        \"description\",\n        \"dns\",\n        \"done\",\n        \"done_all\",\n        \"done_outline\",\n        \"donut_large\",\n        \"donut_small\",\n        \"drag_indicator\",\n        \"eject\",\n        \"euro_symbol\",\n        \"event\",\n        \"event_seat\",\n        \"exit_to_app\",\n        \"explore\",\n        \"explore_off\",\n        \"extension\",\n        \"face\",\n        \"favorite\",\n        \"favorite_border\",\n        \"feedback\",\n        \"find_in_page\",\n        \"find_replace\",\n        \"fingerprint\",\n        \"flight_land\",\n        \"flight_takeoff\",\n        \"flip_to_back\",\n        \"flip_to_front\",\n        \"g_translate\",\n        \"gavel\",\n        \"get_app\",\n        \"gif\",\n        \"grade\",\n        \"group_work\",\n        \"help\",\n        \"help_outline\",\n        \"highlight_off\",\n        \"history\",\n        \"home\",\n        \"horizontal_split\",\n        \"hourglass_empty\",\n        \"hourglass_full\",\n        \"http\",\n        \"https\",\n        \"important_devices\",\n        \"info\",\n        \"input\",\n        \"invert_colors\",\n        \"label\",\n        \"label_important\",\n        \"label_off\",\n        \"language\",\n        \"launch\",\n        \"line_style\",\n        \"line_weight\",\n        \"list\",\n        \"lock\",\n        \"lock_open\",\n        \"loyalty\",\n        \"markunread_mailbox\",\n        \"maximize\",\n        \"minimize\",\n        \"motorcycle\",\n        \"note_add\",\n        \"offline_bolt\",\n        \"offline_pin\",\n        \"opacity\",\n        \"open_in_browser\",\n        \"open_in_new\",\n        \"open_with\",\n        \"pageview\",\n        \"pan_tool\",\n        \"payment\",\n        \"perm_camera_mic\",\n        \"perm_contact_calendar\",\n        \"perm_data_setting\",\n        \"perm_device_information\",\n        \"perm_identity\",\n        \"perm_media\",\n        \"perm_phone_msg\",\n        \"perm_scan_wifi\",\n        \"pets\",\n        \"picture_in_picture\",\n        \"picture_in_picture_alt\",\n        \"play_for_work\",\n        \"polymer\",\n        \"power_settings_new\",\n        \"pregnant_woman\",\n        \"print\",\n        \"query_builder\",\n        \"question_answer\",\n        \"receipt\",\n        \"record_voice_over\",\n        \"redeem\",\n        \"remove_shopping_cart\",\n        \"reorder\",\n        \"report_problem\",\n        \"restore\",\n        \"restore_from_trash\",\n        \"restore_page\",\n        \"room\",\n        \"rounded_corner\",\n        \"rowing\",\n        \"schedule\",\n        \"search\",\n        \"settings\",\n        \"settings_applications\",\n        \"settings_backup_restore\",\n        \"settings_bluetooth\",\n        \"settings_brightness\",\n        \"settings_cell\",\n        \"settings_ethernet\",\n        \"settings_input_antenna\",\n        \"settings_input_component\",\n        \"settings_input_composite\",\n        \"settings_input_hdmi\",\n        \"settings_input_svideo\",\n        \"settings_overscan\",\n        \"settings_phone\",\n        \"settings_power\",\n        \"settings_remote\",\n        \"settings_voice\",\n        \"shop\",\n        \"shop_two\",\n        \"shopping_basket\",\n        \"shopping_cart\",\n        \"speaker_notes\",\n        \"speaker_notes_off\",\n        \"spellcheck\",\n        \"star_rate\",\n        \"stars\",\n        \"store\",\n        \"subject\",\n        \"supervised_user_circle\",\n        \"supervisor_account\",\n        \"swap_horiz\",\n        \"swap_horizontal_circle\",\n        \"swap_vert\",\n        \"swap_vertical_circle\",\n        \"tab\",\n        \"tab_unselected\",\n        \"text_rotate_up\",\n        \"text_rotate_vertical\",\n        \"text_rotation_down\",\n        \"text_rotation_none\",\n        \"theaters\",\n        \"thumb_down\",\n        \"thumb_up\",\n        \"thumbs_up_down\",\n        \"timeline\",\n        \"toc\",\n        \"today\",\n        \"toll\",\n        \"touch_app\",\n        \"track_changes\",\n        \"translate\",\n        \"trending_down\",\n        \"trending_flat\",\n        \"trending_up\",\n        \"turned_in\",\n        \"turned_in_not\",\n        \"update\",\n        \"verified_user\",\n        \"vertical_split\",\n        \"view_agenda\",\n        \"view_array\",\n        \"view_carousel\",\n        \"view_column\",\n        \"view_day\",\n        \"view_headline\",\n        \"view_list\",\n        \"view_module\",\n        \"view_quilt\",\n        \"view_stream\",\n        \"view_week\",\n        \"visibility\",\n        \"visibility_off\",\n        \"voice_over_off\",\n        \"watch_later\",\n        \"work\",\n        \"work_off\",\n        \"work_outline\",\n        \"youtube_searched_for\",\n        \"zoom_in\",\n        \"zoom_out\",\n        \"add_alert\",\n        \"error\",\n        \"error_outline\",\n        \"notification_important\",\n        \"warning\",\n        \"4k\",\n        \"add_to_queue\",\n        \"airplay\",\n        \"album\",\n        \"art_track\",\n        \"av_timer\",\n        \"branding_watermark\",\n        \"call_to_action\",\n        \"closed_caption\",\n        \"control_camera\",\n        \"equalizer\",\n        \"explicit\",\n        \"fast_forward\",\n        \"fast_rewind\",\n        \"featured_play_list\",\n        \"featured_video\",\n        \"fiber_dvr\",\n        \"fiber_manual_record\",\n        \"fiber_new\",\n        \"fiber_pin\",\n        \"fiber_smart_record\",\n        \"forward_10\",\n        \"forward_30\",\n        \"forward_5\",\n        \"games\",\n        \"hd\",\n        \"hearing\",\n        \"high_quality\",\n        \"library_add\",\n        \"library_books\",\n        \"library_music\",\n        \"loop\",\n        \"mic\",\n        \"mic_none\",\n        \"mic_off\",\n        \"missed_video_call\",\n        \"movie\",\n        \"music_video\",\n        \"new_releases\",\n        \"not_interested\",\n        \"note\",\n        \"pause\",\n        \"pause_circle_filled\",\n        \"pause_circle_outline\",\n        \"play_arrow\",\n        \"play_circle_filled\",\n        \"play_circle_filled_white\",\n        \"play_circle_outline\",\n        \"playlist_add\",\n        \"playlist_add_check\",\n        \"playlist_play\",\n        \"queue\",\n        \"queue_music\",\n        \"queue_play_next\",\n        \"radio\",\n        \"recent_actors\",\n        \"remove_from_queue\",\n        \"repeat\",\n        \"repeat_one\",\n        \"replay\",\n        \"replay_10\",\n        \"replay_30\",\n        \"replay_5\",\n        \"shuffle\",\n        \"skip_next\",\n        \"skip_previous\",\n        \"slow_motion_video\",\n        \"snooze\",\n        \"sort_by_alpha\",\n        \"stop\",\n        \"subscriptions\",\n        \"subtitles\",\n        \"surround_sound\",\n        \"video_call\",\n        \"video_label\",\n        \"video_library\",\n        \"videocam\",\n        \"videocam_off\",\n        \"volume_down\",\n        \"volume_mute\",\n        \"volume_off\",\n        \"volume_up\",\n        \"web\",\n        \"web_asset\",\n        \"alternate_email\",\n        \"business\",\n        \"call\",\n        \"call_end\",\n        \"call_made\",\n        \"call_merge\",\n        \"call_missed\",\n        \"call_missed_outgoing\",\n        \"call_received\",\n        \"call_split\",\n        \"cancel_presentation\",\n        \"cell_wifi\",\n        \"chat\",\n        \"chat_bubble\",\n        \"chat_bubble_outline\",\n        \"clear_all\",\n        \"comment\",\n        \"contact_mail\",\n        \"contact_phone\",\n        \"contacts\",\n        \"desktop_access_disabled\",\n        \"dialer_sip\",\n        \"dialpad\",\n        \"domain_disabled\",\n        \"duo\",\n        \"email\",\n        \"forum\",\n        \"import_contacts\",\n        \"import_export\",\n        \"invert_colors_off\",\n        \"list_alt\",\n        \"live_help\",\n        \"location_off\",\n        \"location_on\",\n        \"mail_outline\",\n        \"message\",\n        \"mobile_screen_share\",\n        \"no_sim\",\n        \"pause_presentation\",\n        \"person_add_disabled\",\n        \"phone\",\n        \"phonelink_erase\",\n        \"phonelink_lock\",\n        \"phonelink_ring\",\n        \"phonelink_setup\",\n        \"portable_wifi_off\",\n        \"present_to_all\",\n        \"print_disabled\",\n        \"ring_volume\",\n        \"rss_feed\",\n        \"screen_share\",\n        \"sentiment_satisfied_alt\",\n        \"speaker_phone\",\n        \"stay_current_landscape\",\n        \"stay_current_portrait\",\n        \"stay_primary_landscape\",\n        \"stay_primary_portrait\",\n        \"stop_screen_share\",\n        \"swap_calls\",\n        \"textsms\",\n        \"unsubscribe\",\n        \"voicemail\",\n        \"vpn_key\",\n        \"add\",\n        \"add_box\",\n        \"add_circle\",\n        \"add_circle_outline\",\n        \"archive\",\n        \"backspace\",\n        \"ballot\",\n        \"block\",\n        \"clear\",\n        \"create\",\n        \"delete_sweep\",\n        \"drafts\",\n        \"file_copy\",\n        \"filter_list\",\n        \"flag\",\n        \"font_download\",\n        \"forward\",\n        \"gesture\",\n        \"how_to_reg\",\n        \"how_to_vote\",\n        \"inbox\",\n        \"link\",\n        \"link_off\",\n        \"low_priority\",\n        \"mail\",\n        \"markunread\",\n        \"move_to_inbox\",\n        \"next_week\",\n        \"outlined_flag\",\n        \"redo\",\n        \"remove\",\n        \"remove_circle\",\n        \"remove_circle_outline\",\n        \"reply\",\n        \"reply_all\",\n        \"report\",\n        \"report_off\",\n        \"save\",\n        \"save_alt\",\n        \"select_all\",\n        \"send\",\n        \"sort\",\n        \"text_format\",\n        \"unarchive\",\n        \"undo\",\n        \"waves\",\n        \"weekend\",\n        \"where_to_vote\",\n        \"access_alarm\",\n        \"access_alarms\",\n        \"access_time\",\n        \"add_alarm\",\n        \"add_to_home_screen\",\n        \"airplanemode_active\",\n        \"airplanemode_inactive\",\n        \"battery_20\",\n        \"battery_30\",\n        \"battery_50\",\n        \"battery_60\",\n        \"battery_80\",\n        \"battery_90\",\n        \"battery_alert\",\n        \"battery_charging_20\",\n        \"battery_charging_30\",\n        \"battery_charging_50\",\n        \"battery_charging_60\",\n        \"battery_charging_80\",\n        \"battery_charging_90\",\n        \"battery_charging_full\",\n        \"battery_full\",\n        \"battery_std\",\n        \"battery_unknown\",\n        \"bluetooth\",\n        \"bluetooth_connected\",\n        \"bluetooth_disabled\",\n        \"bluetooth_searching\",\n        \"brightness_auto\",\n        \"brightness_high\",\n        \"brightness_low\",\n        \"brightness_medium\",\n        \"data_usage\",\n        \"developer_mode\",\n        \"devices\",\n        \"dvr\",\n        \"gps_fixed\",\n        \"gps_not_fixed\",\n        \"gps_off\",\n        \"graphic_eq\",\n        \"location_disabled\",\n        \"location_searching\",\n        \"mobile_friendly\",\n        \"mobile_off\",\n        \"network_cell\",\n        \"network_wifi\",\n        \"nfc\",\n        \"screen_lock_landscape\",\n        \"screen_lock_portrait\",\n        \"screen_lock_rotation\",\n        \"screen_rotation\",\n        \"sd_storage\",\n        \"settings_system_daydream\",\n        \"signal_cellular_0_bar\",\n        \"signal_cellular_1_bar\",\n        \"signal_cellular_2_bar\",\n        \"signal_cellular_3_bar\",\n        \"signal_cellular_4_bar\",\n        \"signal_cellular_alt\",\n        \"signal_cellular_connected_no_internet_0_bar\",\n        \"signal_cellular_connected_no_internet_1_bar\",\n        \"signal_cellular_connected_no_internet_2_bar\",\n        \"signal_cellular_connected_no_internet_3_bar\",\n        \"signal_cellular_connected_no_internet_4_bar\",\n        \"signal_cellular_no_sim\",\n        \"signal_cellular_null\",\n        \"signal_cellular_off\",\n        \"signal_wifi_0_bar\",\n        \"signal_wifi_1_bar\",\n        \"signal_wifi_1_bar_lock\",\n        \"signal_wifi_2_bar\",\n        \"signal_wifi_2_bar_lock\",\n        \"signal_wifi_3_bar\",\n        \"signal_wifi_3_bar_lock\",\n        \"signal_wifi_4_bar\",\n        \"signal_wifi_4_bar_lock\",\n        \"signal_wifi_off\",\n        \"storage\",\n        \"usb\",\n        \"wallpaper\",\n        \"widgets\",\n        \"wifi_lock\",\n        \"wifi_tethering\",\n        \"add_comment\",\n        \"attach_file\",\n        \"attach_money\",\n        \"bar_chart\",\n        \"border_all\",\n        \"border_bottom\",\n        \"border_clear\",\n        \"border_color\",\n        \"border_horizontal\",\n        \"border_inner\",\n        \"border_left\",\n        \"border_outer\",\n        \"border_right\",\n        \"border_style\",\n        \"border_top\",\n        \"border_vertical\",\n        \"bubble_chart\",\n        \"drag_handle\",\n        \"format_align_center\",\n        \"format_align_justify\",\n        \"format_align_left\",\n        \"format_align_right\",\n        \"format_bold\",\n        \"format_clear\",\n        \"format_color_fill\",\n        \"format_color_reset\",\n        \"format_color_text\",\n        \"format_indent_decrease\",\n        \"format_indent_increase\",\n        \"format_italic\",\n        \"format_line_spacing\",\n        \"format_list_bulleted\",\n        \"format_list_numbered\",\n        \"format_list_numbered_rtl\",\n        \"format_paint\",\n        \"format_quote\",\n        \"format_shapes\",\n        \"format_size\",\n        \"format_strikethrough\",\n        \"format_textdirection_l_to_r\",\n        \"format_textdirection_r_to_l\",\n        \"format_underlined\",\n        \"functions\",\n        \"highlight\",\n        \"insert_chart\",\n        \"insert_chart_outlined\",\n        \"insert_comment\",\n        \"insert_drive_file\",\n        \"insert_emoticon\",\n        \"insert_invitation\",\n        \"insert_link\",\n        \"insert_photo\",\n        \"linear_scale\",\n        \"merge_type\",\n        \"mode_comment\",\n        \"monetization_on\",\n        \"money_off\",\n        \"multiline_chart\",\n        \"notes\",\n        \"pie_chart\",\n        \"publish\",\n        \"scatter_plot\",\n        \"score\",\n        \"short_text\",\n        \"show_chart\",\n        \"space_bar\",\n        \"strikethrough_s\",\n        \"table_chart\",\n        \"text_fields\",\n        \"title\",\n        \"vertical_align_bottom\",\n        \"vertical_align_center\",\n        \"vertical_align_top\",\n        \"wrap_text\",\n        \"attachment\",\n        \"cloud\",\n        \"cloud_circle\",\n        \"cloud_done\",\n        \"cloud_download\",\n        \"cloud_off\",\n        \"cloud_queue\",\n        \"cloud_upload\",\n        \"create_new_folder\",\n        \"folder\",\n        \"folder_open\",\n        \"folder_shared\",\n        \"cast\",\n        \"cast_connected\",\n        \"cast_for_education\",\n        \"computer\",\n        \"desktop_mac\",\n        \"desktop_windows\",\n        \"developer_board\",\n        \"device_hub\",\n        \"device_unknown\",\n        \"devices_other\",\n        \"dock\",\n        \"gamepad\",\n        \"headset\",\n        \"headset_mic\",\n        \"keyboard\",\n        \"keyboard_arrow_down\",\n        \"keyboard_arrow_left\",\n        \"keyboard_arrow_right\",\n        \"keyboard_arrow_up\",\n        \"keyboard_backspace\",\n        \"keyboard_capslock\",\n        \"keyboard_hide\",\n        \"keyboard_return\",\n        \"keyboard_tab\",\n        \"keyboard_voice\",\n        \"laptop\",\n        \"laptop_chromebook\",\n        \"laptop_mac\",\n        \"laptop_windows\",\n        \"memory\",\n        \"mouse\",\n        \"phone_android\",\n        \"phone_iphone\",\n        \"phonelink\",\n        \"phonelink_off\",\n        \"power_input\",\n        \"router\",\n        \"scanner\",\n        \"security\",\n        \"sim_card\",\n        \"smartphone\",\n        \"speaker\",\n        \"speaker_group\",\n        \"tablet\",\n        \"tablet_android\",\n        \"tablet_mac\",\n        \"toys\",\n        \"tv\",\n        \"videogame_asset\",\n        \"watch\",\n        \"add_a_photo\",\n        \"add_photo_alternate\",\n        \"add_to_photos\",\n        \"adjust\",\n        \"assistant\",\n        \"assistant_photo\",\n        \"audiotrack\",\n        \"blur_circular\",\n        \"blur_linear\",\n        \"blur_off\",\n        \"blur_on\",\n        \"brightness_1\",\n        \"brightness_2\",\n        \"brightness_3\",\n        \"brightness_4\",\n        \"brightness_5\",\n        \"brightness_6\",\n        \"brightness_7\",\n        \"broken_image\",\n        \"brush\",\n        \"burst_mode\",\n        \"camera\",\n        \"camera_alt\",\n        \"camera_front\",\n        \"camera_rear\",\n        \"camera_roll\",\n        \"center_focus_strong\",\n        \"center_focus_weak\",\n        \"collections\",\n        \"collections_bookmark\",\n        \"color_lens\",\n        \"colorize\",\n        \"compare\",\n        \"control_point\",\n        \"control_point_duplicate\",\n        \"crop\",\n        \"crop_16_9\",\n        \"crop_3_2\",\n        \"crop_5_4\",\n        \"crop_7_5\",\n        \"crop_din\",\n        \"crop_free\",\n        \"crop_landscape\",\n        \"crop_original\",\n        \"crop_portrait\",\n        \"crop_rotate\",\n        \"crop_square\",\n        \"dehaze\",\n        \"details\",\n        \"edit\",\n        \"exposure\",\n        \"exposure_neg_1\",\n        \"exposure_neg_2\",\n        \"exposure_plus_1\",\n        \"exposure_plus_2\",\n        \"exposure_zero\",\n        \"filter\",\n        \"filter_1\",\n        \"filter_2\",\n        \"filter_3\",\n        \"filter_4\",\n        \"filter_5\",\n        \"filter_6\",\n        \"filter_7\",\n        \"filter_8\",\n        \"filter_9\",\n        \"filter_9_plus\",\n        \"filter_b_and_w\",\n        \"filter_center_focus\",\n        \"filter_drama\",\n        \"filter_frames\",\n        \"filter_hdr\",\n        \"filter_none\",\n        \"filter_tilt_shift\",\n        \"filter_vintage\",\n        \"flare\",\n        \"flash_auto\",\n        \"flash_off\",\n        \"flash_on\",\n        \"flip\",\n        \"gradient\",\n        \"grain\",\n        \"grid_off\",\n        \"grid_on\",\n        \"hdr_off\",\n        \"hdr_on\",\n        \"hdr_strong\",\n        \"hdr_weak\",\n        \"healing\",\n        \"image\",\n        \"image_aspect_ratio\",\n        \"image_search\",\n        \"iso\",\n        \"landscape\",\n        \"leak_add\",\n        \"leak_remove\",\n        \"lens\",\n        \"linked_camera\",\n        \"looks\",\n        \"looks_3\",\n        \"looks_4\",\n        \"looks_5\",\n        \"looks_6\",\n        \"looks_one\",\n        \"looks_two\",\n        \"loupe\",\n        \"monochrome_photos\",\n        \"movie_creation\",\n        \"movie_filter\",\n        \"music_note\",\n        \"music_off\",\n        \"nature\",\n        \"nature_people\",\n        \"navigate_before\",\n        \"navigate_next\",\n        \"palette\",\n        \"panorama\",\n        \"panorama_fish_eye\",\n        \"panorama_horizontal\",\n        \"panorama_vertical\",\n        \"panorama_wide_angle\",\n        \"photo\",\n        \"photo_album\",\n        \"photo_camera\",\n        \"photo_filter\",\n        \"photo_library\",\n        \"photo_size_select_actual\",\n        \"photo_size_select_large\",\n        \"photo_size_select_small\",\n        \"picture_as_pdf\",\n        \"portrait\",\n        \"remove_red_eye\",\n        \"rotate_90_degrees_ccw\",\n        \"rotate_left\",\n        \"rotate_right\",\n        \"shutter_speed\",\n        \"slideshow\",\n        \"straighten\",\n        \"style\",\n        \"switch_camera\",\n        \"switch_video\",\n        \"tag_faces\",\n        \"texture\",\n        \"timelapse\",\n        \"timer\",\n        \"timer_10\",\n        \"timer_3\",\n        \"timer_off\",\n        \"tonality\",\n        \"transform\",\n        \"tune\",\n        \"view_comfy\",\n        \"view_compact\",\n        \"vignette\",\n        \"wb_auto\",\n        \"wb_cloudy\",\n        \"wb_incandescent\",\n        \"wb_iridescent\",\n        \"wb_sunny\",\n        \"360\",\n        \"add_location\",\n        \"atm\",\n        \"beenhere\",\n        \"category\",\n        \"compass_calibration\",\n        \"departure_board\",\n        \"directions\",\n        \"directions_bike\",\n        \"directions_boat\",\n        \"directions_bus\",\n        \"directions_car\",\n        \"directions_railway\",\n        \"directions_run\",\n        \"directions_subway\",\n        \"directions_transit\",\n        \"directions_walk\",\n        \"edit_attributes\",\n        \"edit_location\",\n        \"ev_station\",\n        \"fastfood\",\n        \"flight\",\n        \"hotel\",\n        \"layers\",\n        \"layers_clear\",\n        \"local_activity\",\n        \"local_airport\",\n        \"local_atm\",\n        \"local_bar\",\n        \"local_cafe\",\n        \"local_car_wash\",\n        \"local_convenience_store\",\n        \"local_dining\",\n        \"local_drink\",\n        \"local_florist\",\n        \"local_gas_station\",\n        \"local_grocery_store\",\n        \"local_hospital\",\n        \"local_hotel\",\n        \"local_laundry_service\",\n        \"local_library\",\n        \"local_mall\",\n        \"local_movies\",\n        \"local_offer\",\n        \"local_parking\",\n        \"local_pharmacy\",\n        \"local_phone\",\n        \"local_pizza\",\n        \"local_play\",\n        \"local_post_office\",\n        \"local_printshop\",\n        \"local_see\",\n        \"local_shipping\",\n        \"local_taxi\",\n        \"map\",\n        \"money\",\n        \"my_location\",\n        \"navigation\",\n        \"near_me\",\n        \"not_listed_location\",\n        \"person_pin\",\n        \"person_pin_circle\",\n        \"pin_drop\",\n        \"place\",\n        \"rate_review\",\n        \"restaurant\",\n        \"restaurant_menu\",\n        \"satellite\",\n        \"store_mall_directory\",\n        \"streetview\",\n        \"subway\",\n        \"terrain\",\n        \"traffic\",\n        \"train\",\n        \"tram\",\n        \"transfer_within_a_station\",\n        \"transit_enterexit\",\n        \"trip_origin\",\n        \"zoom_out_map\",\n        \"apps\",\n        \"arrow_back\",\n        \"arrow_back_ios\",\n        \"arrow_downward\",\n        \"arrow_drop_down\",\n        \"arrow_drop_down_circle\",\n        \"arrow_drop_up\",\n        \"arrow_forward\",\n        \"arrow_forward_ios\",\n        \"arrow_left\",\n        \"arrow_right\",\n        \"arrow_upward\",\n        \"cancel\",\n        \"check\",\n        \"chevron_left\",\n        \"chevron_right\",\n        \"close\",\n        \"expand_less\",\n        \"expand_more\",\n        \"first_page\",\n        \"fullscreen\",\n        \"fullscreen_exit\",\n        \"last_page\",\n        \"menu\",\n        \"more_horiz\",\n        \"more_vert\",\n        \"refresh\",\n        \"subdirectory_arrow_left\",\n        \"subdirectory_arrow_right\",\n        \"unfold_less\",\n        \"unfold_more\",\n        \"adb\",\n        \"airline_seat_flat\",\n        \"airline_seat_flat_angled\",\n        \"airline_seat_individual_suite\",\n        \"airline_seat_legroom_extra\",\n        \"airline_seat_legroom_normal\",\n        \"airline_seat_legroom_reduced\",\n        \"airline_seat_recline_extra\",\n        \"airline_seat_recline_normal\",\n        \"bluetooth_audio\",\n        \"confirmation_number\",\n        \"disc_full\",\n        \"drive_eta\",\n        \"enhanced_encryption\",\n        \"event_available\",\n        \"event_busy\",\n        \"event_note\",\n        \"folder_special\",\n        \"live_tv\",\n        \"mms\",\n        \"more\",\n        \"network_check\",\n        \"network_locked\",\n        \"no_encryption\",\n        \"ondemand_video\",\n        \"personal_video\",\n        \"phone_bluetooth_speaker\",\n        \"phone_callback\",\n        \"phone_forwarded\",\n        \"phone_in_talk\",\n        \"phone_locked\",\n        \"phone_missed\",\n        \"phone_paused\",\n        \"power\",\n        \"power_off\",\n        \"priority_high\",\n        \"sd_card\",\n        \"sms\",\n        \"sms_failed\",\n        \"sync\",\n        \"sync_disabled\",\n        \"sync_problem\",\n        \"system_update\",\n        \"tap_and_play\",\n        \"time_to_leave\",\n        \"tv_off\",\n        \"vibration\",\n        \"voice_chat\",\n        \"vpn_lock\",\n        \"wc\",\n        \"wifi\",\n        \"wifi_off\",\n        \"ac_unit\",\n        \"airport_shuttle\",\n        \"all_inclusive\",\n        \"beach_access\",\n        \"business_center\",\n        \"casino\",\n        \"child_care\",\n        \"child_friendly\",\n        \"fitness_center\",\n        \"free_breakfast\",\n        \"golf_course\",\n        \"hot_tub\",\n        \"kitchen\",\n        \"meeting_room\",\n        \"no_meeting_room\",\n        \"pool\",\n        \"room_service\",\n        \"rv_hookup\",\n        \"smoke_free\",\n        \"smoking_rooms\",\n        \"spa\",\n        \"cake\",\n        \"domain\",\n        \"group\",\n        \"group_add\",\n        \"location_city\",\n        \"mood\",\n        \"mood_bad\",\n        \"notifications\",\n        \"notifications_active\",\n        \"notifications_none\",\n        \"notifications_off\",\n        \"notifications_paused\",\n        \"pages\",\n        \"party_mode\",\n        \"people\",\n        \"people_outline\",\n        \"person\",\n        \"person_add\",\n        \"person_outline\",\n        \"plus_one\",\n        \"poll\",\n        \"public\",\n        \"school\",\n        \"sentiment_dissatisfied\",\n        \"sentiment_satisfied\",\n        \"sentiment_very_dissatisfied\",\n        \"sentiment_very_satisfied\",\n        \"share\",\n        \"thumb_down_alt\",\n        \"thumb_up_alt\",\n        \"whatshot\",\n        \"check_box\",\n        \"check_box_outline_blank\",\n        \"indeterminate_check_box\",\n        \"radio_button_checked\",\n        \"radio_button_unchecked\",\n        \"star\",\n        \"star_border\",\n        \"star_half\",\n        \"toggle_off\",\n        \"toggle_on\"\n      ]\n    };\n  },\n  created() {\n    this.icon = this.$attrs.value;\n  },\n  inheritAttrs: false\n};\n</script>\n"),
	}
	file1q := &embedded.EmbeddedFile{
		Filename:    "vuetify/widgets/edit/Imagefield.vue.tmpl",
		FileModTime: time.Unix(1539936849, 0),
		Content:     string("<template>\n  <div class=\"mt-4 mb-4\">\n    <div class=\"caption v-label v-label--active theme--light pb-2\">{{ \"{{ $attrs.label }}\" }}</div>\n    <div class=\"uploader-wrapper mt-1\">\n      <picture-input buttonClass ref=\"pictureInput\" :crop=\"false\" :z-index=\"0\"\n        class=\"image-uploader\" :prefill=\"image\" width=\"400\" height=\"200\" margin=\"16\"\n        accept=\"image/jpeg,image/png\" size=\"10\" button-class=\"btn\"\n        :custom-strings=\"{\n                    upload: '<h3>Image</h3>', drag: 'Click here to upload image' }\"\n        @change=\"onChange\">\n      </picture-input>\n      <div class=\"px-2\">\n        <v-checkbox\n          label=\"Apply watermark\"\n          v-model=\"watermark\"\n          class=\"mb-0\"\n        ></v-checkbox>\n      </div>\n      <template v-if=\"uploadStatus.uploading\">\n        <v-progress-linear :indeterminate=\"uploadStatus.uploading\"></v-progress-linear>\n      </template>\n      <v-alert :value=\"uploadStatus.success\" type=\"success\" dismissible class=\"pa-2\" transition=\"scale-transition\">\n        Image upload successful\n      </v-alert>\n      <v-alert :value=\"uploadStatus.error\" type=\"error\" dismissible small transition=\"scale-transition\">\n      {{ \"{{ uploadStatus.error | capitalize }}\" }}\n      </v-alert>\n      <v-alert :value=\"true\" color=\"gray lighten-3\" dark icon=\"info\" class=\"pa-2\">\n      {{ \"{{ $attrs.hint }}\" }}\n      </v-alert>\n    </div>\n  </div>\n</template>\n\n<script>\nimport { AdminClient } from \"@/services/service_admin_pb_service\";\nimport { UploadRequest, UploadOpts } from \"@/services/service_admin_pb\";\nimport { File } from \"@/services/service_admin_pb\";\nimport PictureInput from \"vue-picture-input\";\n\nfunction convertDataURIToBinary(dataURI) {\n  var base64Index = dataURI.indexOf(\";base64,\") + 8;\n  var base64 = dataURI.substring(base64Index);\n  var raw = window.atob(base64);\n  var rawLength = raw.length;\n  var array = new Uint8Array(new ArrayBuffer(rawLength));\n\n  for (var i = 0; i < rawLength; i++) {\n    array[i] = raw.charCodeAt(i);\n  }\n\n  return array;\n}\n\nlet cli = new AdminClient(\"/api\");\n\nexport default {\n  inheritAttrs: false,\n  props: [\"field\", \"rpc\", \"entityid\"],\n  data() {\n    return {\n      image: \"\",\n      uploadStatus: {\n        success: false,\n        error: null,\n        uploading: false\n      },\n      uploadOptions: null\n    };\n  },\n  components: {\n    PictureInput\n  },\n  created() {\n    this.image = this.$attrs.value;\n\n    this.uploadOptions = new UploadOpts();\n    this.uploadOptions.setWatermark(true);\n  },\n  filters: {\n    capitalize: function(value) {\n      if (!value) return \"\";\n      value = value.toString();\n      return value.charAt(0).toUpperCase() + value.slice(1);\n    }\n  },\n  computed: {\n    watermark: {\n      set(status) {\n        this.uploadOptions.setWatermark(status);\n      },\n      get() {\n        return this.uploadOptions.getWatermark();\n      }\n    }\n  },\n  methods: {\n    onChange(image) {\n      console.log(\"upload triggered\");\n      if (!image) {\n        console.log(\"FileReader API not supported: use the <form>, Luke!\");\n        return;\n      }\n\n      // Resets alerts\n      this.uploadStatus.error = null;\n      this.uploadStatus.success = false;\n\n      // Finds image name\n      let req = new UploadRequest();\n      req.setId(this.entityid);\n      req.setField(this.field);\n      req.setFilename(this.$refs.pictureInput.file.name);\n      req.setContent(convertDataURIToBinary(image));\n      req.setUploadoptions(this.uploadOptions);\n      this.uploadStatus.uploading = true;\n\n      cli[this.rpc](req, (err, resp) => {\n        this.uploadStatus.uploading = false;\n        if (err) {\n          console.log(err);\n          this.uploadStatus.error = err.message;\n          return;\n        }\n\n        this.uploadStatus.success = true;\n\n        this.image = resp.getUri();\n      });\n    }\n  }\n};\n</script>\n\n<style lang=\"scss\" scoped>\n.uploader-wrapper {\n  background: #c9c9c9;\n}\n.image-container {\n  height: 200px;\n  width: 200px;\n  img {\n    display: block;\n    height: 200px;\n    width: auto;\n  }\n}\n</style>\n"),
	}
	file1r := &embedded.EmbeddedFile{
		Filename:    "vuetify/widgets/edit/Map.vue.tmpl",
		FileModTime: time.Unix(1538482115, 0),
		Content:     string("<template>\n  <div>\n\n    <v-text-field @click=\"dialog = true\" :hint=\"$attrs.hint\" :label=\"$attrs.label\" append-icon=\"map\" :value=\"geo\" :placeholder=\"$attrs.label\"></v-text-field>\n\n    <v-dialog v-model=\"dialog\" :max-width=\"1200\">\n\n      <v-card>\n        <v-card-title class=\"headline grey lighten-2\" primary-title>\n          Pick a location | {{ \"{{ coordinate }}\" }}\n        </v-card-title>\n\n        <v-card-text class=\"ma-0 pa-0\">\n          <div class=\"map-container\">\n            <mgl-map :accessToken=\"accessToken\" :mapStyle=\"mapStyle\" :center.sync=\"center\" ref=\"mapbox\" :zoom.sync=\"zoom\" :repaint=\"true\" class=\"\">\n              <mgl-navigation-control position=\"top-right\" />\n              <mgl-geolocate-control position=\"top-right\" />\n              <mgl-marker :coordinates.sync=\"coordinate\" @update:coordinates=\"updateCoordinates\" :draggable=\"true\" color=\"#004a8f\"></mgl-marker>\n            </mgl-map>\n\n          </div>\n        </v-card-text>\n\n        <v-divider></v-divider>\n\n        <v-card-actions>\n          <v-spacer></v-spacer>\n          <v-btn color=\"gray\" flat @click=\"dialog = false\">\n            Cancel\n          </v-btn>\n          <v-btn color=\"primary\" flat @click=\"saveCoordinates\">\n            Confirm\n          </v-btn>\n        </v-card-actions>\n      </v-card>\n    </v-dialog>\n\n  </div>\n</template>\n\n<script>\nimport {\n  MglMap,\n  MglMarker,\n  MglNavigationControl,\n  MglGeolocateControl\n} from \"vue-mapbox\";\nexport default {\n  data() {\n    return {\n      geo: \"\",\n      accessToken:\n        \"pk.eyJ1Ijoiamplc2h0YSIsImEiOiJjaml2YmdvMXUyamMyM3dwYXN4NHF3Mmx6In0.asPeKTbLW9O-oa3fLuoFog\",\n      mapStyle: \"mapbox://styles/mapbox/streets-v10\",\n      dialog: false,\n      popupCoordinates: [10, 10],\n      center: [],\n      coordinate: [],\n      marker: [],\n      zoom: 9\n    };\n  },\n  components: {\n    MglMap,\n    MglNavigationControl,\n    MglGeolocateControl,\n    MglMarker\n  },\n  created() {\n    this.geo = this.$attrs.value;\n    this.center = this.makeCoordinateArray(this.geo);\n    this.coordinate = this.makeCoordinateArray(this.geo);\n  },\n  computed: {},\n  methods: {\n    makeCoordinateArray(coordinate) {\n      if (coordinate.length === 0) {\n        return [57.61076888351013, -20.122395281744758];\n      } else if (typeof coordinate === \"string\") {\n        return coordinate.split(\",\");\n      } else {\n        return coordinate;\n      }\n    },\n    updateCoordinates(event) {\n      this.geo = event;\n      //   this.addrlong = event[0];\n      //   this.addrlat = event[1];\n    },\n    saveCoordinates() {\n      this.dialog = false;\n      let latlong = this.geo.toString();\n      this.$emit(\"gocipe\", latlong);\n    }\n  },\n  watch: {\n    dialog: function(visible) {\n      if (visible) {\n        setTimeout(() => {\n          this.$refs.mapbox.resize();\n        }, 100);\n        // this.$refs.mapbox.fitBounds();\n      }\n    }\n  },\n  inheritAttrs: false\n};\n</script>\n\n\n<style >\n.map-container {\n  /* width: 300px; */\n  height: 500px;\n  display: block;\n}\n.map-container .mapboxgl-canvas-container {\n  height: 500px;\n}\n</style>\n"),
	}
	file1s := &embedded.EmbeddedFile{
		Filename:    "vuetify/widgets/edit/Select.vue.tmpl",
		FileModTime: time.Unix(1538482115, 0),
		Content:     string("<template>\n    <div>\n        <v-select :hint=\"$attrs.hint\" :label=\"$attrs.label\" @change=\"$emit('gocipe',text)\" v-model=\"text\" :items=\"options\"></v-select>\n    </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      text: \"\",\n      options: []\n    };\n  },\n  created() {\n    this.text = this.$attrs.value;\n    this.options = this.$attrs.options;\n\n    this.$emit('gocipe', this.text);\n  },\n  inheritAttrs: false\n};\n</script>\n"),
	}
	file1t := &embedded.EmbeddedFile{
		Filename:    "vuetify/widgets/edit/SelectRel.vue.tmpl",
		FileModTime: time.Unix(1539416325, 0),
		Content:     string("\n<template>\n  <div class=\"pt-3\">\n    <v-autocomplete :disabled=\"loadingStatus\" :loading=\"loadingStatus\" @change=\"updateParent\" v-model=\"selection\" :multiple=\"multiple\" :items=\"options\" :label=\"$attrs.label\">\n      <template slot=\"selection\" slot-scope=\"data\">\n        <v-chip :selected=\"data.selected\" close class=\"chip--select-multi\"\n          @input=\"remove(data.item)\">\n         {{ \"{{ data.item.text }}\" }}\n        </v-chip>\n      </template>\n\n      <template slot=\"item\" slot-scope=\"data\">\n        <v-list-tile>\n          <v-list-tile-action>\n            <v-checkbox v-model=\"data.tile.props.value\"></v-checkbox>\n          </v-list-tile-action>\n          <v-list-tile>\n            {{ \"{{ data.item.text }}\" }} <v-chip small color=\"warning\" v-if=\"data.item.group === 'draft'\">\n              draft </v-chip>\n          </v-list-tile>\n        </v-list-tile>\n      </template>\n    </v-autocomplete>\n  </div>\n</template>\n\n<script>\nimport { AdminClient } from \"@/services/service_admin_pb_service.js\";\nimport { LookupRequest } from \"@/services/service_admin_pb.js\";\n\nlet cli = new AdminClient(\"/api\");\n\nexport default {\n  data() {\n    return {\n      options: [],\n      selection: this.multiple ? [] : \"\",\n      loadingStatus: false\n    };\n  },\n  props: [\"rpc\", \"multiple\"],\n  created() {\n    this.options = this.$attrs.options;\n    this.setSelection();\n  },\n  mounted() {\n    if (this.rpc != null) {\n      this.lookup();\n    }\n  },\n  methods: {\n    updateParent() {\n      this.$emit(\"gocipe\", this.selection);\n    },\n    setSelection() {\n      let typeOfValue = typeof this.$attrs.value;\n      if (typeOfValue != \"undefined\" && typeOfValue == \"object\") {\n        this.selection = this.multiple\n          ? this.$attrs.value.map(item => item.getId())\n          : this.$attrs.value.getId();\n      } else if (typeOfValue == \"string\" && this.$attrs.value.length == 36) {\n        this.selection = this.$attrs.value;\n      }\n    },\n    lookup() {\n      if (this.rpc == null || this.rpc == \"lookup\") {\n        return;\n      }\n\n      let req = new LookupRequest();\n      req.setTerm(this.text);\n      this.loadingStatus = true;\n      \n      cli[this.rpc](req, (err, resp) => {\n        this.loadingStatus = false;\n        if (err) {\n          console.log(err);\n          return;\n        }\n\n        this.options = resp.getResultList().map(result => {\n          return {\n            value: result.getId(),\n            text: result.getLabel(),\n            group: result.getStatus()\n\n          };\n        });\n\n        this.setSelection();\n      });\n    },\n    remove(item) {\n      if (!this.multiple) {\n        this.selection = null;\n        return;\n      }\n      \n      const index = this.selection.indexOf(item.value);\n      if (index >= 0) this.selection.splice(index, 1);\n    }\n  },\n  watch: {\n    rpc: function(n, o) {\n      if (n != null) {\n        this.lookup();\n      }\n    }\n  },\n  inheritAttrs: false\n};\n</script>\n"),
	}
	file1u := &embedded.EmbeddedFile{
		Filename:    "vuetify/widgets/edit/Status.vue.tmpl",
		FileModTime: time.Unix(1538482115, 0),
		Content:     string("<template>\n  <div>\n    <v-slider class=\"py-3\" :label=\"$attrs.label\" v-model=\"statusValue\" :value=\"valueTranslation(textValue)\"\n      @change=\"onChange\" :tick-labels=\"stages.labels\" :thumb-size=\"30\" thumb-label=\"always\"\n      :color=\"thumbColor\" :track-color=\"thumbColor\" :thumb-color=\"thumbColor\"\n      :max=\"3\" :step=\"1\" :validate-on-blur=\"true\" :prepend-icon=\"thumbLabel\"\n      :always-dirty=\"true\" ticks=\"always\" tick-size=\"5\">\n      <template slot=\"thumb-label\" slot-scope=\"props\">\n        <v-icon flat>{{ \"{{ thumbLabel }}\" }}</v-icon>\n      </template>\n    </v-slider>\n\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      statusValue: \"\",\n      textValue: \"\",\n      stages: {\n        labels: [\"Unpublished\", \"Draft\", \"Saved\", \"Published\"],\n        icon: [\"visibility_off\", \"rowing\", \"bookmark\", \"check_circle\"],\n        colors: [\"error\", \"warning\", \"info\", \"success\"]\n      }\n    };\n  },\n  computed: {\n    thumbColor: function() {\n      // console.log(this.statusValue);\n      if (typeof this.statusValue === \"NaN\") {\n        return \"warning\";\n      }\n      return this.stages.colors[this.statusValue];\n    },\n    thumbLabel: function() {\n      return this.stages.icon[this.statusValue];\n    }\n  },\n  methods: {\n    onChange() {\n      this.statusText = this.textTranslation(this.statusValue);\n      console.log(this.statusText);\n      console.log(this.statusValue);\n      this.$emit(\"gocipe\", this.statusText);\n    },\n    textTranslation(val) {\n      switch (val) {\n        case 1:\n          return \"draft\";\n        case 2:\n          return \"saved\";\n        case 3:\n          return \"published\";\n        case 0:\n          return \"unpublished\";\n      }\n    },\n    valueTranslation(val) {\n      switch (val) {\n        case \"draft\":\n          return 1;\n        case \"saved\":\n          return 2;\n        case \"published\":\n          return 3;\n        case \"unpublished\":\n          return 0;\n      }\n    }\n  },\n  created() {\n    this.textValue = this.$attrs.value;\n    this.statusValue = this.valueTranslation(this.textValue);\n    // console.log(this.textValue);\n  },\n  mounted() {},\n  inheritAttrs: false\n};\n</script>\n"),
	}
	file1v := &embedded.EmbeddedFile{
		Filename:    "vuetify/widgets/edit/Textarea.vue.tmpl",
		FileModTime: time.Unix(1538482115, 0),
		Content:     string("<template>\n  <div>\n    <div class=\"caption v-label v-label--active theme--light pb-2\">{{ \"{{ $attrs.label }}\" }}</div>\n\n    <vue-editor id=\"$attrs.label\" v-model=\"text\" :editorToolbar=\"customToolbar\"></vue-editor>\n\n  </div>\n</template>\n\n<script>\nimport { VueEditor } from \"vue2-editor\";\n\nexport default {\n  data() {\n    return {\n      text: \"\",\n      customToolbar: [\n        [\"bold\", \"italic\", \"underline\"],\n        [\"link\", \"blockquote\"],\n        [{ list: \"ordered\" }, { list: \"bullet\" }],\n        [{ header: [1, 2, 3, false] }]\n      ]\n    };\n  },\n  created() {\n    this.text = this.$attrs.value;\n  },\n  components: {\n    VueEditor\n  },\n  watch: {\n    text: function(n, o) {\n      this.$emit(\"gocipe\", n);\n    }\n  },\n  inheritAttrs: false\n};\n</script>\n"),
	}
	file1w := &embedded.EmbeddedFile{
		Filename:    "vuetify/widgets/edit/Textfield.vue.tmpl",
		FileModTime: time.Unix(1538482115, 0),
		Content:     string("<template>\n    <div>\n        <v-text-field :hint=\"$attrs.hint\" :label=\"$attrs.label\" v-model=\"text\" @change=\"$emit('gocipe',text)\"></v-text-field>\n\n    </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      text: \"\"\n    };\n  },\n  created() {\n    this.text = this.$attrs.value;\n  },\n  inheritAttrs: false\n};\n</script>\n"),
	}
	file1x := &embedded.EmbeddedFile{
		Filename:    "vuetify/widgets/edit/Time.vue.tmpl",
		FileModTime: time.Unix(1538482115, 0),
		Content:     string("<template>\n  <div>\n    <v-text-field :label=\"$attrs.label\" append-icon=\"timer\" v-model=\"displayTime\" @click:append=\"openDatePicker\" :placeholder=\"$attrs.label\"></v-text-field>\n    <div class=\"hidden-date\">\n      <datetime type=\"datetime\" ref=\"datepicker\" class=\"date-time-wrapper\" @input=\"update\" v-model=\"time\" :placeholder=\"$attrs.label\" required></datetime>\n    </div>\n  </div>\n</template>\n\n<script>\nimport * as google_protobuf_timestamp_pb from \"google-protobuf/google/protobuf/timestamp_pb\";\nimport moment from 'moment';\n\nexport default {\n  data() {\n    return {\n      time: new Date().getTime().toString()\n    };\n  },\n  computed: {\n    displayTime() {\n      let time = this.time;\n      return new Date(time).toLocaleString();\n    }\n  },\n  mounted() {\n    let minDate = '1970-01-01T00:00:00.000Z'\n    let dateToday = moment().format(\"YYYY-MM-DDTHH:mm:ss.SSS\");\n    this.time = new Date(this.$attrs.value.toDate()).toISOString();\n    if ((this.time !== null) && (this.time === minDate)) {\n      this.time = dateToday;\n    }\n    /// converting the date from 'milliseconds' to this format : 2018-07-28T00:00:00.000Z\n    console.log(\"setting time to : \", this.time);\n    this.update();\n  },\n  methods: {\n    update() {\n      // if (!this.time.length === 0) {\n      let protoDate = new google_protobuf_timestamp_pb.Timestamp();\n      console.log(\"emiting..\");\n      console.log(this.time.length);\n      let correct_time = new Date(this.time);\n\n      protoDate.fromDate(new Date(this.time));\n      this.$emit(\"gocipe\", protoDate);\n      console.log(\"sending this\");\n      console.log(protoDate);\n      // }s\n    },\n    openDatePicker() {\n      this.$refs[\"datepicker\"].$el.firstChild.click();\n    }\n  },\n  inheritAttrs: false\n};\n</script>\n"),
	}
	file1y := &embedded.EmbeddedFile{
		Filename:    "vuetify/widgets/edit/Toggle.vue.tmpl",
		FileModTime: time.Unix(1538482115, 0),
		Content:     string("<template>\n  <div>\n    <div class=\"caption v-label v-label--active theme--light pt-3 pb-0\">{{ \"{{ $attrs.label }}\" }}</div>\n\n    <v-checkbox v-bind=\"$attrs\" :value=\"$attrs.value\" @change=\"$emit('gocipe', result)\" v-model=\"result\"></v-checkbox>\n\n  </div>\n</template>\n\n\n<script>\nexport default {\n  data() {\n    return {\n      result: \"\"\n    };\n  },\n  created() {\n    this.result = this.$attrs.value;\n  },\n  inheritAttrs: false\n};\n</script>"),
	}
	file20 := &embedded.EmbeddedFile{
		Filename:    "vuetify/widgets/list/Select.vue.tmpl",
		FileModTime: time.Unix(1538482115, 0),
		Content:     string("<template>\n  <v-chip :color=\"statusText.color\" text-color=\"white\">\n    <v-avatar>\n      <v-icon>{{ \"{{ statusText.icon }}\" }}</v-icon>\n    </v-avatar>\n    {{ \"{{ statusText.label }}\" }}\n  </v-chip>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      status: \"\",\n      field: \"\",\n      definitions: {\n        Status: {\n          published: {\n            label: \"Published\",\n            icon: \"check_circle\",\n            color: \"success\"\n          },\n          saved: {\n            label: \"Saved\",\n            icon: \"bookmark\",\n            color: \"info\"\n          },\n          draft: {\n            label: \"Draft\",\n            icon: \"rowing\",\n            color: \"warning\"\n          },\n          unpublished: {\n            label: \"Unpublished\",\n            icon: \"visibility_off\",\n            color: \"error\"\n          },\n          other: {\n            label: \"undefined\",\n            icon: \"dashboard\",\n            color: \"info\"\n          }\n        },\n        BannerType: {\n          I: {\n            icon: \"view_day\",\n            color: \"info\",\n            label: \"Intersection Ad\"\n          },\n          H: {\n            icon: \"view_carousel\",\n            color: \"info\",\n            label: \"Hero Banner\"\n          }\n        },\n        AdsType: {\n          I: {\n            icon: \"view_day\",\n            color: \"info\",\n            label: \"Intersection Ad\"\n          },\n          H: {\n            icon: \"view_carousel\",\n            color: \"info\",\n            label: \"Hero Banner\"\n          }\n        },\n        EntityType: {\n          Banners: {\n            icon: \"view_carousel\",\n            color: \"info\",\n            label: \"Banners\"\n          },\n          Settings: {\n            icon: \"settings\",\n            color: \"info\",\n            label: \"Settings\"\n          },\n          Event: {\n            icon: \"event\",\n            color: \"info\",\n            label: \"Events\"\n          },\n          EventTypes: {\n            icon: \"local_offer\",\n            color: \"info\",\n            label: \"EventTypes\"\n          },\n          Venues: {\n            icon: \"place\",\n            color: \"info\",\n            label: \"Venues\"\n          },\n          Recipe: {\n            icon: \"restaurant\",\n            color: \"info\",\n            label: \"Recipes\"\n          },\n          VenueTypes: {\n            icon: \"map\",\n            color: \"info\",\n            label: \"VenueTypes\"\n          },\n          Showtimes: {\n            icon: \"movie_filter\",\n            color: \"info\",\n            label: \"Showtimes\"\n          },\n          RecipeInstructions: {\n            icon: \"list\",\n            color: \"info\",\n            label: \"RecipeInstructions\"\n          },\n          Products: {\n            icon: \"shopping_basket\",\n            color: \"info\",\n            label: \"Products\"\n          },\n          Towns: {\n            icon: \"location_city\",\n            color: \"info\",\n            label: \"Towns\"\n          },\n          Movie: {\n            icon: \"movie\",\n            color: \"info\",\n            label: \"Movies\"\n          },\n          Genres: {\n            icon: \"movie_filter\",\n            color: \"info\",\n            label: \"Genres\"\n          },\n          Sponsors: {\n            icon: \"attach_money\",\n            color: \"info\",\n            label: \"Sponsors\"\n          },\n          EventTopics: {\n            icon: \"tag\",\n            color: \"info\",\n            label: \"EventTopics\"\n          },\n          VenueGalleries: {\n            icon: \"gallery\",\n            color: \"info\",\n            label: \"VenueGalleries\"\n          },\n          Ads: {\n            icon: \"spa\",\n            color: \"info\",\n            label: \"Ads\"\n          }\n        }\n      }\n    };\n  },\n  created() {\n    this.status = this.$attrs.status.trim();\n    this.field = this.$attrs.field.trim();\n  },\n  computed: {\n    statusText() {\n      // Lots of error checking\n      // Will return a sad face if definition not found\n      let field = this.definitions[this.field];\n      if (typeof field === \"undefined\") {\n        console.log(\n          `The definition of the list widget \"${this.field}\" was not found`\n        );\n        return {\n          label: \"¯\\\\_(ツ)_/¯\",\n          icon: \"sentiment_very_dissatisfied\",\n          color: \"grey\"\n        };\n      } else {\n        let fieldtype = this.definitions[this.field][this.status];\n        if (typeof fieldtype === \"undefined\") {\n          console.log(\n            `The definition of the type \"${\n              this.status\n            }\" was not found for the list widget \"${this.field}\"`\n          );\n          return {\n            label: \"¯\\\\_(ツ)_/¯\",\n            icon: \"sentiment_very_dissatisfied\",\n            color: \"info\"\n          };\n        } else {\n          return fieldtype;\n        }\n      }\n    }\n  }\n};\n</script>\n"),
	}
	file21 := &embedded.EmbeddedFile{
		Filename:    "vuetify/widgets/list/Time.vue.tmpl",
		FileModTime: time.Unix(1538482115, 0),
		Content:     string("<template>\n  <div>\n    <v-tooltip top v-if=\"one\">\n      <timeago slot=\"activator\" locale=\"fr-FR\" :datetime=\"date\"></timeago>\n      <span>{{ \"{{ date.toLocaleDateString() }} {{ date.toLocaleTimeString() }}\" }}</span>\n    </v-tooltip>\n    <span v-else>{{ \"{{ date.toLocaleDateString() }} {{ date.toLocaleTimeString() }}\" }}</span>\n  </div>\n</template>\n\n<script>\nexport default {\n  inheritAttrs: false,\n  data() {\n    return {\n      date: new Date()\n    };\n  },\n  created() {\n    this.date = this.$attrs.time;\n  },\n  computed: {\n    one() {\n      const oneDay = 2 * 24 * 60 * 60 * 1000;\n      const today = new Date().getTime();\n      const check = new Date(this.date).getTime();\n\n      const difference = Math.abs(check - today);\n\n      if (difference < oneDay) {\n        return true;\n      }\n      return false;\n    }\n  }\n};\n</script>\n"),
	}
	file22 := &embedded.EmbeddedFile{
		Filename:    "vuetify/widgets/list/Toggle.vue.tmpl",
		FileModTime: time.Unix(1538482115, 0),
		Content:     string("<template>\n    <div>\n        <v-icon v-if=\"$attrs.value\">check_box</v-icon>\n        <v-icon v-else>check_box_outline_blank</v-icon>\n        <!-- <span v-else>--</span> -->\n    </div>\n</template>\n"),
	}

	// define dirs
	dir1 := &embedded.EmbeddedDir{
		Filename:   "",
		DirModTime: time.Unix(1539936852, 0),
		ChildFiles: []*embedded.EmbeddedFile{},
	}
	dir2 := &embedded.EmbeddedDir{
		Filename:   "admin",
		DirModTime: time.Unix(1539936852, 0),
		ChildFiles: []*embedded.EmbeddedFile{
			file3, // "admin/admin_config_upload.go.tmpl"
			file4, // "admin/admin_helpers.go.tmpl"
			file5, // "admin/admin_permissions.go.tmpl"
			file6, // "admin/service_admin.go.tmpl"
			file7, // "admin/service_admin.proto.tmpl"
			file8, // "admin/service_admin_hooks.go.tmpl"

		},
	}
	dir9 := &embedded.EmbeddedDir{
		Filename:   "application",
		DirModTime: time.Unix(1539936852, 0),
		ChildFiles: []*embedded.EmbeddedFile{
			filea, // "application/gen-service.sh.tmpl"
			fileb, // "application/main.go.tmpl"
			filec, // "application/makefile.tmpl"
			filed, // "application/route.go.tmpl"

		},
	}
	dire := &embedded.EmbeddedDir{
		Filename:   "auth",
		DirModTime: time.Unix(1539861136, 0),
		ChildFiles: []*embedded.EmbeddedFile{
			filef, // "auth/auth.go.tmpl"

		},
	}
	dirg := &embedded.EmbeddedDir{
		Filename:   "bootstrap",
		DirModTime: time.Unix(1538482115, 0),
		ChildFiles: []*embedded.EmbeddedFile{
			fileh, // "bootstrap/bootstrap.go.tmpl"
			filei, // "bootstrap/env.tmpl"

		},
	}
	dirj := &embedded.EmbeddedDir{
		Filename:   "crud",
		DirModTime: time.Unix(1539936852, 0),
		ChildFiles: []*embedded.EmbeddedFile{
			filek, // "crud/crud.go.tmpl"
			filel, // "crud/hooks.go.tmpl"
			filem, // "crud/models.go.tmpl"
			filen, // "crud/models.proto.tmpl"
			fileo, // "crud/moderrors.go.tmpl"

		},
	}
	dirp := &embedded.EmbeddedDir{
		Filename:   "schema",
		DirModTime: time.Unix(1539936852, 0),
		ChildFiles: []*embedded.EmbeddedFile{
			fileq, // "schema/schema.sql.tmpl"

		},
	}
	dirr := &embedded.EmbeddedDir{
		Filename:   "util",
		DirModTime: time.Unix(1539936852, 0),
		ChildFiles: []*embedded.EmbeddedFile{
			files, // "util/credentials.go.tmpl"
			filet, // "util/files.go.tmpl"
			fileu, // "util/imagist.go.tmpl"
			filev, // "util/rice.go.tmpl"
			filew, // "util/util.go.tmpl"
			filex, // "util/web.go.tmpl"
			filey, // "util/ws.go.tmpl"

		},
	}
	dirz := &embedded.EmbeddedDir{
		Filename:   "vuetify",
		DirModTime: time.Unix(1539586325, 0),
		ChildFiles: []*embedded.EmbeddedFile{},
	}
	dir10 := &embedded.EmbeddedDir{
		Filename:   "vuetify/forms",
		DirModTime: time.Unix(1539936852, 0),
		ChildFiles: []*embedded.EmbeddedFile{
			file11, // "vuetify/forms/edit.vue.tmpl"
			file12, // "vuetify/forms/list.vue.tmpl"

		},
	}
	dir13 := &embedded.EmbeddedDir{
		Filename:   "vuetify/js",
		DirModTime: time.Unix(1539586325, 0),
		ChildFiles: []*embedded.EmbeddedFile{
			file14, // "vuetify/js/actions.js.tmpl"
			file15, // "vuetify/js/components-registration.js.tmpl"
			file16, // "vuetify/js/getters.js.tmpl"
			file17, // "vuetify/js/index.js.tmpl"
			file18, // "vuetify/js/mutations.js.tmpl"
			file19, // "vuetify/js/routes.js.tmpl"
			file1a, // "vuetify/js/types.js.tmpl"

		},
	}
	dir1b := &embedded.EmbeddedDir{
		Filename:   "vuetify/old",
		DirModTime: time.Unix(1538482115, 0),
		ChildFiles: []*embedded.EmbeddedFile{
			file1c, // "vuetify/old/vuetify_edit.vue.tmpl"
			file1d, // "vuetify/old/vuetify_editor-field-checkbox.vue.tmpl"
			file1e, // "vuetify/old/vuetify_editor-field-date.vue.tmpl"
			file1f, // "vuetify/old/vuetify_editor-field-number.vue.tmpl"
			file1g, // "vuetify/old/vuetify_editor-field-password.vue.tmpl"
			file1h, // "vuetify/old/vuetify_editor-field-select-rel.vue.tmpl"
			file1i, // "vuetify/old/vuetify_editor-field-select.vue.tmpl"
			file1j, // "vuetify/old/vuetify_editor-field-textarea.vue.tmpl"
			file1k, // "vuetify/old/vuetify_editor-field-textfield.vue.tmpl"
			file1l, // "vuetify/old/vuetify_editor-field-time.vue.tmpl"
			file1m, // "vuetify/old/vuetify_editor-field-toggle.vue.tmpl"

		},
	}
	dir1n := &embedded.EmbeddedDir{
		Filename:   "vuetify/widgets",
		DirModTime: time.Unix(1538482115, 0),
		ChildFiles: []*embedded.EmbeddedFile{},
	}
	dir1o := &embedded.EmbeddedDir{
		Filename:   "vuetify/widgets/edit",
		DirModTime: time.Unix(1539936849, 0),
		ChildFiles: []*embedded.EmbeddedFile{
			file1p, // "vuetify/widgets/edit/Icon.vue.tmpl"
			file1q, // "vuetify/widgets/edit/Imagefield.vue.tmpl"
			file1r, // "vuetify/widgets/edit/Map.vue.tmpl"
			file1s, // "vuetify/widgets/edit/Select.vue.tmpl"
			file1t, // "vuetify/widgets/edit/SelectRel.vue.tmpl"
			file1u, // "vuetify/widgets/edit/Status.vue.tmpl"
			file1v, // "vuetify/widgets/edit/Textarea.vue.tmpl"
			file1w, // "vuetify/widgets/edit/Textfield.vue.tmpl"
			file1x, // "vuetify/widgets/edit/Time.vue.tmpl"
			file1y, // "vuetify/widgets/edit/Toggle.vue.tmpl"

		},
	}
	dir1z := &embedded.EmbeddedDir{
		Filename:   "vuetify/widgets/list",
		DirModTime: time.Unix(1538482115, 0),
		ChildFiles: []*embedded.EmbeddedFile{
			file20, // "vuetify/widgets/list/Select.vue.tmpl"
			file21, // "vuetify/widgets/list/Time.vue.tmpl"
			file22, // "vuetify/widgets/list/Toggle.vue.tmpl"

		},
	}

	// link ChildDirs
	dir1.ChildDirs = []*embedded.EmbeddedDir{
		dir2, // "admin"
		dir9, // "application"
		dire, // "auth"
		dirg, // "bootstrap"
		dirj, // "crud"
		dirp, // "schema"
		dirr, // "util"
		dirz, // "vuetify"

	}
	dir2.ChildDirs = []*embedded.EmbeddedDir{}
	dir9.ChildDirs = []*embedded.EmbeddedDir{}
	dire.ChildDirs = []*embedded.EmbeddedDir{}
	dirg.ChildDirs = []*embedded.EmbeddedDir{}
	dirj.ChildDirs = []*embedded.EmbeddedDir{}
	dirp.ChildDirs = []*embedded.EmbeddedDir{}
	dirr.ChildDirs = []*embedded.EmbeddedDir{}
	dirz.ChildDirs = []*embedded.EmbeddedDir{
		dir10, // "vuetify/forms"
		dir13, // "vuetify/js"
		dir1b, // "vuetify/old"
		dir1n, // "vuetify/widgets"

	}
	dir10.ChildDirs = []*embedded.EmbeddedDir{}
	dir13.ChildDirs = []*embedded.EmbeddedDir{}
	dir1b.ChildDirs = []*embedded.EmbeddedDir{}
	dir1n.ChildDirs = []*embedded.EmbeddedDir{
		dir1o, // "vuetify/widgets/edit"
		dir1z, // "vuetify/widgets/list"

	}
	dir1o.ChildDirs = []*embedded.EmbeddedDir{}
	dir1z.ChildDirs = []*embedded.EmbeddedDir{}

	// register embeddedBox
	embedded.RegisterEmbeddedBox(`templates`, &embedded.EmbeddedBox{
		Name: `templates`,
		Time: time.Unix(1539936852, 0),
		Dirs: map[string]*embedded.EmbeddedDir{
			"":                     dir1,
			"admin":                dir2,
			"application":          dir9,
			"auth":                 dire,
			"bootstrap":            dirg,
			"crud":                 dirj,
			"schema":               dirp,
			"util":                 dirr,
			"vuetify":              dirz,
			"vuetify/forms":        dir10,
			"vuetify/js":           dir13,
			"vuetify/old":          dir1b,
			"vuetify/widgets":      dir1n,
			"vuetify/widgets/edit": dir1o,
			"vuetify/widgets/list": dir1z,
		},
		Files: map[string]*embedded.EmbeddedFile{
			"admin/admin_config_upload.go.tmpl":                    file3,
			"admin/admin_helpers.go.tmpl":                          file4,
			"admin/admin_permissions.go.tmpl":                      file5,
			"admin/service_admin.go.tmpl":                          file6,
			"admin/service_admin.proto.tmpl":                       file7,
			"admin/service_admin_hooks.go.tmpl":                    file8,
			"application/gen-service.sh.tmpl":                      filea,
			"application/main.go.tmpl":                             fileb,
			"application/makefile.tmpl":                            filec,
			"application/route.go.tmpl":                            filed,
			"auth/auth.go.tmpl":                                    filef,
			"bootstrap/bootstrap.go.tmpl":                          fileh,
			"bootstrap/env.tmpl":                                   filei,
			"crud/crud.go.tmpl":                                    filek,
			"crud/hooks.go.tmpl":                                   filel,
			"crud/models.go.tmpl":                                  filem,
			"crud/models.proto.tmpl":                               filen,
			"crud/moderrors.go.tmpl":                               fileo,
			"schema/schema.sql.tmpl":                               fileq,
			"util/credentials.go.tmpl":                             files,
			"util/files.go.tmpl":                                   filet,
			"util/imagist.go.tmpl":                                 fileu,
			"util/rice.go.tmpl":                                    filev,
			"util/util.go.tmpl":                                    filew,
			"util/web.go.tmpl":                                     filex,
			"util/ws.go.tmpl":                                      filey,
			"vuetify/forms/edit.vue.tmpl":                          file11,
			"vuetify/forms/list.vue.tmpl":                          file12,
			"vuetify/js/actions.js.tmpl":                           file14,
			"vuetify/js/components-registration.js.tmpl":           file15,
			"vuetify/js/getters.js.tmpl":                           file16,
			"vuetify/js/index.js.tmpl":                             file17,
			"vuetify/js/mutations.js.tmpl":                         file18,
			"vuetify/js/routes.js.tmpl":                            file19,
			"vuetify/js/types.js.tmpl":                             file1a,
			"vuetify/old/vuetify_edit.vue.tmpl":                    file1c,
			"vuetify/old/vuetify_editor-field-checkbox.vue.tmpl":   file1d,
			"vuetify/old/vuetify_editor-field-date.vue.tmpl":       file1e,
			"vuetify/old/vuetify_editor-field-number.vue.tmpl":     file1f,
			"vuetify/old/vuetify_editor-field-password.vue.tmpl":   file1g,
			"vuetify/old/vuetify_editor-field-select-rel.vue.tmpl": file1h,
			"vuetify/old/vuetify_editor-field-select.vue.tmpl":     file1i,
			"vuetify/old/vuetify_editor-field-textarea.vue.tmpl":   file1j,
			"vuetify/old/vuetify_editor-field-textfield.vue.tmpl":  file1k,
			"vuetify/old/vuetify_editor-field-time.vue.tmpl":       file1l,
			"vuetify/old/vuetify_editor-field-toggle.vue.tmpl":     file1m,
			"vuetify/widgets/edit/Icon.vue.tmpl":                   file1p,
			"vuetify/widgets/edit/Imagefield.vue.tmpl":             file1q,
			"vuetify/widgets/edit/Map.vue.tmpl":                    file1r,
			"vuetify/widgets/edit/Select.vue.tmpl":                 file1s,
			"vuetify/widgets/edit/SelectRel.vue.tmpl":              file1t,
			"vuetify/widgets/edit/Status.vue.tmpl":                 file1u,
			"vuetify/widgets/edit/Textarea.vue.tmpl":               file1v,
			"vuetify/widgets/edit/Textfield.vue.tmpl":              file1w,
			"vuetify/widgets/edit/Time.vue.tmpl":                   file1x,
			"vuetify/widgets/edit/Toggle.vue.tmpl":                 file1y,
			"vuetify/widgets/list/Select.vue.tmpl":                 file20,
			"vuetify/widgets/list/Time.vue.tmpl":                   file21,
			"vuetify/widgets/list/Toggle.vue.tmpl":                 file22,
		},
	})
}
