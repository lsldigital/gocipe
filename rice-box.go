package main

import (
	"github.com/GeertJohan/go.rice/embedded"
	"time"
)

func init() {

	// define files
	file3 := &embedded.EmbeddedFile{
		Filename:    "application/gen-service.sh.tmpl",
		FileModTime: time.Unix(1532880081, 0),
		Content:     string("#!/bin/bash\n\nCURRENT_DIR=`pwd`\nWEB_DIR=\"${CURRENT_DIR}/web\"\nLOG_FILE=\"${CURRENT_DIR}/gen-service.log\"\n\n# Function gets an array of services as arguments (e.g. \"wire\" in \"service_wire.proto\")\ngenerate_files() {\n    # For each sub-folder in \"web\"\n    for d in ${WEB_DIR}/*/; do\n        echo -e \"# ${d}\\n\"\n        if [ ! -f \"${d}package.json\" ]; then\n            echo \"- npm init: package.json file was not found\"\n            cd \"${d}\"\n            npm init --quiet --yes >> $LOG_FILE\n        fi\n\n        if [ ! -d \"${d}node_modules/\" ]; then\n            echo \"- npm init: node_modules dir was not found\"\n            cd \"${d}\"\n            npm init --quiet --yes >> $LOG_FILE\n        fi\n\n        if [ ! -d \"${d}node_modules/.bin\" ]; then\n            echo \"- npm init: .bin dir was not found\"\n            cd \"${d}\"\n            npm init --quiet --yes >> $LOG_FILE\n        fi\n\n        if [ ! -d \"${d}node_modules/@types/google-protobuf\" ]; then\n            echo \"- npm install --save @types/google-protobuf: protobuf was not found\"\n            cd \"${d}\"\n            npm npm install --quiet --save @types/google-protobuf >> $LOG_FILE\n        fi\n\n        if [ ! -f \"${d}node_modules/.bin/protoc-gen-ts\" ]; then\n            echo \"- npm install --save-dev ts-protoc-gen: protoc-gen-ts executable was not found\"\n            cd \"${d}\"\n            npm install --quiet --save-dev ts-protoc-gen >> $LOG_FILE\n        fi\n\n        if [ ! -d \"${d}dist\" ]; then\n            echo \"- creating ${d}dist: dist dir was not found\"\n            mkdir -p \"${d}dist\"\n            echo \"\" > \"${d}dist/.gitkeep\"\n        fi\n\n        if [ ! -d \"${d}src/services\" ]; then\n            echo \"- creating ${d}src/services: src/services dir was not found\"\n            mkdir -p \"${d}src/services\"\n        fi\n\n        if [ -f \"${CURRENT_DIR}/proto/models.proto\" ]; then\n            echo \"- generating JS services for models\"\n            protoc -I=\"${CURRENT_DIR}/proto\" \\\n                \"${CURRENT_DIR}/proto/models.proto\" \\\n                --plugin=\"protoc-gen-ts=${d}node_modules/.bin/protoc-gen-ts\" \\\n                --js_out=\"import_style=commonjs,binary:${d}src/services\" \\\n                --ts_out=\"${d}src/services\"\n        fi\n\n        # For each proto file (the argument)\n        for f in $@; do\n            if [ -f \"${CURRENT_DIR}/proto/service_${f}.proto\" ]; then\n                echo \"- generating JS services for ${f}\"\n                protoc -I=\"${CURRENT_DIR}/proto\" \\\n                    \"${CURRENT_DIR}/proto/service_${f}.proto\" \\\n                    --plugin=\"protoc-gen-ts=${d}node_modules/.bin/protoc-gen-ts\" \\\n                    --js_out=\"import_style=commonjs,binary:${d}src/services\" \\\n                    --ts_out=\"service=true:${d}src/services\"\n            fi\n        done\n\n        echo -e \":: done\\n\"\n    done\n\n    # proto/models.proto goes in \"models\" folder\n    protoc -I=\"${CURRENT_DIR}/proto\" \\\n        \"${CURRENT_DIR}/proto/models.proto\" \\\n        --go_out=plugins=grpc:${GOPATH}/src\n\n    # For each service proto file (the argument)\n    for f in $@; do\n        if [ -f \"${CURRENT_DIR}/proto/service_${f}.proto\" ]; then\n            echo \"# Generating GO services for ${f}\"\n            if [ ! -d \"${CURRENT_DIR}/services/${f}\" ]; then\n                mkdir -p \"${CURRENT_DIR}/services/${f}\"\n            fi\n            protoc -I=\"${CURRENT_DIR}/proto\" \\\n                \"${CURRENT_DIR}/proto/service_${f}.proto\" \\\n                --go_out=plugins=grpc:${GOPATH}/src\n        fi\n    done\n\n    echo -e \"\\n::Done and dusted :-)\\n\"\n}\n\n# -- MAIN SCRIPT STARTS HERE --\n\ncd ${CURRENT_DIR}\n\ndt=$(date '+%d/%m/%Y %H:%M:%S');\necho -e \"# Gen-service: ${dt}\\n\\n\" > \"${LOG_FILE}\"\n\nif [ ! -d \"${CURRENT_DIR}/vendor\" ]; then\n    echo -e \"# Dep init: Vendor folder not found.\\n\"\n    dep init >> $LOG_FILE\nfi\n\nHELP=false\nALL=false\ndeclare -a SERVICES=() # an array\n\nwhile true; do\n  case $1 in\n    -h | --help )\n        HELP=true;\n        shift;\n        ;;\n\n    -a | --all )\n        ALL=true;\n        shift;\n        ;;\n\n    -s | --services )\n        shift;\n        SERVICES=\"${@}\"\n        ;;\n\n    -- )\n        shift;\n        break\n        ;;\n\n    *  )\n        break\n        ;;\n  esac\ndone\n\n# Process all service_*.proto files in proto/ folder\nif [ \"${ALL}\" == true ]; then\n    index=0\n    for f in `find ${CURRENT_DIR}/proto/ -type f -iname \"service_*.proto\" | awk -F \"service_\" '{print $2}' | awk -F \".proto\" '{print $1}'`; do\n        SERVICES[$index]=\"${f}\"\n        index=$(($index+1))\n    done\n    generate_files ${SERVICES[@]}\n    exit 0\nfi\n\n# Process individual service_*.proto files in proto/ folder\nif [[ ${SERVICES[@]} ]]; then\n    generate_files ${SERVICES[@]}\n    exit 0\nfi\n\n# Display help\necho \"Generation of services. Usage:\"\necho \"\"\necho \" $ ./gen-service.sh -h|--help\"\necho \"   Displays this help\"\necho \"\"\necho \" $ ./gen-service.sh -a|--all\"\necho \"   Will process all service_*.proto files in 'proto' folder\"\necho \"\"\necho \" $ ./gen-service.sh -s|--services service1 service2 ... serviceN\"\necho \"   Will process individual service_*.proto files in 'proto' folder (as provided in the arguments)\"\necho \"\"\nexit 0;\n"),
	}
	file4 := &embedded.EmbeddedFile{
		Filename:    "application/main.go.tmpl",
		FileModTime: time.Unix(1534232918, 0),
		Content:     string("package main\n\nimport (\n\t\"net/http\"\n\n\trice \"github.com/GeertJohan/go.rice\"\n\t\"github.com/gorilla/mux\"\n\t\"github.com/improbable-eng/grpc-web/go/grpcweb\"\n\t\"google.golang.org/grpc\"\n\tlog \"github.com/sirupsen/logrus\"\n)\n\n//go:generate rice embed-go\n\n{{if not .Bootstrap.NoVersion}}\n// Versioning info\nvar (\n\tappVersion = \"n/a\"\n\tappCommit  = \"n/a\"\n\tappBuilt   = \"n/a\"\n)\n{{end}}\n\nfunc main() {\n\t{{- if not .Bootstrap.NoVersion}}\n\tversion := flag.Bool(\"v\", false, \"prints current app version\")\n\tflag.Parse()\n\tif *version {\n\t\tfmt.Printf(\"Version : %v \\nCommit : %v\\nBuilt: %v\\n\", appVersion, appCommit, appBuilt)\n\t\tos.Exit(0)\n\t}\n\t{{end}}\n\n\tconfig := app.Bootstrap()\n\tmodels.Init(config.DB)\n\t\n\t{{if .Bootstrap.Assets}}\n\tapp.Assets = rice.MustFindBox(\"assets\")\n\t{{end}}\n\n\t{{if not .Bootstrap.NoGRPCWeb}}\n\tg := grpc.NewServer()\n\tws := grpcweb.WrapServer(g)\n\trouter := newProdRouter(ws)\n\t{{else}}\n\trouter := newDevRouter(nil)\n\t{{end}}\n\t\n\t{{if not .Bootstrap.NoGRPCWire}}\n\tgo func() {\n\t\tl, err := net.Listen(\"tcp\", \":\"+config.GRPCPort)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"error starting tcp listener: %v\", err)\n\t\t}\n\t\tdefer l.Close()\n\n\t\tg := grpc.NewServer()\n\t\tif err := g.Serve(l); err != nil {\n\t\t\tlog.Fatalf(\"error serving grpc: %v\", err)\n\t\t}\n\t}()\n\t{{end}}\n\n\tsrv := &http.Server{\n\t\tHandler:      router,\n\t\tAddr:         \":\" + config.HTTPPort,\n\t\tReadTimeout:  5 * time.Second,\n\t\tWriteTimeout: 10 * time.Second,\n\t\tIdleTimeout:  15 * time.Second,\n\t}\n\n\tlog.Println(\"Listening on http://127.0.0.1:\" + config.HTTPPort)\n\tif err := srv.ListenAndServe(); err != nil {\n\t\tlog.Fatalf(\"error starting http server: %v\", err)\n\t}\n}\n"),
	}
	file5 := &embedded.EmbeddedFile{
		Filename:    "application/makefile.tmpl",
		FileModTime: time.Unix(1534420769, 0),
		Content:     string("VERSION     := 1.0.0\nCOMMIT      := `git rev-parse HEAD`\nDATE        := `date +%FT%T%z`\nBUILD_FLAGS := \"-X=main.appVersion=$(VERSION) -X=main.appCommit=$(COMMIT) -X=main.appBuilt=$(DATE)\"\nBUILD_DIR\t:= \"build\"\nAPPNAME\t\t:= \"{{.AppName}}\"\n\n.PHONY: build\n\nbuild:\n\t@echo \"Compiling for DEV...\"\n\t@go clean && go build -ldflags ${BUILD_FLAGS} -o ${BUILD_DIR}/${APPNAME}\n\t@echo \"Build done!\"\n\t@cd ${BUILD_DIR} && ./${BUILD_DIR}/${APPNAME}\n\nprod:\n\t@echo \"Compiling for PROD ...\"\n\t@go clean && go generate && env GOOS=linux GOARCH=amd64 go build -ldflags ${BUILD_FLAGS} -o ${BUILD_DIR}/${APPNAME}\n\t@echo \"Compressing into tar.gz ...\"\n\t@tar -czf ${BUILD_DIR}/${APPNAME}-`date +%FT%T`.tar.gz ${BUILD_DIR}/${APPNAME}\n\t@rm ${BUILD_DIR}/${APPNAME}\n\t@echo \"Build done!\""),
	}
	file6 := &embedded.EmbeddedFile{
		Filename:    "application/route.go.tmpl",
		FileModTime: time.Unix(1534232918, 0),
		Content:     string("package main\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/improbable-eng/grpc-web/go/grpcweb\"\n\tlog \"github.com/sirupsen/logrus\"\n)\n\nfunc newMuxRouter(ws *grpcweb.WrappedGrpcServer) *mux.Router {\n\trouter := mux.NewRouter()\n\n    {{if not .Bootstrap.NoGRPCWeb}}\n\trouter.PathPrefix(\"/api\").Handler(http.StripPrefix(\"/api\", ws))\n    {{end}}\n\n\tif _, err := web.NewSubrouter(router, \"/\", \"app\", nil); err != nil {\n\t\tlogs := log.WithFields(log.Fields{\n\t\t\t\"error\":  err,\n\t\t})\n\t\tif app.Env == app.EnvironmentDev {\n\t\t\tlogs.Warn(\"Could not create sub route\")\n\t\t} else {\n\t\t\tlogs.Fatal(\"Could not create sub route\")\n\t\t}\n\t}\n\n\treturn router\n}\n\nfunc newProdRouter(ws *grpcweb.WrappedGrpcServer) *mux.Router {\n\trouter := mux.NewRouter()\n\t{{if not .Bootstrap.NoGRPCWeb}}\n\tif ws != nil {\n\t\trouter.PathPrefix(\"/api\").Handler(http.StripPrefix(\"/api\", ws))\n\t}\n\t{{end}}\n\n\tif err := web.WebAppRouting(router, \"/\", \"app\", nil); err != nil {\n\t\tlog.Fatalf(\"Failed to create subroute app: %s\\n\", err)\n\t\treturn nil\n\t}\n\n\t{{if .Bread.Generate}}\n\tif err := web.WebAppRouting(router, \"/admin\", \"backoffice\", nil); err != nil {\n\t\tlog.Fatalf(\"Failed to create subroute backoffice: %s\\n\", err)\n\t\treturn nil\n\t}\n\t{{end}}\n\n\treturn router\n}\n\nfunc newDevRouter(ws *grpcweb.WrappedGrpcServer) *mux.Router {\n\trouter := mux.NewRouter()\n\t{{if not .Bootstrap.NoGRPCWeb}}\n\tif ws != nil {\n\t\trouter.PathPrefix(\"/api\").Handler(http.StripPrefix(\"/api\", ws))\n\t}\n\t{{end}}\n\n\tif err := web.WebDevRouting(router, \"/admin\", \"backoffice\", \"8081\"); err != nil {\n\t\tlog.Warnf(\"Failed to create subrouter backofice: %s\\n\", err)\n\t}\n\n\t{{if .Bread.Generate}}\n\tif err := web.WebDevRouting(router, \"/\", \"app\", \"8080\"); err != nil {\n\t\tlog.Warnf(\"Failed to create subrouter app: %s\\n\", err)\n\t}\n\t{{end}}\n\n\treturn router\n}\n"),
	}
	file8 := &embedded.EmbeddedFile{
		Filename:    "bootstrap/bootstrap.go.tmpl",
		FileModTime: time.Unix(1533812553, 0),
		Content:     string("package app\n\nimport (\n\t\"bytes\"\n\t\"database/sql\"\n\t\"log\"\n\t\"os\"\n\n\t\"github.com/joho/godotenv\"\n\trice \"github.com/GeertJohan/go.rice\"\n\t// Load database driver\n\t_ \"github.com/lib/pq\"\n)\n\nconst (\n\t//EnvironmentProd represents production environment\n\tEnvironmentProd = \"PROD\"\n\n\t//EnvironmentDev represents development environment\n\tEnvironmentDev  = \"DEV\"\n)\n\nvar (\n\t// bootstrapped is a flag to prevent multiple bootstrapping\n\tbootstrapped = false\n\n\t// Env indicates in which environment (prod / dev) the application is running\n\tEnv string\n\t{{range .Bootstrap.Settings}}{{if .Public}}\n\t// {{.Name}} {{.Description}}\n\t{{.Name}} string\n\t{{end}}{{end}}\n\t{{if .Bootstrap.Assets}}\n\t// Assets is a rice box to assets directory\n\tAssets *rice.Box\n\t{{end}}\n)\n\n// Config represents application configuration loaded during bootstrap\ntype Config struct {\n\t{{if not .Bootstrap.NoDB}}DB  *sql.DB{{end}}\n\tHTTPPort string\n\t{{if not .Bootstrap.NoGRPCWire}}GRPCPort string{{end}}\n\t{{range .Bootstrap.Settings}}{{if not .Public}}\n\t// {{.Name}} {{.Description}}\n\t{{.Name}} string\n\t{{end}}{{end}}\n}\n\n// Bootstrap loads environment variables and initializes the application\nfunc Bootstrap() *Config {\n\tvar config Config\n\n\tif bootstrapped {\n\t\treturn nil\n\t}\n\n\tgodotenv.Load()\n\n\tEnv = os.Getenv(\"ENV\")\n\tif Env == \"\" {\n\t\tEnv = EnvironmentProd\n\t}\n\n\t{{if not .Bootstrap.NoDB}}\n\tdsn := os.Getenv(\"DSN\")\n\tif dsn == \"\" {\n\t\tlog.Fatal(\"Environment variable DSN must be defined. Example: postgres://user:pass@host/db?sslmode=disable\")\n\t}\n\n\tvar err error\n\tconfig.DB, err = sql.Open(\"postgres\", dsn)\n\tif err == nil {\n\t\tlog.Println(\"Connected to database successfully.\")\n\t} else if (Env == EnvironmentDev) {\n\t\tlog.Println(\"Database connection failed: \", err)\n\t} else {\n\t\tlog.Fatal(\"Database connection failed: \", err)\n\t}\n\n\terr = config.DB.Ping()\n\tif err == nil {\n\t\tlog.Println(\"Pinged database successfully.\")\n\t} else if (Env == EnvironmentDev) {\n\t\tlog.Println(\"Database ping failed: \", err)\n\t} else {\n\t\tlog.Fatal(\"Database ping failed: \", err)\n\t}\n\t{{end}}\n\n\tconfig.HTTPPort = os.Getenv(\"HTTP_PORT\")\n\tif config.HTTPPort == \"\" {\n\t\tconfig.HTTPPort = \"{{.Bootstrap.HTTPPort}}\"\n\t}\n\n\t{{if not .Bootstrap.NoGRPCWire}}\n\tconfig.GRPCPort = os.Getenv(\"GRPC_PORT\")\n\tif config.GRPCPort == \"\" {\n\t\tconfig.GRPCPort = \"{{.Bootstrap.GRPCPort}}\"\n\t}\n\t{{end}}\n\n\t{{range .Bootstrap.Settings}}{{if not .Public}}\n\tconfig.{{.Name}} = os.Getenv(\"{{upper (snake .Name)}}\")\n\tif config.{{.Name}} == \"\" {\n\t\tlog.Fatal(\"Environment variable {{upper (snake .Name)}} ({{.Description}}) must be defined.\")\n\t}\n\t{{end}}{{end}}\n\n\t{{range .Bootstrap.Settings}}{{if .Public}}\n\t{{.Name}} = os.Getenv(\"{{upper (snake .Name)}}\")\n\tif {{.Name}} == \"\" {\n\t\tlog.Fatal(\"Environment variable {{upper (snake .Name)}} ({{.Description}}) must be defined.\")\n\t}\n\t{{end}}{{end}}\n\n\tos.Clearenv() //prevent non-authorized access\n\n\treturn &config\n}\n\n\n{{if .Bootstrap.Assets}}\n// ExecuteTemplate applies templating a text/template template given data and returns the string output\nfunc ExecuteTemplate(name string, data interface{}) (string, error) {\n\tvar output bytes.Buffer\n\n\traw, err := Assets.String(\"templates/\"+name)\n\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\ttpl, err := template.New(name).Funcs(template.FuncMap{}).Parse(raw)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\terr = tpl.Execute(&output, data)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn output.String(), nil\n}\n{{end}}"),
	}
	file9 := &embedded.EmbeddedFile{
		Filename:    "bootstrap/env.tmpl",
		FileModTime: time.Unix(1533812553, 0),
		Content:     string("# The following must be defined as well: ENV{{if not .Bootstrap.NoDB}}, DSN{{end}}, HTTP_PORT\n{{range .Bootstrap.Settings}}{{upper (snake .Name)}} = \"{{.Description}}\"\n{{end}}"),
	}
	fileb := &embedded.EmbeddedFile{
		Filename:    "bread/service_bread.gocipe.go.tmpl",
		FileModTime: time.Unix(1533755658, 0),
		Content:     string("package bread\n\nimport (\n\t\"github.com/pkg/errors\"\n\t\"golang.org/x/net/context\"\n)\n\nvar (\n\tErrorInvalidOperation = errors.New(\"invalid filter operation specified\")\n\tErrorRequestEmpty = errors.New(\"request object is malformed\")\n)\n\n// Service represents implementation of BREAD service to Browse, Read, Edit, Add and Delete entities\ntype Service struct {\n\tDB *sql.DB\n}\n\n{{range .Entities}}\n{{if .Bread.Create -}}\n// Create{{.Name}} allows creation of entity of type {{.Name}}\nfunc(s Service) Create{{.Name}}(ctx context.Context, req *Create{{.Name}}Request) (*Create{{.Name}}Response, error) {\n\tvar (\n\t\terr  error\n\t\ttx   *sql.Tx\n\t\tres  Create{{.Name}}Response\n\t\t{{if or .Bread.Hooks.PreCreate .Bread.Hooks.PostCreate -}}\n\t\tstop bool\n\t\t{{- end}}\n\t)\n\n\tif req == nil {\n\t\treturn nil, ErrorRequestEmpty\n\t}\n\n\t{{if or .Bread.Hooks.PreCreate .Bread.Hooks.PostCreate -}}\n\tfilespath := make(map[string]string)\n\t{{- end}}\n\n\tres.{{.Name}} = req.{{.Name}}\n\ttx, err = s.DB.Begin()\n\t{{if .Bread.Hooks.PreCreate}}\n\tstop, err = s.{{lower .Name}}PreCreate(ctx, tx, req, &res, filespath, err)\n\tif stop {\n\t\treturn &res, nil\n\t}\n\t{{- end}}\n\n\tif err != nil {\n\t\treturn nil, errors.WithStack(err)\n\t}\n\n\terr = models.{{.Name}}Repo.SaveWithRel(ctx, res.{{.Name}}, tx, true)\n\n\t{{if .Bread.Hooks.PostCreate -}}\n\tstop, err = s.{{lower .Name}}PostCreate(ctx, req, &res, filespath, err)\n\tif stop {\n\t\treturn &res, nil\n\t}\n\t{{- end}}\n\n\tif err != nil {\n\t\treturn nil, errors.WithStack(err)\n\t}\n\n\treturn &res, errors.WithStack(err)\n}\n{{- end}}\n\n{{if .Bread.Read -}}\n// Get{{.Name}} allows getting a single entity of type {{.Name}}\nfunc(s Service) Get{{.Name}}(ctx context.Context, req *Get{{.Name}}Request) (*Get{{.Name}}Response, error) {\n\tvar (\n\t\tres  Get{{.Name}}Response\n\t\terr  error\n\t\t{{if or .Bread.Hooks.PreRead .Bread.Hooks.PostRead -}}\n\t\tstop bool\n\t\t{{- end}}\n\t)\n\n\tif req == nil || req.ID == \"\" {\n\t\treturn nil, ErrorRequestEmpty\n\t}\n\n\t{{if .Bread.Hooks.PreRead}}\n\tstop, err = s.{{lower .Name}}PreRead(ctx, req, &res)\n\tif stop {\n\t\treturn &res, nil\n\t}\n\t{{- end}}\n\n\tres.{{.Name}}, err = models.{{.Name}}Repo.GetWithRel(ctx, req.ID)\n\n\t{{if .Bread.Hooks.PostRead -}}\n\tstop, err = s.{{lower .Name}}PostRead(ctx, req, &res, err)\n\tif stop {\n\t\treturn &res, nil\n\t}\n\t{{- end}}\n\n\tif err != nil {\n\t\treturn nil, errors.WithStack(err)\n\t}\n\n\treturn &res, nil\n}\n{{- end}}\n\n{{if .Bread.List -}}\n// List{{plural .Name}} allows listing all entity of type {{.Name}}\nfunc(s Service) List{{plural .Name}}(ctx context.Context, req *List{{plural .Name}}Request) (*List{{plural .Name}}Response, error) {\n\tvar (\n\t\tres  List{{plural .Name}}Response\n\t\terr  error\n\t\t{{if or .Bread.Hooks.PreList .Bread.Hooks.PostList -}}\n\t\tstop bool\n\t\t{{- end}}\n\t\tfilters []*models.Filter\n\t)\n\n\tif req == nil {\n\t\treturn nil, ErrorRequestEmpty\n\t}\n\n\t{{if .Bread.Hooks.PreList -}}\n\tstop, err = s.{{lower .Name}}PreList(ctx, req, &res)\n\tif stop {\n\t\treturn &res, nil\n\t}\n\t{{- end}}\n\n\tif req.ListOpts == nil {\n\t\treq.ListOpts = &models.ListOpts{Offset: models.NoOffset, Limit: models.NoLimit}\n\t}\n\n\t{{$filters := getBreadFilters .Fields }}\n\t{{if (or $filters.HasBool $filters.HasString $filters.HasDate)}}\n\tif req.Filters != nil {\n\t\tfor i := range req.Filters {\n\t\t\tswitch req.Filters[i].Field {\n\t\t\t{{if $filters.HasBool}}\n\t\t\tcase {{$filters.BoolFilters}}:\n\t\t\t\tif f, err := newBoolFilter(req.Filters[i]); err == nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t} else {\n\t\t\t\t\tfilters = append(filters, f)\n\t\t\t\t}\n\t\t\t{{end}}\n\t\t\t{{if $filters.HasString}}\n\t\t\tcase {{$filters.StringFilters}}:\n\t\t\t\tif f, err := newStringFilter(req.Filters[i]); err == nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t} else {\n\t\t\t\t\tfilters = append(filters, f)\n\t\t\t\t}\n\t\t\t{{end}}\n\t\t\t{{if $filters.HasDate}}\n\t\t\tcase {{$filters.DateFilters}}:\n\t\t\t\tif f, err := newDateFilter(req.Filters[i]); err == nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t} else {\n\t\t\t\t\tfilters = append(filters, f)\n\t\t\t\t}\n\t\t\t{{end}}\n\t\t\t}\n\t\t}\n\t}\n\t{{end}}\n\n\tres.{{plural .Name}}, err = models.{{.Name}}Repo.ListWithRel(ctx, req.ListOpts, filters...)\n\n\t{{if .Bread.Hooks.PostList -}}\n\tstop, err = s.{{lower .Name}}PostList(ctx, req, &res, err)\n\tif stop {\n\t\treturn &res, nil\n\t}\n\t{{- end}}\n\t\n\tif err != nil {\n\t\treturn nil, errors.WithStack(err)\n\t}\n\n\treturn &res, nil\n}\n{{- end}}\n\n{{if .Bread.Update -}}\n// Update{{.Name}} allows updating one entity of type {{.Name}}\nfunc(s Service) Update{{.Name}}(ctx context.Context, req *Update{{.Name}}Request) (*Update{{.Name}}Response, error) {\n\tvar (\n\t\terr  error\n\t\ttx   *sql.Tx\n\t\tres  Update{{.Name}}Response\n\t\t{{if or .Bread.Hooks.PreUpdate .Bread.Hooks.PostUpdate -}}\n\t\tstop bool\n\t\t{{- end}}\n\t)\n\n\tif req == nil || req.{{.Name}} == nil {\n\t\treturn nil, ErrorRequestEmpty\n\t}\n\n\t{{if or .Bread.Hooks.PreUpdate .Bread.Hooks.PostUpdate -}}\n\tfilespath := make(map[string]string)\n\t{{- end}}\n\n\t// existing records in DB\n\texisting, err := models.{{.Name}}Repo.Get(ctx, req.{{.Name}}.ID)\n\tif err != nil {\n\t\t{{if .Bread.Hooks.PreUpdate -}}\n\t\tstop, err = s.{{lower .Name}}PreUpdate(ctx, tx, req, &res, *existing, filespath, err)\n\t\tif stop {\n\t\t\treturn &res, nil\n\t\t}\n\t\t{{end}}\n\t\treturn nil, errors.WithStack(err)\n\t}\n\n\tres.{{.Name}} = req.{{.Name}}\n\ttx, err = s.DB.Begin()\n\n\t{{if .Bread.Hooks.PreUpdate -}}\n\tstop, err = s.{{lower .Name}}PreUpdate(ctx, tx, req, &res, *existing, filespath, err)\n\tif stop {\n\t\treturn &res, nil\n\t}\n\t{{- end}}\n\n\tif err != nil {\n\t\treturn nil, errors.WithStack(err)\n\t}\n\n\terr = models.{{.Name}}Repo.SaveWithRel(ctx, res.{{.Name}}, tx, true)\n\tif err != nil {\n\t\treturn nil, errors.WithStack(err)\n\t}\n\n\t{{if .Bread.Hooks.PostUpdate -}}\n\tstop, err = s.{{lower .Name}}PostUpdate(ctx, req, &res, *existing, filespath, err)\n\tif stop {\n\t\treturn &res, nil\n\t}\n\t{{- end}}\n\n\tif err != nil {\n\t\treturn nil, errors.WithStack(err)\n\t}\n\n\treturn &res, nil\n}\n{{- end}}\n\n{{if .Bread.Delete -}}\n// Delete{{.Name}} allows deleting an entity of type {{.Name}}\nfunc(s Service) Delete{{.Name}}(ctx context.Context, req *Delete{{.Name}}Request) (*Delete{{.Name}}Response, error) {\n\tvar (\n\t\terr  error\n\t\ttx   *sql.Tx\n\t\tres  Delete{{.Name}}Response\n\t\t{{if or .Bread.Hooks.PreDelete .Bread.Hooks.PostDelete -}}\n\t\tstop bool\n\t\t{{- end}}\n\t)\n\n\tif req == nil || req.ID == \"\" {\n\t\treturn nil, ErrorRequestEmpty\n\t}\n\n\t// existing records in DB\n\texisting, err := models.{{.Name}}Repo.Get(ctx, req.ID)\n\tif err != nil {\n\t\t{{if .Bread.Hooks.PreDelete -}}\n\t\tstop, err = s.{{lower .Name}}PreDelete(ctx, tx, req, &res, *existing, err)\n\t\tif stop {\n\t\t\treturn &res, nil\n\t\t}\n\t\t{{end}}\n\t\treturn nil, errors.WithStack(err)\n\t}\n\n\ttx, err = s.DB.Begin()\n\t{{if .Bread.Hooks.PreDelete}}\n\tstop, err = s.{{lower .Name}}PreDelete(ctx, tx, req, &res, *existing, err)\n\tif stop {\n\t\treturn &res, nil\n\t}\n\t{{end}}\n\terr = models.{{.Name}}Repo.Delete(ctx, existing, tx, true)\n\tif err != nil {\n\t\treturn nil, errors.WithStack(err)\n\t}\n\t{{if .Bread.Hooks.PostDelete}}\n\tstop, err = s.{{lower .Name}}PostDelete(ctx, req, &res, *existing, err)\n\tif stop {\n\t\treturn &res, nil\n\t}\n\t{{- end}}\n\t\n\tif err != nil {\n\t\treturn nil, errors.WithStack(err)\n\t}\n\n\treturn &res, nil\n}\n{{- end}}\n{{end}}\n\nfunc newBoolFilter(filter *Filter) (*models.Filter, error) {\n\tvalue, err := strconv.ParseBool(filter.Value); \n\t\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &models.Filter{Field: filter.Field, Operation: \"=\", Value: value}, nil\n}\n\nfunc newStringFilter(filter *Filter) (*models.Filter, error) {\n\tswitch filter.Operation {\n\tcase \"=\":\n\t\treturn &models.Filter{Field: filter.Field, Operation: \"=\", Value: filter.Value}, nil\n\tcase \"~\":\n\t\treturn &models.Filter{Field: filter.Field, Operation: \"LIKE\", Value: filter.Value}, nil\n\t}\n\n\treturn nil, ErrorInvalidOperation\n}\n\nfunc newDateFilter(filter *Filter) (*models.Filter, error) {\n\tvar (\n\t\tvalue time.Time\n\t\terr   error\n\t)\n\n\tif value, err = time.Parse(time.RFC3339, filter.Value); err != nil {\n\t\treturn nil, err\n\t}\n\n\tswitch filter.Operation {\n\tcase \"=\":\n\t\treturn &models.Filter{Field: filter.Field, Operation: \"=\", Value: value}, nil\n\tcase \">\":\n\t\treturn &models.Filter{Field: filter.Field, Operation: \">\", Value: value}, nil\n\tcase \">=\":\n\t\treturn &models.Filter{Field: filter.Field, Operation: \">=\", Value: value}, nil\n\tcase \"<\":\n\t\treturn &models.Filter{Field: filter.Field, Operation: \"<\", Value: value}, nil\n\tcase \"<=\":\n\t\treturn &models.Filter{Field: filter.Field, Operation: \"<=\", Value: value}, nil\n\t}\n\n\treturn &models.Filter{Field: filter.Field, Operation: \"LIKE\", Value: value}, nil\n}\n"),
	}
	filec := &embedded.EmbeddedFile{
		Filename:    "bread/service_bread.proto.tmpl",
		FileModTime: time.Unix(1534420769, 0),
		Content:     string("syntax = \"proto3\";\n\npackage bread;\n\nimport \"models.proto\";\noption go_package = \"{{.AppImportPath}}/services/bread\";\n\nmessage File {\n    string Field = 1;\n    string Filename = 2;\n    bytes Content = 3;\n}\n\nmessage Filter {\n    string Field     = 1;\n    string Operation = 2;\n    string Value     = 3;\n}\n\nservice Bread {\n    {{range .Entities}}\n    {{if .Bread.Create}}\n    // Create{{.Name}} allows creation of entity of type {{.Name}}\n    rpc Create{{.Name}}(Create{{.Name}}Request) returns (Create{{.Name}}Response);\n    {{- end}}\n    {{if .Bread.Read}}\n    // Get{{.Name}} allows getting a single entity of type {{.Name}}\n    rpc Get{{.Name}}(Get{{.Name}}Request) returns (Get{{.Name}}Response);\n    {{- end}}\n    {{if .Bread.List}}\n    // List{{.Name}} allows listing all entity of type {{.Name}}\n    rpc List{{plural .Name}}(List{{plural .Name}}Request) returns (List{{plural .Name}}Response);\n    {{- end}}\n    {{if .Bread.Update}}\n    // Update{{.Name}} allows updating one entity of type {{.Name}}\n    rpc Update{{.Name}}(Update{{.Name}}Request) returns (Update{{.Name}}Response);\n    {{- end}}\n    {{if .Bread.Delete}}\n    // Delete{{.Name}} allows deleting an entity of type {{.Name}}\n    rpc Delete{{.Name}}(Delete{{.Name}}Request) returns (Delete{{.Name}}Response);\n    {{- end}}\n    {{- end}}\n}\n\n{{range .Entities}}\n{{if .Bread.Create}}\n// Create{{.Name}}Request represents a request to allow creation of entity of type {{.Name}}\nmessage Create{{.Name}}Request {\n    string Key = 1;\n\tmodels.{{.Name}} {{.Name}} = 2;\n    repeated File Files = 3;\n}\n// Create{{.Name}}Response represents result to a Create{{.Name}}Request\nmessage Create{{.Name}}Response {\n    models.{{.Name}} {{.Name}} = 1;\n}\n{{- end}}\n{{if .Bread.Read}}\n// Get{{.Name}}Request represents a request to allow getting a single entity of type {{.Name}}\nmessage Get{{.Name}}Request {\n    string Key = 1;\n    string ID = 2;\n}\n// Get{{.Name}}Response represents result to a Get{{.Name}}Request\nmessage Get{{.Name}}Response {\n    models.{{.Name}} {{.Name}} = 1;\n}\n{{- end}}\n{{if .Bread.List}}\n// List{{plural .Name}}Request represents a request to allow listing all entity of type {{.Name}}\nmessage List{{plural .Name}}Request {\n    string Key = 1;\n    models.ListOpts ListOpts = 2;\n    repeated Filter Filters = 3;\n}\n// List{{plural .Name}}Response represents result to a List{{plural .Name}}Request\nmessage List{{plural .Name}}Response {\n    repeated models.{{.Name}} {{plural .Name}} = 1;\n}\n{{- end}}\n{{if .Bread.Update}}\n// Update{{.Name}}Request represents a request to allow updating one entity of type {{.Name}}\nmessage Update{{.Name}}Request {\n    string Key = 1;\n    models.{{.Name}} {{.Name}} = 2;\n    repeated File Files = 3;\n}\n// Update{{.Name}}Response represents result to a Update{{.Name}}Request\nmessage Update{{.Name}}Response {\n    models.{{.Name}} {{.Name}} = 1;\n}\n{{- end}}\n{{if .Bread.Delete}}\n// Delete{{.Name}}Request represents a request to allow deleting an entity of type {{.Name}}\nmessage Delete{{.Name}}Request {\n    string Key = 1;\n    string ID = 2;\n}\n// Delete{{.Name}}Response represents result to a Delete{{.Name}}Request\nmessage Delete{{.Name}}Response {}\n{{- end}}\n{{- end}}\n"),
	}
	filed := &embedded.EmbeddedFile{
		Filename:    "bread/service_bread_hooks.go.tmpl",
		FileModTime: time.Unix(1533755658, 0),
		Content:     string("package bread\n\n{{if .PreRead}}\n// {{lower .Entity.Name}}PreRead is a hook that occurs before the ead operation in BREAD service. Returns stop (boolean) and error\nfunc (s Service) {{lower .Entity.Name}}PreRead(ctx context.Context, req *Get{{.Entity.Name}}Request, res *Get{{.Entity.Name}}Response) (bool, error) {\n\treturn false, nil\n}\n{{end}}\n{{if .PostRead}}\n// {{lower .Entity.Name}}PostRead is a hook that occurs after the Read operation in BREAD service. Returns stop (boolean) and error\nfunc (s Service) {{lower .Entity.Name}}PostRead(ctx context.Context, req *Get{{.Entity.Name}}Request, res *Get{{.Entity.Name}}Response, err error) (bool, error) {\n\treturn false, nil\n}\n{{end}}\n{{if .PreList}}\n// {{lower .Entity.Name}}PreList is a hook that occurs before the ist operation in BREAD service. Returns stop (boolean) and error\nfunc (s Service) {{lower .Entity.Name}}PreList(ctx context.Context, req *List{{plural  .Entity.Name}}Request, res *List{{plural .Entity.Name}}Response) (bool, error) {\n\treturn false, nil\n}\n{{end}}\n{{if .PostList}}\n// {{lower .Entity.Name}}PostList is a hook that occurs after the List operation in BREAD service. Returns stop (boolean) and error\nfunc (s Service) {{lower .Entity.Name}}PostList(ctx context.Context, req *List{{plural  .Entity.Name}}Request, res *List{{plural  .Entity.Name}}Response, err error) (bool, error) {\n\treturn false, nil\n}\n{{end}}\n{{if .PreCreate}}\n// {{lower .Entity.Name}}PreCreate is a hook that occurs before the reate operation in BREAD service. Returns stop (boolean) and error\nfunc (s Service) {{lower .Entity.Name}}PreCreate(ctx context.Context, tx *sql.Tx, req *Create{{.Entity.Name}}Request, res *Create{{.Entity.Name}}Response, filespath map[string]string, err error) (bool, error) {\n\treturn false, nil\n}\n{{end}}\n{{if .PostCreate}}\n// {{lower .Entity.Name}}PostCreate is a hook that occurs after the Create operation in BREAD service. Returns stop (boolean) and error\nfunc (s Service) {{lower .Entity.Name}}PostCreate(ctx context.Context, req *Create{{.Entity.Name}}Request, res *Create{{.Entity.Name}}Response, filespath map[string]string, err error) (bool, error) {\n\treturn false, nil\n}\n{{end}}\n{{if .PreUpdate}}\n// {{lower .Entity.Name}}PreUpdate is a hook that occurs before the pdate operation in BREAD service. Returns stop (boolean) and error\nfunc (s Service) {{lower .Entity.Name}}PreUpdate(ctx context.Context, tx *sql.Tx, req *Update{{.Entity.Name}}Request, res *Update{{.Entity.Name}}Response, existing models.{{.Entity.Name}}, filespath map[string]string, err error) (bool, error) {\n\treturn false, nil\n}\n{{end}}\n{{if .PostUpdate}}\n// {{lower .Entity.Name}}PostUpdate is a hook that occurs after the Update operation in BREAD service. Returns stop (boolean) and error\nfunc (s Service) {{lower .Entity.Name}}PostUpdate(ctx context.Context, req *Update{{.Entity.Name}}Request, res *Update{{.Entity.Name}}Response, existing models.{{.Entity.Name}}, filespath map[string]string, err error) (bool, error) {\n\treturn false, nil\n}\n{{end}}\n{{if .PreDelete}}\n// {{lower .Entity.Name}}PreDelete is a hook that occurs before the elete operation in BREAD service. Returns stop (boolean) and error\nfunc (s Service) {{lower .Entity.Name}}PreDelete(ctx context.Context, tx *sql.Tx, req *Delete{{.Entity.Name}}Request, res *Delete{{.Entity.Name}}Response, existing models.{{.Entity.Name}}, err error) (bool, error) {\n\treturn false, nil\n}\n{{end}}\n{{if .PostDelete}}\n// {{lower .Entity.Name}}PostDelete is a hook that occurs after the Delete operation in BREAD service. Returns stop (boolean) and error\nfunc (s Service) {{lower .Entity.Name}}PostDelete(ctx context.Context, req *Delete{{.Entity.Name}}Request, res *Delete{{.Entity.Name}}Response, existing models.{{.Entity.Name}}, err error) (bool, error) {\n\treturn false, nil\n}\n{{end}}\n"),
	}
	filef := &embedded.EmbeddedFile{
		Filename:    "crud/crud.go.tmpl",
		FileModTime: time.Unix(1532434897, 0),
		Content:     string("package models\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"github.com/pkg/errors\"\n\t{{range .Imports}}{{.}}{{end}}\n)\n{{.Structure}}\n{{.Get}}\n{{.List}}\n{{.DeleteSingle}}\n{{.DeleteMany}}\n{{.Save}}\n{{.Insert}}\n{{.Update}}\n{{.Merge}}\n{{range .LoadRelated}}{{.}}{{end}}\n{{range .SaveRelated}}{{.}}{{end}}"),
	}
	fileg := &embedded.EmbeddedFile{
		Filename:    "crud/hooks.go.tmpl",
		FileModTime: time.Unix(1528714907, 0),
		Content:     string("package models\nimport (\n\t\"database/sql\"\n)\n\n{{if .Hooks.PreRead}}\nfunc crudPreGet(id {{pkeyPropertyType .Entity.PrimaryKey}}) error {\n\treturn nil\n}\n{{end}}\n{{if .Hooks.PostRead}}\nfunc crudPostGet(entity *{{.Entity.Name}}) error {\n\treturn nil\n}\n{{end}}\n\n{{if .Hooks.PreList}}\nfunc crudPreList(filters []models.ListFilter) ([]models.ListFilter, error) {\n\treturn filters, nil\n}\n{{end}}\n{{if .Hooks.PostList}}\nfunc crudPostList(list []*{{.Entity.Name}}) ([]*{{.Entity.Name}}, error) {\n\treturn list, nil\n}\n{{end}}\n\n{{if .Hooks.PreDelete}}\nfunc crudPreDelete(id {{pkeyPropertyType .Entity.PrimaryKey}}, tx *sql.Tx) error {\n\treturn nil\n}\n{{end}}\n{{if .Hooks.PostDelete}}\nfunc crudPostDelete(id {{pkeyPropertyType .Entity.PrimaryKey}}, tx *sql.Tx) error {\n\treturn nil\n}\n{{end}}\n\n\n{{if .Hooks.PreSave }}\nfunc crudPreSave(op string, entity *{{.Entity.Name}}, tx *sql.Tx) error {\n\treturn nil\n}\n{{end}}\n{{if .Hooks.PreSave }}\nfunc crudPostSave(op string, entity *{{.Entity.Name}}, tx *sql.Tx) error {\n\treturn nil\n}\n{{end}}\n\n"),
	}
	fileh := &embedded.EmbeddedFile{
		Filename:    "crud/models.go.tmpl",
		FileModTime: time.Unix(1534490268, 0),
		Content:     string("package models\n\nvar (\n\tdb *sql.DB\n\t{{range .Entities}}\n\t// {{.Name}}Repo provides interaction with database content repository for {{.Name}}\n\t{{.Name}}Repo {{.Name}}Repository\n\t{{- end}}\n)\n\nconst (\n\t// OperationMerge indicates a Merge save operation is under way\n\tOperationMerge  byte = 'M'\n\t// OperationInsert indicates a Insert save operation is under way\n\tOperationInsert byte = 'I'\n\t// OperationUpdate indicates a Update save operation is under way\n\tOperationUpdate byte = 'U'\n\n\t// NoOffset indicates List/Select queries without offset clause\n\tNoOffset = -1\n\t// NoLimit indicates List/Select queries without limit clause\n\tNoLimit  = -1\n)\n\n// Filter represents a filter to apply during listing (crud)\ntype Filter struct {\n\tField     string\n\tOperation string\n\tValue     interface{}\n}\n\n// Init is responsible to initialize all repositories\nfunc Init(database *sql.DB) {\n\tdb = database\n\t{{range .Entities}}\n\t{{.Name}}Repo = {{.Name}}Repositorium{db: database}\n\t{{- end}}\n}\n\n// StartTransaction initiates a database transaction\nfunc StartTransaction() (*sql.Tx, error) {\n\treturn db.Begin()\n}\n\n{{- $Entities := .Entities -}}\n{{range .Entities }}\n// {{.Name}}Repository encapsulates operations that may be performed on the entity {{.Name}}\ntype {{.Name}}Repository interface {\n{{if $.Crud -}}\n\t// Insert performs an SQL insert for {{.Name}} record and update instance with inserted id.\n\tInsert(ctx context.Context, entity *{{.Name}}, tx *sql.Tx, autocommit bool) error\t\n\t// InsertWithRel performs an SQL insert for {{.Name}} record and update instance with inserted id; including related entities. Prefer using Save instead of Insert directly.\n\tInsertWithRel(ctx context.Context, entity *{{.Name}}, tx *sql.Tx, autocommit bool) error\n\t\n\t// Get returns a single {{.Name}} from database by primary key\n\tGet(ctx context.Context, id {{pkeyPropertyType .PrimaryKey}}) (*{{.Name}}, error)\n\t// GetWithRel returns a single {{.Name}} from database by primary key; loads related entities\n\tGetWithRel(ctx context.Context, id {{pkeyPropertyType .PrimaryKey}}) (*{{.Name}}, error)\n\t\n\t// List returns a slice containing {{.Name}} records\n\tList(ctx context.Context, opts *ListOpts, filters ...*Filter) ([]*{{.Name}}, error)\n\t// ListWithRel returns a slice containing {{.Name}} records; will also load related entities.\n\tListWithRel(ctx context.Context, opts *ListOpts, filters ...*Filter) ([]*{{.Name}}, error)\n\t\n\t// Select returns a slice containing {{.Name}} records according to a custom SQL condition\n\tSelect(ctx context.Context, opts *ListOpts, condition string, values ...interface{}) ([]*{{.Name}}, error)\n\t// SelectWithRel returns a slice containing {{.Name}} records according to a custom SQL condition; will also load related entities.\n\tSelectWithRel(ctx context.Context, opts *ListOpts, condition string, values ...interface{}) ([]*{{.Name}}, error)\n\t\n\t// Update Will execute an SQLUpdate Statement for {{.Name}} in the database. Prefer using Save instead of Update directly.\n\tUpdate(ctx context.Context, entity *{{.Name}}, tx *sql.Tx, autocommit bool) error\n\t// UpdateWithRel Will execute an SQLUpdate Statement for {{.Name}} in the database; including related entities. Prefer using Save instead of Update directly.\n\tUpdateWithRel(ctx context.Context, entity *{{.Name}}, tx *sql.Tx, autocommit bool) error\n\t// DeleteMany deletes many {{.Name}} records from database using filter\n\tDeleteMany(ctx context.Context, tx *sql.Tx, autocommit bool, filters ...*Filter) error\n\t// Delete deletes a {{.Name}} record from database and sets id to nil\n\tDelete(ctx context.Context, entity *{{.Name}}, tx *sql.Tx, autocommit bool) error\n\t\n\t// Merge performs an SQL merge for {{.Name}} record.\n\tMerge(ctx context.Context, entity *{{.Name}}, tx *sql.Tx, autocommit bool) error\n\t// Save either inserts or updates a {{.Name}} record based on whether or not id is nil\n\tSave(ctx context.Context, entity *{{.Name}}, tx *sql.Tx, autocommit bool) error\n\t// SaveWithRel either inserts or updates a {{.Name}} record based on whether or not id is nil; will also save related entities\n\tSaveWithRel(ctx context.Context, entity *{{.Name}}, tx *sql.Tx, autocommit bool) error\n{{end -}}\n\n{{- $ThisEntity := . -}}\n{{range .Relationships -}}\n{{if eq .Type \"many-many\" -}}\n\t// Load{{RelFuncName .}} is a helper function to load related {{.Name}} entities\n\tLoad{{RelFuncName .}}(ctx context.Context, entities ...*{{$ThisEntity.Name}}) error\n\t// Save{{RelFuncName .}} is a helper function to save related {{.Name}} in a pivot table (many-many relationship)\n\tSave{{RelFuncName .}}(ctx context.Context, tx *sql.Tx, autocommit bool, idthis {{pkeyPropertyType $ThisEntity.PrimaryKey}}, relatives ...*{{fkeyPropertyTypeName $Entities .}}) error\n\t// Save{{RelFuncName .}}IDs is a helper function to save related {{.Name}} IDs in a pivot table (many-many relationship)\n\tSave{{RelFuncName .}}IDs(ctx context.Context, tx *sql.Tx, autocommit bool, idthis {{pkeyPropertyType $ThisEntity.PrimaryKey}}, relatives ...{{fkeyPropertyType $Entities .}}) error\n{{end -}}\n{{if eq .Type \"one-many\" -}}\n\t// Load{{RelFuncName .}} is a helper function to load related {{.Name}} entities\n\tLoad{{RelFuncName .}}(ctx context.Context, entities ...*{{$ThisEntity.Name}}) error\n{{end -}}\n{{if eq .Type \"many-one\" -}}\n\t// Load{{RelFuncName .}} is a helper function to load related {{.Name}} entities\n\tLoad{{RelFuncName .}}(ctx context.Context, entities ...*{{$ThisEntity.Name}}) error\n{{end -}}\n{{end -}}\n}\n\n// {{.Name}}Repositorium implements {{.Name}}Repository\ntype {{.Name}}Repositorium struct {\n\tdb *sql.DB\n}\n{{end}}\n\n// QueryAddIN adds IN condition to query\nfunc QueryAddIN(segments []string, values []interface{}, index *int, fieldname string, val interface{}, not bool) ([]string, []interface{}, error) {\n\tvar subsegments []string\n\n\tif data, ok := val.([]bool); ok {\n\t\tfor d := range data {\n\t\t\t*index += 1\n\t\t\tsubsegments = append(subsegments, \"$\"+strconv.Itoa(*index))\n\t\t\tvalues = append(values, data[d])\n\t\t}\n\t} else if data, ok := val.([]byte); ok {\n\t\tfor d := range data {\n\t\t\t*index += 1\n\t\t\tsubsegments = append(subsegments, \"$\"+strconv.Itoa(*index))\n\t\t\tvalues = append(values, data[d])\n\t\t}\n\t} else if data, ok := val.([]complex64); ok {\n\t\tfor d := range data {\n\t\t\t*index += 1\n\t\t\tsubsegments = append(subsegments, \"$\"+strconv.Itoa(*index))\n\t\t\tvalues = append(values, data[d])\n\t\t}\n\t} else if data, ok := val.([]complex128); ok {\n\t\tfor d := range data {\n\t\t\t*index += 1\n\t\t\tsubsegments = append(subsegments, \"$\"+strconv.Itoa(*index))\n\t\t\tvalues = append(values, data[d])\n\t\t}\n\t} else if data, ok := val.([]float32); ok {\n\t\tfor d := range data {\n\t\t\t*index += 1\n\t\t\tsubsegments = append(subsegments, \"$\"+strconv.Itoa(*index))\n\t\t\tvalues = append(values, data[d])\n\t\t}\n\t} else if data, ok := val.([]float64); ok {\n\t\tfor d := range data {\n\t\t\t*index += 1\n\t\t\tsubsegments = append(subsegments, \"$\"+strconv.Itoa(*index))\n\t\t\tvalues = append(values, data[d])\n\t\t}\n\t} else if data, ok := val.([]int); ok {\n\t\tfor d := range data {\n\t\t\t*index += 1\n\t\t\tsubsegments = append(subsegments, \"$\"+strconv.Itoa(*index))\n\t\t\tvalues = append(values, data[d])\n\t\t}\n\t} else if data, ok := val.([]int8); ok {\n\t\tfor d := range data {\n\t\t\t*index += 1\n\t\t\tsubsegments = append(subsegments, \"$\"+strconv.Itoa(*index))\n\t\t\tvalues = append(values, data[d])\n\t\t}\n\t} else if data, ok := val.([]int16); ok {\n\t\tfor d := range data {\n\t\t\t*index += 1\n\t\t\tsubsegments = append(subsegments, \"$\"+strconv.Itoa(*index))\n\t\t\tvalues = append(values, data[d])\n\t\t}\n\t} else if data, ok := val.([]int32); ok {\n\t\tfor d := range data {\n\t\t\t*index += 1\n\t\t\tsubsegments = append(subsegments, \"$\"+strconv.Itoa(*index))\n\t\t\tvalues = append(values, data[d])\n\t\t}\n\t} else if data, ok := val.([]int64); ok {\n\t\tfor d := range data {\n\t\t\t*index += 1\n\t\t\tsubsegments = append(subsegments, \"$\"+strconv.Itoa(*index))\n\t\t\tvalues = append(values, data[d])\n\t\t}\n\t} else if data, ok := val.([]rune); ok {\n\t\tfor d := range data {\n\t\t\t*index += 1\n\t\t\tsubsegments = append(subsegments, \"$\"+strconv.Itoa(*index))\n\t\t\tvalues = append(values, data[d])\n\t\t}\n\t} else if data, ok := val.([]string); ok {\n\t\tfor d := range data {\n\t\t\t*index += 1\n\t\t\tsubsegments = append(subsegments, \"$\"+strconv.Itoa(*index))\n\t\t\tvalues = append(values, data[d])\n\t\t}\n\t} else if data, ok := val.([]uint); ok {\n\t\tfor d := range data {\n\t\t\t*index += 1\n\t\t\tsubsegments = append(subsegments, \"$\"+strconv.Itoa(*index))\n\t\t\tvalues = append(values, data[d])\n\t\t}\n\t} else if data, ok := val.([]uint8); ok {\n\t\tfor d := range data {\n\t\t\t*index += 1\n\t\t\tsubsegments = append(subsegments, \"$\"+strconv.Itoa(*index))\n\t\t\tvalues = append(values, data[d])\n\t\t}\n\t} else if data, ok := val.([]uint16); ok {\n\t\tfor d := range data {\n\t\t\t*index += 1\n\t\t\tsubsegments = append(subsegments, \"$\"+strconv.Itoa(*index))\n\t\t\tvalues = append(values, data[d])\n\t\t}\n\t} else if data, ok := val.([]uint32); ok {\n\t\tfor d := range data {\n\t\t\t*index += 1\n\t\t\tsubsegments = append(subsegments, \"$\"+strconv.Itoa(*index))\n\t\t\tvalues = append(values, data[d])\n\t\t}\n\t} else if data, ok := val.([]uint64); ok {\n\t\tfor d := range data {\n\t\t\t*index += 1\n\t\t\tsubsegments = append(subsegments, \"$\"+strconv.Itoa(*index))\n\t\t\tvalues = append(values, data[d])\n\t\t}\n\t} else if data, ok := val.([]uintptr); ok {\n\t\tfor d := range data {\n\t\t\t*index += 1\n\t\t\tsubsegments = append(subsegments, \"$\"+strconv.Itoa(*index))\n\t\t\tvalues = append(values, data[d])\n\t\t}\t} else {\n\t\treturn nil, nil, moderrors.InFilterValueUnknownError\n\t}\n\n\tif len(subsegments) == 0 {\n\t\treturn nil, nil, moderrors.InFilterValueEmptyError\n\t}\n\n\tcondition := \" IN\"\n\tif not {\n\t\tcondition = \" NOT\" + condition\n\t}\n\n\tsegments = append(segments, fieldname+condition+\" (\"+strings.Join(subsegments, \",\")+\")\")\n\treturn segments, values, nil\n}\n"),
	}
	filei := &embedded.EmbeddedFile{
		Filename:    "crud/moderrors.go.tmpl",
		FileModTime: time.Unix(1531136700, 0),
		Content:     string("package moderrors\n\nvar (\n\t// RecordNotFoundError indicates record not found when using Repository.Get()\n\tRecordNotFoundError = errors.New(\"record not found\")\n\n\t// InFilterValueUnknownError indicates that value for IN condition is not known\n\tInFilterValueUnknownError = errors.New(\"unknown filter value type for IN condition\")\n\n\t// InFilterValueEmptyError indicates that slice of values provided for IN condition is empty\n\tInFilterValueEmptyError = errors.New(\"filter values for IN condition empty\")\n)"),
	}
	filek := &embedded.EmbeddedFile{
		Filename:    "crud/partials/delete_many.go.tmpl",
		FileModTime: time.Unix(1532888772, 0),
		Content:     string("\n// DeleteMany deletes many {{.EntityName}} records from database using filter\nfunc (repo {{.EntityName}}Repositorium) DeleteMany(ctx context.Context, tx *sql.Tx, autocommit bool, filters ...*Filter) error {\n\tvar (\n\t\terr      error\n\t\tstmt     *sql.Stmt\n\t\tsegments []string\n\t\tvalues   []interface{}\n\t\tquery    string\n\t)\n\n\tif tx == nil {\n\t\tif err = util.CheckContext(ctx); err != nil {\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t\t\n\t\ttx, err = repo.db.Begin()\n\t\tif err != nil {\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t}\n\n\t{{if .HasPreHook}}\n    if filters, err = repo.preDeleteMany(ctx, tx, filters); err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\t{{end}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\tfor i, filter := range filters {\n\t\tsegments = append(segments, filter.Field+\" \"+filter.Operation+\" $\"+strconv.Itoa(i+1))\n\t\tvalues = append(values, filter.Value)\n\t}\n\n\tif len(segments) != 0 {\n\t\tquery = \" WHERE \" + strings.Join(segments, \" AND \")\n\t}\n\n\t{{range .Relationships}}{{if eq .Type \"many-many\"}}\n\tstmt, err = repo.db.Prepare(\"DELETE FROM {{.JoinTable}} WHERE {{.ThatID}} IN (SELECT id FROM {{$.Table}}\"+query+\")\")\n\tif err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\n\t_, err = stmt.Exec(values...)\n\tif err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t{{end}}{{end}}\n\n\tstmt, err = repo.db.Prepare(\"DELETE FROM {{.Table}}\"+query)\n\tif err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif err = util.CheckContext(ctx); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\t_, err = stmt.Exec(values...)\n\tif err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\t{{if .HasPostHook}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif err = repo.postDeleteMany(ctx, tx, filters); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t{{end}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif autocommit {\n\t\terr = tx.Commit()\n\t\tif err != nil {\n\t\t\ttx.Rollback()\n\t\t}\n\t}\n\n\treturn errors.WithStack(err)\n}\n"),
	}
	filel := &embedded.EmbeddedFile{
		Filename:    "crud/partials/delete_single.go.tmpl",
		FileModTime: time.Unix(1532434481, 0),
		Content:     string("\n// Delete deletes a {{.EntityName}} record from database and sets id to nil\nfunc (repo {{.EntityName}}Repositorium) Delete(ctx context.Context, entity *{{.EntityName}}, tx *sql.Tx, autocommit bool) error {\n\tvar (\n\t\terr  error\n\t\tstmt *sql.Stmt\n\t)\n\tid := entity.ID\n\n\tif tx == nil {\n\t\tif err = util.CheckContext(ctx); err != nil {\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\n\t\ttx, err = repo.db.Begin()\n\t\tif err != nil {\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t}\n\n\tif err = util.CheckContext(ctx); err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\n\tstmt, err = tx.Prepare(\"DELETE FROM {{.Table}} WHERE id = $1\")\n\tif err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\t{{if .HasPreHook}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif err = repo.preDelete(ctx, tx, id); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t{{end}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t\n\t_, err = stmt.Exec(id)\n\tif err == nil {\n\t\tentity.ID = {{pkeyPropertyEmptyVal .PrimaryKey}}\n\t} else {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t\n\t{{range .Post}}{{.}}\n\t{{end}}\n\n\t{{if .HasPostHook}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t\n\tif err = repo.postDelete(ctx, tx, id); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t{{end}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif autocommit {\n\t\terr = tx.Commit()\n\t\tif err != nil {\n\t\t\ttx.Rollback()\n\t\t}\n\t}\n\n\treturn errors.WithStack(err)\n}"),
	}
	filem := &embedded.EmbeddedFile{
		Filename:    "crud/partials/get.go.tmpl",
		FileModTime: time.Unix(1532605297, 0),
		Content:     string("\n// Get returns a single {{.EntityName}} from database by primary key\nfunc (repo {{.EntityName}}Repositorium) Get(ctx context.Context, id {{pkeyPropertyType .PrimaryKey}}) (*{{.EntityName}}, error) {\n\tvar (\n\t\trows   *sql.Rows\n\t\terr    error\n\t\tentity {{.EntityName}}\n\t)\n\t{{if .HasPreHook}}\n    if err = repo.preGet(ctx, id); err != nil {\n\t\treturn nil, err\n\t}\n    {{end}}\n\t\n\tif err = util.CheckContext(ctx); err != nil {\n\t\treturn nil, err\n\t}\n\n\trows, err = repo.db.Query(`SELECT {{.SQLFields}} FROM {{.Table}} t WHERE t.id = $1 ORDER BY t.id ASC`, id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdefer rows.Close()\n\tif rows.Next() {\n\t\tif err = util.CheckContext(ctx); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t{{range .Before}}{{.}}\n\t\t{{end}}\n\n\t\terr = rows.Scan({{.StructFields}})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\t\n\t\t{{range .After}}{{.}}\n\t\t{{end}}\n\t} else {\n\t\treturn nil, moderrors.RecordNotFoundError\n\t}\n\t{{if .HasPostHook}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err = repo.postGet(ctx, &entity); err != nil {\n\t\treturn nil, err\n\t}\n\t{{end}}\n\n\treturn &entity, nil\n}\n\n// GetWithRel returns a single {{.EntityName}} from database by primary key; loads related entities\nfunc (repo {{.EntityName}}Repositorium) GetWithRel(ctx context.Context, id {{pkeyPropertyType .PrimaryKey}}) (*{{.EntityName}}, error) {\n\tentity, err := repo.Get(ctx, id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t{{range .Related}}{{.}}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err = util.CheckContext(ctx); err != nil {\n\t\treturn nil, err\n\t}\n\t{{end}}\n\n\treturn entity, nil\n}"),
	}
	filen := &embedded.EmbeddedFile{
		Filename:    "crud/partials/insert.go.tmpl",
		FileModTime: time.Unix(1534795470, 0),
		Content:     string("\n// Insert performs an SQL insert for {{.EntityName}} record and update instance with inserted id. Prefer using Save instead of Insert directly.\nfunc (repo {{.EntityName}}Repositorium) Insert(ctx context.Context, entity *{{.EntityName}}, tx *sql.Tx, autocommit bool) error {\n\tvar (\n\t\t{{- if pkeyIsAuto .PrimaryKey -}}\n\t\tid  {{pkeyPropertyType .PrimaryKey}}\n\t\t{{- end}}\n\t\terr  error\n\t\tstmt *sql.Stmt\n\t)\n\n\tif tx == nil {\n\t\tif err = util.CheckContext(ctx); err != nil {\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t\t\n\t\ttx, err = repo.db.Begin()\n\t\tif err != nil {\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t}\n\t{{range .Before}}{{.}}\n\t{{end}}\n\n\t{{if eq .PrimaryKey \"serial\" -}}\n\tstmt, err = tx.Prepare(`INSERT INTO {{.Table}} ({{.SQLFields}}) VALUES ({{.SQLPlaceholders}}) RETURNING id`)\n\tif err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\t{{else}}\n\tstmt, err = tx.Prepare(`INSERT INTO {{.Table}} ({{.SQLFields}}) VALUES ({{.SQLPlaceholders}})`)\n\tif err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\t{{- end}}\n\n\t{{range .After}}{{.}}\n\t{{end}}\n\n\t{{if .HasPreHook}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\t\n\tif err = repo.preSave(ctx, tx, models.OperationInsert, entity); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t{{end}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t{{if eq .PrimaryKey \"serial\" -}}\n\terr = stmt.QueryRow({{.StructFields}}).Scan(&id)\n\tif err == nil {\n\t\tentity.ID = id\n\t} else {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t{{else}}\n\t{{if eq .PrimaryKey \"uuid\" -}}\n\tidUUID := uuid.NewV4()\n\tid = idUUID.String()\n\tentity.ID = id\n\t{{- end}}\n\n\tif err = util.CheckContext(ctx); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\t_, err = stmt.Exec({{.StructFields}})\n\tif err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t{{end}}\n\n\t{{if .HasPostHook}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\tif err := repo.postSave(ctx, \"INSERT\", entity, tx); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t{{end}}\n\n\tif err = util.CheckContext(ctx); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif autocommit {\n\t\terr = tx.Commit()\n\t\tif err != nil {\n\t\t\ttx.Rollback()\n\t\t}\n\t}\n\n\treturn errors.WithStack(err)\n}\n\n// InsertWithRel performs an SQL insert for {{.EntityName}} record and update instance with inserted id; including related entities. Prefer using Save instead of Insert directly.\nfunc (repo {{.EntityName}}Repositorium) InsertWithRel(ctx context.Context, entity *{{.EntityName}}, tx *sql.Tx, autocommit bool) error{\n\tvar (\n\t\t{{- if pkeyIsAuto .PrimaryKey -}}\n\t\tid  {{pkeyPropertyType .PrimaryKey}}\n\t\t{{- end}}\n\t\terr  error\n\t\tstmt *sql.Stmt\n\t)\n\n\tif tx == nil {\n\t\tif err = util.CheckContext(ctx); err != nil {\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t\t\n\t\ttx, err = repo.db.Begin()\n\t\tif err != nil {\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t}\n\t{{range .Before}}{{.}}\n\t{{end}}\n\n\t{{if eq .PrimaryKey \"serial\" -}}\n\tstmt, err = tx.Prepare(`INSERT INTO {{.Table}} ({{.SQLFields}}) VALUES ({{.SQLPlaceholders}}) RETURNING id`)\n\tif err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\t{{else}}\n\tstmt, err = tx.Prepare(`INSERT INTO {{.Table}} ({{.SQLFields}}) VALUES ({{.SQLPlaceholders}})`)\n\tif err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\t{{- end}}\n\n\t{{range .After}}{{.}}\n\t{{end}}\n\n\t{{if .HasPreHook}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\t\n\tif err = repo.preSave(ctx, tx, models.OperationInsert, entity); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t{{end}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t{{if eq .PrimaryKey \"serial\" -}}\n\terr = stmt.QueryRow({{.StructFields}}).Scan(&id)\n\tif err == nil {\n\t\tentity.ID = id\n\t} else {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t{{else}}\n\t{{if eq .PrimaryKey \"uuid\" -}}\n\tidUUID := uuid.NewV4()\n\tid = idUUID.String()\n\tentity.ID = id\n\t{{- end}}\n\n\tif err = util.CheckContext(ctx); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\t_, err = stmt.Exec({{.StructFields}})\n\tif err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t{{end}}\n\n\t{{range $i, $r := .Related}}{{$r}}\n\tif err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t{{if ne (plus1 $i) (len $.Related)}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t{{end}}\n\t{{end}}\n\n\t{{if .HasPostHook}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\tif err := repo.postSave(ctx, \"INSERT\", entity, tx); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t{{end}}\n\n\tif err = util.CheckContext(ctx); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif autocommit {\n\t\terr = tx.Commit()\n\t\tif err != nil {\n\t\t\ttx.Rollback()\n\t\t}\n\t}\n\n\treturn errors.WithStack(err)\n}\n"),
	}
	fileo := &embedded.EmbeddedFile{
		Filename:    "crud/partials/list.go.tmpl",
		FileModTime: time.Unix(1534760230, 0),
		Content:     string("\n// List returns a slice containing {{.EntityName}} records\nfunc (repo {{.EntityName}}Repositorium) List(ctx context.Context, opts *ListOpts, filters ...*Filter) ([]*{{.EntityName}}, error) {\n\tvar (\n\t\tlist\t []*{{.EntityName}}\n\t\tsegments []string\n\t\tvalues\t []interface{}\n\t\terr\t\t error\n\t\trows\t *sql.Rows\n\t\tindex\t int = 0\n\t)\n\n\tquery := `SELECT {{.SQLFields}} FROM {{.Table}} t`\n\t{{if .HasPreHook}}\n    if filters, err = repo.preList(ctx, filters); err != nil {\n\t\treturn nil, err\n\t}\n\t{{end}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, filter := range filters {\n\t\tif filter.Operation == \"IN\" || filter.Operation == \"NOT IN\" {\n\t\t\tseg, val, err := QueryAddIN(segments, values, &index, filter.Field, filter.Value, \"NOT IN\" == filter.Operation)\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tsegments = seg\n\t\t\tvalues = val\n\t\t} else {\n\t\t\tindex += 1\n\t\t\tsegments = append(segments, filter.Field+\" \"+filter.Operation+\" $\"+strconv.Itoa(index))\n\t\t\tvalues = append(values, filter.Value)\n\t\t}\n\t}\n\n\tif len(segments) != 0 {\n\t\tquery += \" WHERE \" + strings.Join(segments, \" AND \")\n\t}\n\n\tif opts != nil && opts.Sort != \"\" {\n\t\tquery += \" ORDER BY \" + opts.Sort\n\t}{{if .DefaultSort}} else {\n\t\tquery += ` ORDER BY {{.DefaultSort}}`\n\t}\n\t{{- end}}\n\n\tif opts != nil && opts.Offset > 0 {\n\t\tquery += \" OFFSET \" + strconv.FormatInt(opts.Offset, 10)\n\t}\n\n\tif opts != nil && opts.Limit > 0 {\n\t\tquery += \" LIMIT \" + strconv.FormatInt(opts.Limit, 10)\n\t}\n\n\trows, err = repo.db.Query(query, values...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdefer rows.Close()\n\tfor rows.Next() {\n\t\tif err = util.CheckContext(ctx); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tvar entity {{.EntityName}}\n\t\t{{range .Before}}{{.}}\n\t\t{{end}}\n\n\t\terr = rows.Scan({{.StructFields}})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\t\n\t\t{{range .After}}{{.}}\n\t\t{{end}}\n\n\t\tlist = append(list, &entity)\n\t}\n\t{{if .HasPostHook}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif list, err = repo.postList(ctx, list); err != nil {\n\t\treturn nil, err\n\t}\n\t{{end}}\n\treturn list, nil\n}\n\n// ListWithRel returns a slice containing {{.EntityName}} records; will also load related entities.\nfunc (repo {{.EntityName}}Repositorium) ListWithRel(ctx context.Context, opts *ListOpts, filters ...*Filter) ([]*{{.EntityName}}, error) {\n\tvar (\n\t\terr error\n\t\tentities []*{{.EntityName}}\n\t)\n\n\tentities, err = repo.List(ctx, opts, filters...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t{{range .Related}}{{.}}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err = util.CheckContext(ctx); err != nil {\n\t\treturn nil, err\n\t}\n\t{{end}}\n\n\treturn entities, nil\n}\n\n// Select returns a slice containing {{.EntityName}} records according to a custom SQL condition\nfunc (repo {{.EntityName}}Repositorium) Select(ctx context.Context, opts *ListOpts, condition string, values ...interface{}) ([]*{{.EntityName}}, error) {\n\tvar (\n\t\tlist     []*{{.EntityName}}\n\t\terr      error\n\t\trows     *sql.Rows\n\t)\n\n\tquery := `SELECT {{.SQLFields}} FROM {{.Table}} t ` + condition\n\tif err = util.CheckContext(ctx); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif opts != nil {\n\t\tswitch opts.Sort {\n\t\tcase {{.OrderFields}}:\n\t\t\tquery += ` ORDER BY t.\"` + opts.Sort + `\"`\n\t\t}\n\t}\n\n\tif opts != nil && opts.Offset > 0 {\n\t\tquery += \" OFFSET \" + strconv.FormatInt(opts.Offset, 10)\n\t}\n\n\tif opts != nil && opts.Limit > 0 {\n\t\tquery += \" LIMIT \" + strconv.FormatInt(opts.Limit, 10)\n\t}\n\n\trows, err = repo.db.Query(query, values...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdefer rows.Close()\n\tfor rows.Next() {\n\t\tif err = util.CheckContext(ctx); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tvar entity {{.EntityName}}\n\t\t{{range .Before}}{{.}}\n\t\t{{end}}\n\n\t\terr = rows.Scan({{.StructFields}})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\t\n\t\t{{range .After}}{{.}}\n\t\t{{end}}\n\n\t\tlist = append(list, &entity)\n\t}\n\n\treturn list, nil\n}\n\n// SelectWithRel returns a slice containing {{.EntityName}} records according to a custom SQL condition; will also load related entities.\nfunc (repo {{.EntityName}}Repositorium) SelectWithRel(ctx context.Context, opts *ListOpts, condition string, values ...interface{}) ([]*{{.EntityName}}, error) {\n\tvar (\n\t\terr error\n\t\tentities []*{{.EntityName}}\n\t)\n\n\tentities, err = repo.Select(ctx, opts, condition, values...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t{{range .Related}}{{.}}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err = util.CheckContext(ctx); err != nil {\n\t\treturn nil, err\n\t}\n\t{{end}}\n\n\treturn entities, nil\n}\n"),
	}
	filep := &embedded.EmbeddedFile{
		Filename:    "crud/partials/loadrelated_manymany.go.tmpl",
		FileModTime: time.Unix(1533713685, 0),
		Content:     string("\n// Load{{.Funcname}} is a helper function to load related {{.PropertyName}} entities\nfunc (repo {{.ThisEntity}}Repositorium) Load{{.Funcname}}(ctx context.Context, entities ...*{{.ThisEntity}}) error {\n\tvar (\n\t\terr error\n\t\tplaceholder string\n\t\tvalues  []interface{}\n\t\tindices = make(map[{{.ThisType}}][]*{{.ThisEntity}})\n\t)\n\n\tif err = util.CheckContext(ctx); err != nil {\n\t\treturn errors.WithStack(err)\n\t} else if len(entities) == 0 {\n\t\treturn nil\n\t}\n\n\tc := 1\n\tfor _, entity := range entities {\n\t\tplaceholder += \"$\" + strconv.Itoa(c) + \",\"\n\t\tindices[entity.ID] = append(indices[entity.ID], entity)\n\t\tvalues = append(values, entity.ID)\n\t\tc++\n\t}\n\tplaceholder = strings.TrimRight(placeholder, \",\")\n\n\trows, err := repo.db.Query(`\n\t\tSELECT j.{{.ThisID}}, {{.SQLFields}} FROM {{.ThatTable}} t \n\t\tINNER JOIN {{.JoinTable}} j ON t.id = j.{{.ThatID}}\n\t\tWHERE j.{{.ThisID}} IN (`+placeholder+`)\n\t`, values...)\n\tif err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif err = util.CheckContext(ctx); err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\n\tfor rows.Next() {\n\t\tvar (\n\t\t\tthisID {{.ThisType}}\n\t\t\tentity {{.ThatEntity}}\n\t\t)\n\t\t{{range .Before}}{{.}}\n\t\t{{end}}\n\t\terr = rows.Scan(&thisID, {{.StructFields}})\n\t\tif err != nil {\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t\t{{range .After}}{{.}}\n\t\t{{end}}\n\t\t\n\t\tfor i := range indices[thisID] {\n\t\t\tindices[thisID][i].{{.PropertyName}} = append(indices[thisID][i].{{.PropertyName}}, &entity)\n\t\t}\n\t\t\n\t\tif err = util.CheckContext(ctx); err != nil {\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t}\n\n\treturn nil\n}"),
	}
	fileq := &embedded.EmbeddedFile{
		Filename:    "crud/partials/loadrelated_manyone.go.tmpl",
		FileModTime: time.Unix(1533709790, 0),
		Content:     string("\n// Load{{.Funcname}} is a helper function to load related {{.PropertyName}} entities\nfunc (repo {{.ThisEntity}}Repositorium) Load{{.Funcname}}(ctx context.Context, entities ...*{{.ThisEntity}}) error {\n\tvar (\n\t\terr error\n\t\tplaceholder string\n\t\tvalues  []interface{}\n\t\tindices = make(map[{{.ThatType}}][]*{{.ThisEntity}})\n\t)\n\n\tif err = util.CheckContext(ctx); err != nil {\n\t\treturn errors.WithStack(err)\n\t} else if len(entities) == 0 {\n\t\treturn nil\n\t}\n\n\tc := 1\n\tfor _, entity := range entities {\n\t\tplaceholder += \"$\" + strconv.Itoa(c) + \",\"\n\t\tindices[entity.{{.ThisID}}] = append(indices[entity.{{.ThisID}}], entity)\n\t\tvalues = append(values, entity.{{.ThisID}})\n\t\tc++\n\t}\n\tplaceholder = strings.TrimRight(placeholder, \",\")\n\trows, err := repo.db.Query(`\n\t\tSELECT t.\"id\", {{.SQLFields}} FROM {{.ThatTable}} t WHERE t.\"id\" IN (`+placeholder+`)\n\t`, values...)\n\tif err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif err = util.CheckContext(ctx); err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\n\tfor rows.Next() {\n\t\tvar (\n\t\t\tthatID {{.ThatType}}\n\t\t\tthatEntity {{.ThatEntity}}\n\t\t)\n\t\t{{range .Before}}{{.}}\n\t\t{{end}}\n\t\terr = rows.Scan(&thatID, {{.StructFields}})\n\t\tif err != nil {\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t\t{{range .After}}{{.}}\n\t\t{{end}}\n\n\t\tfor i := range indices[thatID] {\n\t\t\tindices[thatID][i].{{.PropertyName}} = &thatEntity\n\t\t}\n\t\t\n\t\tif err = util.CheckContext(ctx); err != nil {\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t}\n\n\treturn nil\n}\n"),
	}
	filer := &embedded.EmbeddedFile{
		Filename:    "crud/partials/loadrelated_onemany.go.tmpl",
		FileModTime: time.Unix(1533713685, 0),
		Content:     string("\n// Load{{.Funcname}} is a helper function to load related {{.PropertyName}} entities\nfunc (repo {{.ThisEntity}}Repositorium) Load{{.Funcname}}(ctx context.Context, entities ...*{{.ThisEntity}}) error {\n\tvar (\n\t\terr error\n\t\tplaceholder string\n\t\tvalues  []interface{}\n\t\tindices = make(map[{{.ThisType}}][]*{{.ThisEntity}})\n\t)\n\n\tif err = util.CheckContext(ctx); err != nil {\n\t\treturn errors.WithStack(err)\n\t} else if len(entities) == 0 {\n\t\treturn nil\n\t}\n\n\tc := 1\n\tfor _, entity := range entities {\n\t\tplaceholder += \"$\" + strconv.Itoa(c) + \",\"\n\t\tindices[entity.ID] = append(indices[entity.ID], entity)\n\t\tvalues = append(values, entity.ID)\n\t\tc++\n\t}\n\tplaceholder = strings.TrimRight(placeholder, \",\")\n\n\trows, err := repo.db.Query(`\n\t\tSELECT t.\"{{.ThisID}}\", {{.SQLFields}} FROM {{.ThatTable}} t WHERE t.\"{{.ThisID}}\" IN (`+placeholder+`)\n\t`, values...)\n\tif err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif err = util.CheckContext(ctx); err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\n\tfor rows.Next() {\n\t\tvar (\n\t\t\tthisID {{.ThisType}}\n\t\t\tentity {{.ThatEntity}}\n\t\t)\n\t\t\n\t\t{{range .Before}}{{.}}\n\t\t{{end}}\n\t\terr = rows.Scan(&thisID, {{.StructFields}})\n\t\tif err != nil {\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t\t{{range .After}}{{.}}\n\t\t{{end}}\n\t\t\n\t\tfor i := range indices[thisID] {\n\t\t\tindices[thisID][i].{{.PropertyName}} = append(indices[thisID][i].{{.PropertyName}}, &entity)\n\t\t}\n\t\t\n\t\tif err = util.CheckContext(ctx); err != nil {\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t}\n\n\treturn nil\n}\n"),
	}
	files := &embedded.EmbeddedFile{
		Filename:    "crud/partials/merge.go.tmpl",
		FileModTime: time.Unix(1534795470, 0),
		Content:     string("\n// Merge performs an SQL merge for {{.EntityName}} record.\nfunc (repo {{.EntityName}}Repositorium) Merge(ctx context.Context, entity *{{.EntityName}}, tx *sql.Tx, autocommit bool) error {\n\tvar (\n\t\terr error\n\t\tstmt *sql.Stmt\n\t)\n\n\tif tx == nil {\n\t\tif err = util.CheckContext(ctx); err != nil {\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t\t\n\t\ttx, err = repo.db.Begin()\n\t\tif err != nil {\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t}\n\n\tif entity.ID == {{pkeyPropertyEmptyVal .PrimaryKey}} {\n\t\treturn {{.EntityName}}Repo.Insert(ctx, entity, tx, autocommit)\n\t}\n\n\t{{range .Before}}{{.}}\n\t{{end}}\n\n\tstmt, err = tx.Prepare(`INSERT INTO {{.Table}} ({{.SQLFieldsInsert}}) VALUES ({{.SQLPlaceholders}}) \n\tON CONFLICT (id) DO UPDATE SET {{.SQLFieldsUpdate}}`)\n\tif err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif err = util.CheckContext(ctx); err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\t{{if .HasPreHook}}\n    if err = repo.preSave(ctx, tx, models.OperationMerge, entity); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t{{end}}\n\n\tif err = util.CheckContext(ctx); err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\t_, err = stmt.Exec({{.StructFields}})\n\tif err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\t{{if .HasPostHook}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\tif err = repo.postSave(ctx, \"MERGE\", entity, tx); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t{{end}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif autocommit {\n\t\terr = tx.Commit()\n\t\tif err != nil {\n\t\t\ttx.Rollback()\n\t\t}\n\t}\n\n\treturn errors.WithStack(err)\n}\n\n// MergeWithRel performs an SQL merge for {{.EntityName}} record.\nfunc (repo {{.EntityName}}Repositorium) MergeWithRel(ctx context.Context, entity *{{.EntityName}}, tx *sql.Tx, autocommit bool) error {\n\tvar (\n\t\terr error\n\t\tstmt *sql.Stmt\n\t)\n\n\tif tx == nil {\n\t\tif err = util.CheckContext(ctx); err != nil {\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t\t\n\t\ttx, err = repo.db.Begin()\n\t\tif err != nil {\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t}\n\n\tif entity.ID == {{pkeyPropertyEmptyVal .PrimaryKey}} {\n\t\treturn {{.EntityName}}Repo.Insert(ctx, entity, tx, autocommit)\n\t}\n\n\t{{range .Before}}{{.}}\n\t{{end}}\n\n\tstmt, err = tx.Prepare(`INSERT INTO {{.Table}} ({{.SQLFieldsInsert}}) VALUES ({{.SQLPlaceholders}}) \n\tON CONFLICT (id) DO UPDATE SET {{.SQLFieldsUpdate}}`)\n\tif err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif err = util.CheckContext(ctx); err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\t{{if .HasPreHook}}\n    if err = repo.preSave(ctx, tx, models.OperationMerge, entity); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t{{end}}\n\n\tif err = util.CheckContext(ctx); err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\t_, err = stmt.Exec({{.StructFields}})\n\tif err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\t{{range $i, $r := .Related}}{{$r}}\n\tif err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t{{if ne (plus1 $i) (len $.Related)}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t{{end}}\n\t{{end}}\n\n\t{{if .HasPostHook}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\tif err = repo.postSave(ctx, \"MERGE\", entity, tx); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t{{end}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif autocommit {\n\t\terr = tx.Commit()\n\t\tif err != nil {\n\t\t\ttx.Rollback()\n\t\t}\n\t}\n\n\treturn errors.WithStack(err)\n}\n"),
	}
	filet := &embedded.EmbeddedFile{
		Filename:    "crud/partials/save.go.tmpl",
		FileModTime: time.Unix(1530772658, 0),
		Content:     string("\n// Save either inserts or updates a {{.EntityName}} record based on whether or not id is nil\nfunc (repo {{.EntityName}}Repositorium) Save(ctx context.Context, entity *{{.EntityName}}, tx *sql.Tx, autocommit bool) error {\n\t{{if pkeyIsAuto .PrimaryKey -}}\n\tif entity.ID == {{pkeyPropertyEmptyVal .PrimaryKey}} {\n\t\treturn repo.Insert(ctx, entity, tx, autocommit)\n\t}\n\treturn repo.Update(ctx, entity, tx, autocommit)\n\t{{- else -}}\n\tif entity.ID == {{pkeyPropertyEmptyVal .PrimaryKey}} {\n\t\treturn entity, errors.New(\"primary key cannot be nil\")\n\t}\n\treturn repo.Merge(ctx, entity, tx, autocommit)\n\t{{end -}}\n}\n\n// SaveWithRel either inserts or updates a {{.EntityName}} record based on whether or not id is nil; will also save related entities\nfunc (repo {{.EntityName}}Repositorium) SaveWithRel(ctx context.Context, entity *{{.EntityName}}, tx *sql.Tx, autocommit bool) error {\n\t{{if pkeyIsAuto .PrimaryKey -}}\n\tif entity.ID == {{pkeyPropertyEmptyVal .PrimaryKey}} {\n\t\treturn repo.InsertWithRel(ctx, entity, tx, autocommit)\n\t}\n\treturn repo.UpdateWithRel(ctx, entity, tx, autocommit)\n\t{{- else -}}\n\tif entity.ID == {{pkeyPropertyEmptyVal .PrimaryKey}} {\n\t\treturn entity, errors.New(\"primary key cannot be nil\")\n\t}\n\treturn repo.MergeWithRel(ctx, entity, tx, autocommit)\n\t{{end -}}\n}"),
	}
	fileu := &embedded.EmbeddedFile{
		Filename:    "crud/partials/saverelated_manymany.go.tmpl",
		FileModTime: time.Unix(1534795470, 0),
		Content:     string("\n// Save{{.Funcname}} is a helper function to save related {{.PropertyName}} in a pivot table (many-many relationship)\nfunc (repo {{.EntityName}}Repositorium) Save{{.Funcname}}(ctx context.Context, tx *sql.Tx, autocommit bool, idthis {{pkeyPropertyType .PrimaryKey}}, relatives ...{{.ThatType}}) error {\n\tvar (\n\t\tstmt *sql.Stmt\n\t\terr  error\n\t)\n\n\tif tx == nil {\n\t\tif err = util.CheckContext(ctx); err != nil {\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\n\t\ttx, err = repo.db.Begin()\n\t\tif err != nil {\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t}\n\n\tstmt, err = tx.Prepare(\"DELETE FROM {{.Table}} WHERE {{.ThatColumn}} = $1\")\n\tif err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\n\t_, err = stmt.Exec(idthis)\n\tif err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif err = util.CheckContext(ctx); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\tstmt, err = tx.Prepare(\"INSERT INTO {{.Table}} ({{.ThatColumn}}, {{.ThisColumn}}) VALUES ($1, $2)\")\n\tif err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\n\tfor _, rel := range relatives {\n\t\tif err = util.CheckContext(ctx); err != nil {\n\t\t\ttx.Rollback()\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\n\t\t_, err = stmt.Exec(idthis, rel.ID)\n\t\tif err != nil {\n\t\t\ttx.Rollback()\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t}\n\n\tif autocommit {\n\t\terr = tx.Commit()\n\t\tif err != nil {\n\t\t\ttx.Rollback()\n\t\t}\n\t}\n\n\treturn errors.WithStack(err)\n}\n\n// Save{{.Funcname}}IDs is a helper function to save related {{.PropertyName}} IDs in a pivot table (many-many relationship)\nfunc (repo {{.EntityName}}Repositorium) Save{{.Funcname}}IDs(ctx context.Context, tx *sql.Tx, autocommit bool, idthis {{pkeyPropertyType .PrimaryKey}}, relatives ...{{pkeyPropertyType .ThatPrimaryKey}}) error {\n\tvar (\n\t\tstmt *sql.Stmt\n\t\terr  error\n\t)\n\n\tif tx == nil {\n\t\tif err = util.CheckContext(ctx); err != nil {\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\n\t\ttx, err = repo.db.Begin()\n\t\tif err != nil {\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t}\n\t\n\tstmt, err = tx.Prepare(\"DELETE FROM {{.Table}} WHERE {{.ThatColumn}} = $1\")\n\tif err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\n\t_, err = stmt.Exec(idthis)\n\tif err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif err = util.CheckContext(ctx); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\tstmt, err = tx.Prepare(\"INSERT INTO {{.Table}} ({{.ThatColumn}}, {{.ThisColumn}}) VALUES ($1, $2)\")\n\tif err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\n\tfor _, relid := range relatives {\n\t\tif err = util.CheckContext(ctx); err != nil {\n\t\t\ttx.Rollback()\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\n\t\t_, err = stmt.Exec(idthis, relid)\n\t\tif err != nil {\n\t\t\ttx.Rollback()\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t}\n\n\tif autocommit {\n\t\terr = tx.Commit()\n\t\tif err != nil {\n\t\t\ttx.Rollback()\n\t\t}\n\t}\n\n\treturn errors.WithStack(err)\n}\n"),
	}
	filev := &embedded.EmbeddedFile{
		Filename:    "crud/partials/saverelated_onemany.go.tmpl",
		FileModTime: time.Unix(1534795470, 0),
		Content:     string("\n// Save{{.Funcname}} is a helper function to save related {{.PropertyName}} (one-many relationship)\nfunc (repo {{.EntityName}}Repositorium) Save{{.Funcname}}(ctx context.Context, tx *sql.Tx, autocommit bool, idthis {{pkeyPropertyType .PrimaryKey}}, relatives ...{{.ThatType}}) error {\n\tvar (\n\t\tstmt *sql.Stmt\n\t\terr  error\n\t)\n\n\tif tx == nil {\n\t\tif err = util.CheckContext(ctx); err != nil {\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\n\t\ttx, err = repo.db.Begin()\n\t\tif err != nil {\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t}\n\n\tstmt, err = tx.Prepare(\"UPDATE {{.Table}} SET {{.ThatColumn}} = $1 WHERE {{.ThisColumn}} = $2\")\n\tif err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\n\tfor _, rel := range relatives {\n\t\tif err = util.CheckContext(ctx); err != nil {\n\t\t\ttx.Rollback()\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\n\t\t_, err = stmt.Exec(idthis, rel.ID)\n\t\tif err != nil {\n\t\t\ttx.Rollback()\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t}\n\n\tif autocommit {\n\t\terr = tx.Commit()\n\t\tif err != nil {\n\t\t\ttx.Rollback()\n\t\t}\n\t}\n\n\treturn errors.WithStack(err)\n}\n"),
	}
	filew := &embedded.EmbeddedFile{
		Filename:    "crud/partials/update.go.tmpl",
		FileModTime: time.Unix(1534795470, 0),
		Content:     string("\n// Update Will execute an SQLUpdate Statement for {{.EntityName}} in the database. Prefer using Save instead of Update directly.\nfunc (repo {{.EntityName}}Repositorium) Update(ctx context.Context, entity *{{.EntityName}}, tx *sql.Tx, autocommit bool) error {\n\tvar (\n\t\terr error\n\t\tstmt *sql.Stmt\n\t)\n\n\tif tx == nil {\n\t\tif err = util.CheckContext(ctx); err != nil {\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\n\t\ttx, err = repo.db.Begin()\n\t\tif err != nil {\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t}\n\t\n\t{{range .Before}}{{.}}\n\t{{end}}\n\n\tstmt, err = tx.Prepare(`UPDATE {{.Table}} SET {{.SQLFields}} WHERE id = $1`)\n\tif err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\n\t{{range .After}}{{.}}\n\t{{end}}\n\n\t{{if .HasPreHook}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\n    if err = repo.preSave(ctx, tx, models.OperationUpdate, entity); err != nil {\n\t\ttx.Rollback()\n        return errors.WithStack(err)\n\t}\n\t{{end}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t_, err = stmt.Exec({{.StructFields}})\n\tif err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\t{{if .HasPostHook}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif err = repo.postSave(ctx, \"UPDATE\", entity, tx); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t{{end}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif autocommit {\n\t\terr = tx.Commit()\n\t\tif err != nil {\n\t\t\ttx.Rollback()\n\t\t}\n\t}\n\n\treturn errors.WithStack(err)\n}\n\n// UpdateWithRel Will execute an SQLUpdate Statement for {{.EntityName}} in the database; including related entities. Prefer using Save instead of Update directly.\nfunc (repo {{.EntityName}}Repositorium) UpdateWithRel(ctx context.Context, entity *{{.EntityName}}, tx *sql.Tx, autocommit bool) error {\n\tvar (\n\t\terr error\n\t\tstmt *sql.Stmt\n\t)\n\n\tif tx == nil {\n\t\tif err = util.CheckContext(ctx); err != nil {\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\n\t\ttx, err = repo.db.Begin()\n\t\tif err != nil {\n\t\t\treturn errors.WithStack(err)\n\t\t}\n\t}\n\t\n\t{{range .Before}}{{.}}\n\t{{end}}\n\n\tstmt, err = tx.Prepare(`UPDATE {{.Table}} SET {{.SQLFields}} WHERE id = $1`)\n\tif err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\n\t{{range .After}}{{.}}\n\t{{end}}\n\n\t{{if .HasPreHook}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\n    if err = repo.preSave(ctx, tx, models.OperationUpdate, entity); err != nil {\n\t\ttx.Rollback()\n        return errors.WithStack(err)\n\t}\n\t{{end}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t_, err = stmt.Exec({{.StructFields}})\n\tif err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\t{{range $i, $r := .Related}}{{$r}}\n\tif err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t{{if ne (plus1 $i) (len $.Related)}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t{{end}}\n\t{{end}}\n\n\t{{if .HasPostHook}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif err = repo.postSave(ctx, \"UPDATE\", entity, tx); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\t{{end}}\n\tif err = util.CheckContext(ctx); err != nil {\n\t\ttx.Rollback()\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif autocommit {\n\t\terr = tx.Commit()\n\t\tif err != nil {\n\t\t\ttx.Rollback()\n\t\t}\n\t}\n\n\treturn errors.WithStack(err)\n}\n"),
	}
	filex := &embedded.EmbeddedFile{
		Filename:    "crud/protobuf.proto.tmpl",
		FileModTime: time.Unix(1534420769, 0),
		Content:     string("syntax = \"proto3\";\n\npackage models;\noption go_package = \"{{.AppImportPath}}/models\";\n\n{{range .Imports -}}\n{{.}}\n{{- end}}\n\nmessage ListOpts {\n\tint64 Offset = 1;\n\tint64 Limit = 2;\n\tstring Sort = 3;\n}\n\n{{ range .Entities -}}\n// {{.Name}} {{.Description}}\nmessage {{.Name}} { {{ range .Fields }}\n\t{{.Type}} {{.Name}} = {{.Index}};\n{{- end}}\n}\n\n{{end}}\n"),
	}
	filey := &embedded.EmbeddedFile{
		Filename:    "http.go.tmpl",
		FileModTime: time.Unix(1528714907, 0),
		Content:     string("package app\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\n\t\"github.com/gorilla/mux\"\n)\n\n// ServeHTTP starts an http server\nfunc ServeHTTP(listen string, route func(router *mux.Router) error) {\n\tvar err error\n\tsigs := make(chan os.Signal, 1)\n\tsignal.Notify(sigs, syscall.SIGTERM)\n\n\trouter := mux.NewRouter()\n\terr = route(router)\n\n\tif err != nil {\n\t\tlog.Fatal(\"Failed to register routes: \", err)\n\t}\n\n\tgo func() {\n\t\terr = http.ListenAndServe(listen, router)\n\t\tif err != nil {\n\t\t\tlog.Fatal(\"Failed to start http server: \", err)\n\t\t}\n\t}()\n\n\tlog.Println(\"Listening on \" + listen)\n\t<-sigs\n\tlog.Println(\"Server stopped\")\n}\n"),
	}
	filez := &embedded.EmbeddedFile{
		Filename:    "rest.go.tmpl",
		FileModTime: time.Unix(1528714907, 0),
		Content:     string("package {{.Package}}\nimport (\n\t\"database/sql\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strconv\"\n\n\t\"github.com/gorilla/mux\"\n)\n\ntype responseSingle struct {\n\tStatus   bool      `json:\"status\"`\n\tMessages []message `json:\"messages\"`\n\tEntity   *{{.Entity.Name}} `json:\"entity\"`\n}\n\ntype responseList struct {\n\tStatus   bool                `json:\"status\"`\n\tMessages []message           `json:\"messages\"`\n\tEntities []*{{.Entity.Name}} `json:\"entities\"`\n}\n\ntype message struct {\n\tType    rune   `json:\"type\"`\n\tMessage string `json:\"message\"`\n}\n\n//RegisterRoutes registers routes with a mux Router\nfunc RegisterRoutes(router *mux.Router) {\n\t{{if .Entity.Rest.Read}}router.HandleFunc(\"/{{.Endpoint}}/{id}\", RestGet).Methods(\"GET\"){{end}}\n\t{{if .Entity.Rest.ReadList}}router.HandleFunc(\"/{{.Endpoint}}\", RestList).Methods(\"GET\"){{end}}\n\t{{if .Entity.Rest.Create}}router.HandleFunc(\"/{{.Endpoint}}\", RestCreate).Methods(\"POST\"){{end}}\n\t{{if .Entity.Rest.Update}}router.HandleFunc(\"/{{.Endpoint}}/{id}\", RestUpdate).Methods(\"PUT\"){{end}}\n\t{{if .Entity.Rest.Delete}}router.HandleFunc(\"/{{.Endpoint}}/{id}\", RestDelete).Methods(\"DELETE\"){{end}}\n}\n\n{{if .Entity.Rest.Read}}\n//RestGet is a REST endpoint for GET /{{.Endpoint}}/{id}\nfunc RestGet(w http.ResponseWriter, r *http.Request) {\n\tvar (\n\t\tid       {{pkeyPropertyType .Entity.PrimaryKey}}\n\t\terr      error\n\t\tresponse responseSingle\n\t\t{{if or .Entity.Rest.Hooks.PreRead .Entity.Rest.Hooks.PostRead -}}\n\t\tstop     bool\n\t\t{{- end}}\n\t)\n\n\tvars := mux.Vars(r)\n\t{{if pkeyIsInt .Entity.PrimaryKey -}}\n\tvalid := false\n\tif _, ok := vars[\"id\"]; ok {\n\t\tid, err = strconv.ParseInt(vars[\"id\"], 10, 64)\n\t\tvalid = err == nil && id > 0\n\t}\n\t{{else}}\n\tid, valid := vars[\"id\"]\n\t{{- end}}\n\n\tif !valid {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\tfmt.Fprint(w, `{\"status\": false, \"messages\": [{\"type\": \"error\", \"text\": \"Invalid ID\"}]}`)\n\t\treturn\n\t}\n\n\t{{if .Entity.Rest.Hooks.PreRead}}\n    if stop, err = restPreGet(w, r, id); err != nil || stop {\n        return\n    }\n    {{end}}\n\n\tresponse.Entity, err = Get(id)\n\tif err != nil {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprint(w, `{\"status\": false, \"messages\": [{\"type\": \"error\", \"text\": \"An error occurred\"}]}`)\n\t\treturn\n\t}\n\n\tif response.Entity == nil {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprint(w, `{\"status\": false, \"messages\": [{\"type\": \"error\", \"text\": \"Entity not found\"}]}`)\n\t\treturn\n\t}\n\n\t{{if .Entity.Rest.Hooks.PostRead}}\n    if stop, err = restPostGet(w, r, response.Entity); err != nil || stop {\n        return\n    }\n    {{end}}\n\n\tresponse.Status = true\n\tresponse.Status = true\t\n\toutput, err := json.Marshal(response)\n\tif err != nil {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprint(w, `{\"status\": false, \"messages\": [{\"type\": \"error\", \"text\": \"JSON encoding failed\"}]}`)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprint(w, string(output))\n}\n{{end}}\n\n{{if .Entity.Rest.ReadList}}\n//RestList is a REST endpoint for GET /{{.Endpoint}}\nfunc RestList(w http.ResponseWriter, r *http.Request) {\n\tvar (\n\t\terr      error\n\t\tresponse responseList\n\t\tfilters  []models.ListFilter\n\t\t{{if or .Entity.Rest.Hooks.PreList .Entity.Rest.Hooks.PostList}}stop     bool{{end}}\n\t)\n\t{{range .Entity.Fields}}{{if .Filterable}}\n\t{{if eq .Property.Type \"bool\"}}\n\tif val := query.Get(\"{{.Serialized}}\"); val != \"\" {\n\t\tif t, e := strconv.ParseBool(val); e == nil {\n\t\t\tfilters = append(filters, models.ListFilter{Field:\"{{.Schema.Field}}\", Operation:\"=\", Value:t})\n\t\t}\n\t}\n\t{{end}}\n\t{{if eq .Property.Type \"string\"}}\n\tif val := query.Get(\"{{.Serialized}}\"); val != \"\" {\n\t\tfilters = append(filters, models.ListFilter{Field:\"{{.Schema.Field}}\", Operation:\"=\", Value:val})\n\t}\n\n\tif val := query.Get(\"{{.Serialized}}-lk\"); val != \"\" {\n\t\tfilters = append(filters, models.ListFilter{Field:\"{{.Schema.Field}}\", Operation:\"LIKE\", Value:\"%\" + val + \"%\"})\n\t}\n\t{{end}}\n\t{{if eq .Property.Type \"time.Time\"}}\n\tif val := query.Get(\"{{.Serialized}}\"); len(val) == 16 {\n\t\tif t, e := time.Parse(\"2006-01-02-15-04\", val); e == nil {\n\t\t\tfilters = append(filters, models.ListFilter{Field:\"{{.Schema.Field}}\", Operation:\"=\", Value:t})\n\t\t}\n\t}\n\n\tif val := query.Get(\"{{.Serialized}}-gt\"); len(val) == 16 {\n\t\tif t, e := time.Parse(\"2006-01-02-15-04\", val); e == nil {\n\t\t\tfilters = append(filters, models.ListFilter{Field:\"{{.Schema.Field}}\", Operation:\">\", Value:t})\n\t\t}\n\t}\n\n\tif val := query.Get(\"{{.Serialized}}-ge\"); len(val) == 16 {\n\t\tif t, e := time.Parse(\"2006-01-02-15-04\", val); e == nil {\n\t\t\tfilters = append(filters, models.ListFilter{Field:\"{{.Schema.Field}}\", Operation:\">=\", Value:t})\n\t\t}\n\t}\n\n\tif val := query.Get(\"{{.Serialized}}-lt\"); len(val) == 16 {\n\t\tif t, e := time.Parse(\"2006-01-02-15-04\", val); e == nil {\n\t\t\tfilters = append(filters, models.ListFilter{Field:\"{{.Schema.Field}}\", Operation:\"<\", Value:t})\n\t\t}\n\t}\n\n\tif val := query.Get(\"{{.Serialized}}-le\"); len(val) == 16 {\n\t\tif t, e := time.Parse(\"2006-01-02-15-04\", val); e == nil {\n\t\t\tfilters = append(filters, models.ListFilter{Field:\"{{.Schema.Field}}\", Operation:\"<=\", Value:t})\n\t\t}\n\t}\n\t{{end}}\n\t{{end}}{{end}}\n\n\t{{if .Entity.Rest.Hooks.PreList}}\n    if filters, stop, err = restPreList(w, r, filters); err != nil || stop {\n        return\n    }\n    {{end}}\n\n\tresponse.Entities, err = List(filters)\n\tif err != nil {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprint(w, `{\"status\": false, \"messages\": [{\"type\": \"error\", \"text\": \"An error occurred\"}]}`)\n\t\treturn\n\t}\n\n\t{{if .Entity.Rest.Hooks.PostList}}\n    if response.Entities, stop, err = restPostList(w, r, response.Entities); err != nil || stop {\n        return\n    }\n    {{end}}\n\n\tresponse.Status = true\n\tresponse.Status = true\t\n\toutput, err := json.Marshal(response)\n\tif err != nil {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprint(w, `{\"status\": false, \"messages\": [{\"type\": \"error\", \"text\": \"JSON encoding failed\"}]}`)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprint(w, string(output))\n}\n{{end}}\n\n{{if .Entity.Rest.Create}}\n//RestCreate is a REST endpoint for POST /{{.Endpoint}}\nfunc RestCreate(w http.ResponseWriter, r *http.Request) {\n\tvar (\n\t\terr      error\n\t\trawbody  []byte\n\t\tresponse responseSingle\n\t\ttx       *sql.Tx\n\t\t{{if or .Entity.Rest.Hooks.PreCreate .Entity.Rest.Hooks.PostCreate}}stop     bool{{end}}\n\t)\n\n\trawbody, err = ioutil.ReadAll(r.Body)\n\tif err != nil {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\tfmt.Fprint(w, `{\"status\": false, \"messages\": [{\"type\": \"error\", \"text\": \"Failed to read body\"}]}`)\n\t\treturn\n\t}\n\n\tresponse.Entity = New()\n\terr = json.Unmarshal(rawbody, response.Entity)\n\tif err != nil {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\tfmt.Fprint(w, `{\"status\": false, \"messages\": [{\"type\": \"error\", \"text\": \"Failed to decode body\"}]}`)\n\t\treturn\n\t}\n\t{{if pkeyIsAuto .Entity.PrimaryKey -}}\n\tresponse.Entity.ID = nil\n\t{{- end}}\n\n\ttx, err = db.Begin()\n\tif err != nil {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprint(w, `{\"status\": false, \"messages\": [{\"type\": \"error\", \"text\": \"Failed to process\"}]}`)\n\t\treturn\n\t}\n\n\t{{if .Entity.Rest.Hooks.PreCreate}}\n\tif stop, err = restPreCreate(w, r, response.Entity, tx); err != nil {\n\t\ttx.Rollback()\n\t\treturn\n\t} else if stop {\n\t\treturn\n\t}\n\t{{end}}\n\n\terr = response.Entity.Save(tx, false)\n\tif err != nil {\n\t\ttx.Rollback()\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprint(w, `{\"status\": false, \"messages\": [{\"type\": \"error\", \"text\": \"Save failed\"}]}`)\n\t\treturn\n\t}\n\n\t{{if .Entity.Rest.Hooks.PostCreate}}\n\tif stop, err = restPostCreate(w, r, response.Entity, tx); err != nil {\n\t\ttx.Rollback()\n\t\treturn\n\t} else if stop {\n\t\treturn\n\t}\n\t{{end}}\n\t\n\tif err = tx.Commit(); err != nil {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\tfmt.Fprint(w, `{\"status\": false, \"messages\": [{\"type\": \"E\", \"message\": \"RestCreate could not commit transaction\"}]}`)\n\t\treturn\n\t}\n\n\tresponse.Status = true\t\n\toutput, err := json.Marshal(response)\n\tif err != nil {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprint(w, `{\"status\": false, \"messages\": [{\"type\": \"error\", \"text\": \"JSON encoding failed\"}]}`)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprint(w, string(output))\n}\n{{end}}\n\n{{if .Entity.Rest.Update}}\n//RestUpdate is a REST endpoint for PUT /{{.Endpoint}}/{id}\nfunc RestUpdate(w http.ResponseWriter, r *http.Request) {\n\tvar (\n\t\terr      error\n\t\trawbody  []byte\n\t\tid       {{pkeyPropertyType .Entity.PrimaryKey}}\n\t\tresponse responseSingle\n\t\ttx       *sql.Tx\n\t\t{{if or .Entity.Rest.Hooks.PreUpdate .Entity.Rest.Hooks.PostUpdate -}}\n\t\tstop     bool\n\t\t{{- end}}\n\t)\n\n\tvars := mux.Vars(r)\n\t{{if pkeyIsInt .Entity.PrimaryKey -}}\n\tvalid := false\n\tif _, ok := vars[\"id\"]; ok {\n\t\tid, err = strconv.ParseInt(vars[\"id\"], 10, 64)\n\t\tvalid = err == nil && id > 0\n\t}\n\t{{else}}\n\tid, valid := vars[\"id\"]\n\t{{- end}}\n\n\tif !valid {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\tfmt.Fprint(w, `{\"status\": false, \"messages\": [{\"type\": \"error\", \"text\": \"Invalid ID\"}]}`)\n\t\treturn\n\t}\n\n\tresponse.Entity, err = Get(id)\n\tif err != nil {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprint(w, `{\"status\": false, \"messages\": [{\"type\": \"error\", \"text\": \"An error occurred\"}]}`)\n\t\treturn\n\t}\n\n\tif response.Entity == nil {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprint(w, `{\"status\": false, \"messages\": [{\"type\": \"error\", \"text\": \"Entity not found\"}]}`)\n\t\treturn\n\t}\n\n\trawbody, err = ioutil.ReadAll(r.Body)\n\tif err != nil {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\tfmt.Fprint(w, `{\"status\": false, \"messages\": [{\"type\": \"error\", \"text\": \"Failed to read body\"}]}`)\n\t\treturn\n\t}\n\n\terr = json.Unmarshal(rawbody, response.Entity)\n\tif err != nil {\n\t\tif err != nil {\n\t\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\t\tw.WriteHeader(http.StatusBadRequest)\n\t\t\tfmt.Fprint(w, `{\"status\": false, \"messages\": [{\"type\": \"error\", \"text\": \"Failed to decode body\"}]}`)\n\t\t\treturn\n\t\t}\n\t}\n\tresponse.Entity.ID = &id\n\n\ttx, err = db.Begin()\n\tif err != nil {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprint(w, `{\"status\": false, \"messages\": [{\"type\": \"error\", \"text\": \"Failed to process\"}]}`)\n\t\treturn\n\t}\n\n\t{{if .Entity.Rest.Hooks.PreUpdate}}\n    if stop, err = restPreUpdate(w, r, response.Entity, tx); err != nil {\n\t\ttx.Rollback()\n        return\n    } else if stop {\n\t\treturn\n\t}\n    {{end}}\n\n\terr = response.Entity.Save(tx, false)\n\tif err != nil {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprint(w, `{\"status\": false, \"messages\": [{\"type\": \"error\", \"text\": \"Save failed\"}]}`)\n\t\treturn\n\t}\n\n\t{{if .Entity.Rest.Hooks.PostUpdate}}\n    if stop, err = restPostUpdate(w, r, response.Entity, tx); err != nil {\n\t\ttx.Rollback()\n        return\n    } else if stop {\n\t\treturn\n\t}\n\t{{end}}\n\t\n\tif err = tx.Commit(); err != nil {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\tfmt.Fprint(w, `{\"status\": false, \"messages\": [{\"type\": \"E\", \"message\": \"RestUpdate could not commit transaction\"}]}`)\n\t\treturn\n\t}\n\n\tresponse.Status = true\t\n\toutput, err := json.Marshal(response)\n\tif err != nil {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprint(w, `{\"status\": false, \"messages\": [{\"type\": \"error\", \"text\": \"JSON encoding failed\"}]}`)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprint(w, string(output))\n}\n{{end}}\n\n{{if .Entity.Rest.Delete}}\n//RestDelete is a REST endpoint for DELETE /{{.Endpoint}}/{id}\nfunc RestDelete(w http.ResponseWriter, r *http.Request) {\n\tvar (\n\t\tid       {{pkeyPropertyType .Entity.PrimaryKey}}\n\t\terr      error\n\t\tresponse responseSingle\n\t\ttx       *sql.Tx\n\t\t{{if or .Entity.Rest.Hooks.PreDelete .Entity.Rest.Hooks.PostDelete -}}\n\t\tstop     bool\n\t\t{{- end}}\n\t)\n\n\tvars := mux.Vars(r)\n\t{{if pkeyIsInt .Entity.PrimaryKey -}}\n\tvalid := false\n\tif _, ok := vars[\"id\"]; ok {\n\t\tid, err = strconv.ParseInt(vars[\"id\"], 10, 64)\n\t\tvalid = err == nil && id > 0\n\t}\n\t{{else}}\n\tid, valid := vars[\"id\"]\n\t{{- end}}\n\n\tif !valid {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\tfmt.Fprint(w, `{\"status\": false, \"messages\": [{\"type\": \"error\", \"text\": \"Invalid ID\"}]}`)\n\t\treturn\n\t}\n\n\tresponse.Entity, err = Get(id)\n\tif err != nil {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprint(w, `{\"status\": false, \"messages\": [{\"type\": \"error\", \"text\": \"An error occurred\"}]}`)\n\t\treturn\n\t}\n\n\tif response.Entity == nil {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusNotFound)\n\t\tfmt.Fprint(w, `{\"status\": false, \"messages\": [{\"type\": \"error\", \"text\": \"Entity not found\"}]}`)\n\t\treturn\n\t}\n\n\ttx, err = db.Begin()\n\tif err != nil {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprint(w, `{\"status\": false, \"messages\": [{\"type\": \"error\", \"text\": \"Failed to process\"}]}`)\n\t\treturn\n\t}\n\t{{if .Entity.Rest.Hooks.PreDelete}}\n\tif stop, err = restPreDelete(w, r, id, tx); err != nil {\n\t\ttx.Rollback()\n\t\treturn\n\t} else if stop {\n\t\treturn\n\t}\n    {{end}}\n\terr = response.Entity.Delete(tx, false)\n\tif err != nil {\n\t\ttx.Rollback()\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprint(w, `{\"status\": false, \"messages\": [{\"type\": \"error\", \"text\": \"Delete failed\"}]}`)\n\t\treturn\n\t}\n\t{{if .Entity.Rest.Hooks.PostDelete}}\n\tif stop, err = restPostDelete(w, r, id, tx); err != nil {\n\t\ttx.Rollback()\n\t\treturn\n\t} else if stop {\n\t\treturn\n\t}\n\t{{end}}\n\tif err = tx.Commit(); err != nil {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\tfmt.Fprint(w, `{\"status\": false, \"messages\": [{\"type\": \"E\", \"message\": \"RestDelete could not commit transaction\"}]}`)\n\t\treturn\n\t}\n\n\tresponse.Status = true\t\n\toutput, err := json.Marshal(response)\n\tif err != nil {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\tfmt.Fprint(w, `{\"status\": false, \"messages\": [{\"type\": \"error\", \"text\": \"JSON encoding failed\"}]}`)\n\t\treturn\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprint(w, string(output))\n}\n{{end}}\n"),
	}
	file10 := &embedded.EmbeddedFile{
		Filename:    "rest_hooks.go.tmpl",
		FileModTime: time.Unix(1528714907, 0),
		Content:     string("package {{.Package}}\n\nimport (\n\t\"database/sql\"\n\t\"net/http\"\n)\n\n{{if .Hooks.PreRead}}\nfunc restPreGet(w http.ResponseWriter, r *http.Request, id {{pkeyPropertyType .Entity.PrimaryKey}}) (bool, error) {\n\treturn false, nil\n}\n{{end}}\n{{if .Hooks.PostRead}}\nfunc restPostGet(w http.ResponseWriter, r *http.Request, entity *{{.Entity.Name}}) (bool, error) {\n\treturn false, nil\n}\n{{end}}\n\n{{if .Hooks.PreList}}\nfunc restPreList(w http.ResponseWriter, r *http.Request, filters []models.ListFilter) ([]models.ListFilter, bool, error) {\n\treturn filters, false, nil\n}\n{{end}}\n{{if .Hooks.PostList}}\nfunc restPostList(w http.ResponseWriter, r *http.Request, list []*{{.Entity.Name}}) ([]*{{.Entity.Name}}, bool, error) {\n\treturn list, false, nil\n}\n{{end}}\n\n{{if .Hooks.PreCreate}}\nfunc restPreCreate(w http.ResponseWriter, r *http.Request, entity *{{.Entity.Name}}, tx *sql.Tx) (bool, error) {\n\treturn false, nil\n}\n{{end}}\n{{if .Hooks.PostCreate}}\nfunc restPostCreate(w http.ResponseWriter, r *http.Request, entity *{{.Entity.Name}}, tx *sql.Tx) (bool, error) {\n\treturn false, nil\n}\n{{end}}\n\n{{if .Hooks.PreUpdate}}\nfunc restPreUpdate(w http.ResponseWriter, r *http.Request, entity *{{.Entity.Name}}, tx *sql.Tx) (bool, error) {\n\treturn false, nil\n}\n{{end}}\n{{if .Hooks.PostUpdate}}\nfunc restPostUpdate(w http.ResponseWriter, r *http.Request, entity *{{.Entity.Name}}, tx *sql.Tx) (bool, error) {\n\treturn false, nil\n}\n{{end}}\n\n{{if .Hooks.PreDelete}}\nfunc restPreDelete(w http.ResponseWriter, r *http.Request, id {{pkeyPropertyType .Entity.PrimaryKey}}, tx *sql.Tx) (bool, error) {\n\treturn false, nil\n}\n{{end}}\n{{if .Hooks.PostDelete}}\nfunc restPostDelete(w http.ResponseWriter, r *http.Request, id {{pkeyPropertyType .Entity.PrimaryKey}}, tx *sql.Tx) (bool, error) {\n\treturn false, nil\n}\n{{end}}"),
	}
	file12 := &embedded.EmbeddedFile{
		Filename:    "schema/schema.sql.tmpl",
		FileModTime: time.Unix(1533812553, 0),
		Content:     string("DROP TABLE IF EXISTS {{.Entity.Table}};\n\nCREATE TABLE {{.Entity.Table}} (\n\t\"id\" {{pkeyFieldType .Entity.PrimaryKey}},\n\t{{- range $i, $e := .Entity.Fields}}{{if ne .Schema.Field \"\"}}\n\t\"{{.Schema.Field}}\" {{$e.Schema.Type}} NOT NULL\n\t{{- if ne .Schema.Default \"\"}} DEFAULT {{.Schema.Default}}{{end}},\n\t{{- end}}{{- end}}\n\t{{- range .RelatedFields}}\n\t\"{{.Name}}\" {{.Type}} NOT NULL,\n\t{{end}}\n\t{{range .Entity.TableConstraints}}{{.}},{{end}}\n\tPRIMARY KEY (\"id\")\n);\n\n{{range .RelatedTables}}\nDROP TABLE IF EXISTS {{.Table}};\n\nCREATE TABLE {{.Table}} (\n\t\"{{.ThisID}}\" {{.ThisType}} NOT NULL,\n\t\"{{.ThatID}}\" {{.ThatType}} NOT NULL\n);\n\nDROP INDEX IF EXISTS {{.Table}}_{{.ThisID}};\nDROP INDEX IF EXISTS {{.Table}}_{{.ThatID}};\n\nCREATE INDEX {{.Table}}_{{.ThisID}} ON {{.Table}} ({{.ThisID}});\nCREATE INDEX {{.Table}}_{{.ThatID}} ON {{.Table}} ({{.ThatID}});\n{{end}}"),
	}
	file14 := &embedded.EmbeddedFile{
		Filename:    "util/credentials.go.tmpl",
		FileModTime: time.Unix(1533201928, 0),
		Content:     string("package credentials\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\n// Credentials represents connection to a service having a protocol, identifier, password, host and port\ntype Credentials struct {\n\tProtocol   string\n\tIdentifier string\n\tPassword   string\n\tHost       string\n\tPort       string\n}\n\n// String returns a human friendly representation of the credentials\nfunc (c *Credentials) String() string {\n\treturn fmt.Sprintf(\"Protocol: %s Identifier: %s Password: %s Host: %s Port: %s\", c.Protocol, c.Identifier, c.Password, c.Host, c.Port)\n}\n\n// getProtocol returns Protocol portion of the credentials\nfunc (c *Credentials) GetProtocol() string {\n\treturn c.Protocol\n}\n\n// getIdentifier returns Identifier portion of the credentials\nfunc (c *Credentials) GetIdentifier() string {\n\treturn c.Identifier\n}\n\n// getPassword returns Password portion of the credentials\nfunc (c *Credentials) GetPassword() string {\n\treturn c.Password\n}\n\n// getHost returns Host portion of the credentials\nfunc (c *Credentials) GetHost() string {\n\treturn c.Host\n}\n\n// getPort returns Port portion of the credentials\nfunc (c *Credentials) GetPort() string {\n\treturn c.Port\n}\n\n\n// NewCredentials returns a connection from string in the format protocol://username:password@host:port\nfunc NewCredentials(conn string, defaults ...*Credentials) *Credentials {\n\tvar (\n\t\tcredentials   *Credentials\n\t\tcreds, server string\n\t)\n\n\tif len(defaults) == 1 {\n\t\tcredentials = defaults[0]\n\t} else {\n\t\tcredentials = new(Credentials)\n\t}\n\n\tif i := strings.Index(conn, \"://\"); i != -1 {\n\t\tcredentials.Protocol = conn[:i]\n\t\tconn = conn[i+3:]\n\t}\n\n\tif i := strings.Index(conn, \"@\"); i == -1 { //no username password\n\t\tserver = conn\n\t} else {\n\t\tcreds = conn[:i]\n\t\tserver = conn[i+1:]\n\t}\n\n\tif creds == \"\" {\n\t\t//do nothing\n\t} else if i := strings.Index(creds, \":\"); i != -1 { //both id and password\n\t\tcredentials.Identifier = creds[:i]\n\t\tcredentials.Password = creds[i+1:]\n\t} else { //only id\n\t\tcredentials.Identifier = creds\n\t}\n\n\tif server == \"\" {\n\t\t//do nothing\n\t} else if i := strings.Index(server, \":\"); i != -1 { //both host and port\n\t\tcredentials.Host = server[:i]\n\t\tcredentials.Port = server[i+1:]\n\t} else { //only host\n\t\tcredentials.Host = conn\n\t}\n\n\treturn credentials\n}\n"),
	}
	file15 := &embedded.EmbeddedFile{
		Filename:    "util/files.go.tmpl",
		FileModTime: time.Unix(1534490495, 0),
		Content:     string("package files\n\nimport (\n\t\"fmt\"\n\t\"image\"\n\t\"image/gif\"\n\t\"image/jpeg\"\n\t\"image/png\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gopkg.in/h2non/filetype.v1\"\n)\n\n// Constants for files package\nconst (\n\tNoLimit = -1\n)\n\nvar (\n\t// BaseUploadPath holds the path on disk\n\t// for the uploaded files\n\tBaseUploadPath = \"public/\"\n\n\t// DefaultUploadOptions holds default upload options\n\tDefaultUploadOptions = &UploadOptions{\n\t\tPermissions: 0644,\n\t\tFileExt:     \"jpg\",\n\t\tMaxSize:     NoLimit,\n\t\tMinSize:     NoLimit,\n\t\tImgDimensions: &ImageDimensions{\n\t\t\tMinHeight: NoLimit,\n\t\t\tMaxHeight: NoLimit,\n\t\t\tMinWidth:  NoLimit,\n\t\t\tMaxWidth:  NoLimit,\n\t\t},\n\t}\n)\n\n// ImageDimensions holds dimensions options\ntype ImageDimensions struct {\n\tMinHeight int\n\tMaxHeight int\n\tMinWidth  int\n\tMaxWidth  int\n}\n\n// UploadOptions holds file upload options\ntype UploadOptions struct {\n\tDestination   string\n\tPermissions   os.FileMode\n\tEntity        string\n\tField         string\n\tFileExt       string\n\tMaxSize       int\n\tMinSize       int\n\tImgDimensions *ImageDimensions\n}\n\nfunc init() {\n\timage.RegisterFormat(\"jpeg\", \"jpeg\", jpeg.Decode, jpeg.DecodeConfig)\n\timage.RegisterFormat(\"png\", \"png\", png.Decode, png.DecodeConfig)\n\timage.RegisterFormat(\"gif\", \"gif\", gif.Decode, gif.DecodeConfig)\n}\n\n// SetBaseUploadPath sets the base upload path for files upload\nfunc SetBaseUploadPath(bUploadPath string) {\n\tif bUploadPath == \"\" {\n\t\treturn\n\t}\n\tBaseUploadPath = bUploadPath\n}\n\n// Upload validates and saves create file\nfunc Upload(fileName string, fileContent []byte, options *UploadOptions) (string, string, error) {\n\tvar filePath string\n\n\tif options.Permissions == 0 {\n\t\toptions.Permissions = DefaultUploadOptions.Permissions\n\t}\n\n\tfileName = buildFileName(fileName, options.FileExt)\n\tdirectoryPath := path.Join(BaseUploadPath, options.Destination)\n\n\tif err := os.MkdirAll(directoryPath, os.ModePerm); err != nil {\n\t\tlog.Printf(\"error creating directories: %v\\n\", err)\n\t\treturn filePath, fileName, err\n\t}\n\n\tfilePath = filepath.Join(directoryPath, fileName)\n\n\tif _, err := os.Stat(filePath); os.IsNotExist(err) {\n\t\tif err := ioutil.WriteFile(filePath, fileContent, options.Permissions); err != nil {\n\t\t\tlog.Printf(\"error writing %v: %v\\n\", filePath, err)\n\t\t\treturn filePath, fileName, err\n\t\t}\n\t}\n\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\tlog.Printf(\"error opening %v: %v\\n\", filePath, err)\n\t\treturn filePath, fileName, err\n\t}\n\tdefer file.Close()\n\n\tbuf, err := ioutil.ReadFile(filePath)\n\tif err != nil {\n\t\tlog.Printf(\"error reading %v: %v\\n\", filePath, err)\n\t\treturn filePath, fileName, err\n\t}\n\n\tfileSize := len(buf)\n\n\tif options.FileExt == \"\" {\n\t\toptions.FileExt = DefaultUploadOptions.FileExt\n\t}\n\n\tif !filetype.IsExtension(buf, options.FileExt) {\n\t\tlog.Printf(\"file not a valid %v file\\n\", options.FileExt)\n\t\treturn filePath, fileName, fmt.Errorf(\"file type invalid\")\n\t}\n\n\tif options.MaxSize != NoLimit && fileSize > options.MaxSize {\n\t\tlog.Printf(\"file %v greater than max file size: %v\\n\", fileName, options.MaxSize)\n\t\treturn filePath, fileName, fmt.Errorf(\"file max size error\")\n\t}\n\n\tif options.MinSize != NoLimit && fileSize < options.MinSize {\n\t\tlog.Printf(\"file %v lower than min file size: %v\\n\", fileName, options.MinSize)\n\t\treturn filePath, fileName, fmt.Errorf(\"file min size error\")\n\t}\n\n\tif filetype.IsImage(buf) {\n\t\timage, _, err := image.DecodeConfig(file)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"error decoding image: %v\", err)\n\t\t\treturn filePath, fileName, err\n\t\t}\n\n\t\tif options.ImgDimensions == nil {\n\t\t\toptions.ImgDimensions = DefaultUploadOptions.ImgDimensions\n\t\t}\n\n\t\tif options.ImgDimensions.MaxHeight != NoLimit && image.Height > options.ImgDimensions.MaxHeight {\n\t\t\tlog.Printf(\"image %v greater than max height: %v\\n\", fileName, options.ImgDimensions.MaxHeight)\n\t\t\treturn filePath, fileName, fmt.Errorf(\"image max height error\")\n\t\t}\n\n\t\tif options.ImgDimensions.MinHeight != NoLimit && image.Height < options.ImgDimensions.MinHeight {\n\t\t\tlog.Printf(\"image %v lower than min height: %v\\n\", fileName, options.ImgDimensions.MinHeight)\n\t\t\treturn filePath, fileName, fmt.Errorf(\"image min height error\")\n\t\t}\n\n\t\tif options.ImgDimensions.MaxWidth != NoLimit && image.Width > options.ImgDimensions.MaxWidth {\n\t\t\tlog.Printf(\"image %v greater than max width: %v\\n\", fileName, options.ImgDimensions.MaxWidth)\n\t\t\treturn filePath, fileName, fmt.Errorf(\"image max width error\")\n\t\t}\n\n\t\tif options.ImgDimensions.MinWidth != NoLimit && image.Width < options.ImgDimensions.MinWidth {\n\t\t\tlog.Printf(\"image %v lower than min width: %v\\n\", fileName, options.ImgDimensions.MinWidth)\n\t\t\treturn filePath, fileName, fmt.Errorf(\"image min width error\")\n\t\t}\n\t}\n\n\treturn filePath, fileName, nil\n}\n\n// Delete deletes one file\nfunc Delete(fp string) error {\n\tif err := os.Remove(fp); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// DeleteFromRel deletes one file using relative path\nfunc DeleteFromRel(prefix, filePathRel string) error {\n\tfilePathTrimmed := strings.TrimPrefix(filePathRel, prefix)\n\tfilePathDisk := filepath.Join(BaseUploadPath, filePathTrimmed)\n\treturn Delete(filePathDisk)\n}\n\n// DeleteMany deletes many files\nfunc DeleteMany(filespath map[string]string) {\n\tfor _, fp := range filespath {\n\t\tif err := Delete(fp); err != nil {\n\t\t\tlog.Printf(\"error deleting file %v\\n\", err)\n\t\t}\n\t}\n}\n\n// RemoveContents deletes all contents of a directory\nfunc RemoveContents(dir, exception string) error {\n\tdir = path.Join(BaseUploadPath, dir)\n\tdirRead, err := os.Open(dir)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdirFiles, err := dirRead.Readdir(0)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, fileInfo := range dirFiles {\n\t\tfullPath := path.Join(dir, fileInfo.Name())\n\n\t\tif fullPath == exception {\n\t\t\tcontinue\n\t\t}\n\n\t\tos.Remove(fullPath)\n\t}\n\treturn nil\n}\n\nfunc buildFileName(oldFilename, newExt string) string {\n\toldExt := filepath.Ext(oldFilename)\n\tnewFilename := strings.TrimSuffix(oldFilename, oldExt)\n\tnewFilename = newFilename + \"_\" + time.Now().Format(\"20060102150405\")\n\treturn newFilename + \".\" + newExt\n}\n"),
	}
	file16 := &embedded.EmbeddedFile{
		Filename:    "util/rice.go.tmpl",
		FileModTime: time.Unix(1532349938, 0),
		Content:     string("package util\n\nimport (\n\t\"net/http\"\n\t\"strings\"\n\n\trice \"github.com/GeertJohan/go.rice\"\n)\n\n// WebBox implements http.FileSystem which allows the use of Box with a http.FileServer.\n//   e.g.: http.Handle(\"/\", http.FileServer(rice.MustFindBox(\"http-files\").HTTPBox()))\ntype WebBox struct {\n\tBox  *rice.Box\n\tApp  string\n\tPath string\n}\n\n// NewWebBoxHandler returns a new WebBox File Server Handler\nfunc NewWebBoxHandler(box *rice.Box, app, path string) http.Handler {\n\treturn http.FileServer(WebBox{Box: box, App: app, Path: \"/\" + path})\n}\n\n// Open returns a File using the http.File interface\nfunc (b WebBox) Open(name string) (http.File, error) {\n\tname = strings.TrimPrefix(name, b.Path)\n\treturn b.Box.Open(b.App + name)\n}\n"),
	}
	file17 := &embedded.EmbeddedFile{
		Filename:    "util/util.go.tmpl",
		FileModTime: time.Unix(1528714907, 0),
		Content:     string("package util\n\nimport (\n\t\"context\"\n)\n\n// CheckContext returns an error if context is done\nfunc CheckContext(ctx context.Context) error {\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn ctx.Err()\n\tdefault:\n\t\treturn nil\n\t}\n}"),
	}
	file18 := &embedded.EmbeddedFile{
		Filename:    "util/web.go.tmpl",
		FileModTime: time.Unix(1534420769, 0),
		Content:     string("package web\n\nimport (\n\t\"net/http\"\n\t\"os\"\n\t\"path\"\n\t\"strings\"\n\n\t\"github.com/gorilla/mux\"\n\tlog \"github.com/sirupsen/logrus\"\n)\n\nfunc lookupContent(root http.FileSystem, upath string) (http.File, os.FileInfo, bool) {\n\tvar (\n\t\terr  error\n\t\tfile http.File\n\t\tinfo os.FileInfo\n\t)\n\n\tif !strings.HasPrefix(upath, \"/\") {\n\t\tupath = \"/\" + upath\n\t}\n\n\tupath = path.Clean(upath)\n\n\tif file, err = root.Open(upath); err != nil {\n\t\treturn nil, nil, false\n\t}\n\n\tif info, err = file.Stat(); err != nil {\n\t\treturn nil, nil, false\n\t}\n\n\tif info.IsDir() {\n\t\tupath += \"/index.html\"\n\t\treturn lookupContent(root, upath+\"/index.html\")\n\t}\n\n\treturn file, info, true\n}\n\ntype fileHandlerWithFallback struct {\n\troot     http.FileSystem\n\tfallback http.File\n}\n\n// FileServerWithFallback returns an HTTP static fileserver with a default file fallback if requested url was not found\nfunc FileServerWithFallback(root http.FileSystem, fallback http.File) http.Handler {\n\treturn &fileHandlerWithFallback{root: root, fallback: fallback}\n}\n\nfunc (f *fileHandlerWithFallback) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tvar (\n\t\tfile http.File\n\t\tinfo os.FileInfo\n\t\tok   bool\n\t\terr  error\n\t)\n\n\tfile, info, ok = lookupContent(f.root, r.URL.Path)\n\n\tif !ok {\n\t\tfile = f.fallback\n\t\tif info, err = file.Stat(); err == nil {\n\t\t\tok = true\n\t\t}\n\t}\n\n\tif ok {\n\t\thttp.ServeContent(w, r, info.Name(), info.ModTime(), file)\n\t} else {\n\t\tw.Header().Set(\"Content-Type\", \"text/plain; charset=utf-8\")\n\t\tw.Header().Set(\"X-Content-Type-Options\", \"nosniff\")\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\tw.Write([]byte(\"File not found and default could not be served.\"))\n\t}\n}\n\ntype fileHandlerWithNotFoundHandler struct {\n\troot    http.FileSystem\n\thandler http.Handler\n}\n\n// FileServerWithNotFoundHandler returns an HTTP static fileserver with a custom http.Handler if requested url was not found\nfunc FileServerWithNotFoundHandler(root http.FileSystem, handler http.Handler) http.Handler {\n\treturn &fileHandlerWithNotFoundHandler{root: root, handler: handler}\n}\n\nfunc (f *fileHandlerWithNotFoundHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tif file, info, ok := lookupContent(f.root, r.URL.Path); ok {\n\t\thttp.ServeContent(w, r, info.Name(), info.ModTime(), file)\n\t} else {\n\t\tf.handler.ServeHTTP(w, r)\n\t}\n}\n\n// WebAppRouting returns a new subrouter\nfunc WebAppRouting(router *mux.Router, prefix string, appName string, mwf ...mux.MiddlewareFunc) error {\n\tvar (\n\t\tfileSystem   http.FileSystem\n\t\tfallbackFile http.File\n\t\terr          error\n\t)\n\n\tfallbackFile, err = app.Assets.Open(\"web/\" + appName + \"/index.html\")\n\tif err != nil {\n\t\treturn err\n\t}\n\t\n\tfileSystem = util.WebBox{Box: app.Assets, App: \"web/\" + appName, Path: \"/\" + appName}\n\n\trouter.PathPrefix(prefix).Handler(\n\t\thttp.StripPrefix(\n\t\t\tprefix,\n\t\t\tFileServerWithFallback(fileSystem, fallbackFile),\n\t\t),\n\t)\n\n\treturn nil\n}\n\n// WebDevRouting returns a new subrouter\nfunc WebDevRouting(router *mux.Router, prefix string, app string, port string, mwf ...mux.MiddlewareFunc) error {\n\tvar (\n\t\turl\t\t  = &url.URL{Scheme: \"http\", Host: \"localhost:\" + port}\n\t\twsprox    = NewWSReverseProxy(url)\n\t\thtprox    = httputil.NewSingleHostReverseProxy(url)\n\t)\n\n\trouter.PathPrefix(prefix).HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif IsWebsocket(r) {\n\t\t\twsprox.ServeHTTP(w, r)\n\t\t} else {\n\t\t\thtprox.ServeHTTP(w, r)\n\t\t}\n\t})\n\n\treturn nil\n}\n"),
	}
	file19 := &embedded.EmbeddedFile{
		Filename:    "util/ws.go.tmpl",
		FileModTime: time.Unix(1534232918, 0),
		Content:     string("package web\n\n// WSReverseProxy implements http.HandlerFunc to reverse proxy websocket requests\ntype WSReverseProxy struct {\n\tTarget string\n}\n\n// NewWSReverseProxy creates a new websocket reverse proxy\nfunc NewWSReverseProxy(url *url.URL) *WSReverseProxy {\n\tvar proxy = new(WSReverseProxy)\n\tproxy.Target = fmt.Sprintf(\"%s:%s\", url.Hostname(), url.Port())\n\n\treturn proxy\n}\n\nfunc (ws *WSReverseProxy) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\td, err := net.Dial(\"tcp\", ws.Target)\n\tif err != nil {\n\t\thttp.Error(w, \"Error contacting backend server.\", http.StatusBadGateway)\n\t\tlog.Printf(\"Error dialing websocket backend %s: %s\", ws.Target, err)\n\t\treturn\n\t}\n\n\thj, ok := w.(http.Hijacker)\n\tif !ok {\n\t\thttp.Error(w, \"Not a hijacker?\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tnc, _, err := hj.Hijack()\n\tif err != nil {\n\t\tlog.Printf(\"Hijack error: %v\", err)\n\t\treturn\n\t}\n\n\tdefer nc.Close()\n\tdefer d.Close()\n\n\terr = r.Write(d)\n\tif err != nil {\n\t\tlog.Printf(\"Error copying request to target: %v\", err)\n\t\treturn\n\t}\n\n\terrc := make(chan error, 2)\n\tcp := func(dst io.Writer, src io.Reader) {\n\t\t_, err := io.Copy(dst, src)\n\n\t\tif err != nil {\n\t\t\terrc <- err\n\t\t}\n\t}\n\tgo cp(d, nc)\n\tgo cp(nc, d)\n\t<-errc\n}\n\n// IsWebsocket determines whether or not an http request is using websocket\nfunc IsWebsocket(r *http.Request) bool {\n\tconnHdr := \"\"\n\tconnHdrs := r.Header[\"Connection\"]\n\tif len(connHdrs) > 0 {\n\t\tconnHdr = connHdrs[0]\n\t}\n\n\tupgradeWs := false\n\tif strings.ToLower(connHdr) == \"upgrade\" {\n\t\tupgradeHdrs := r.Header[\"Upgrade\"]\n\t\tif len(upgradeHdrs) > 0 {\n\t\t\tupgradeWs = (strings.ToLower(upgradeHdrs[0]) == \"websocket\")\n\t\t}\n\t}\n\n\treturn upgradeWs\n}\n"),
	}
	file1c := &embedded.EmbeddedFile{
		Filename:    "vuetify/js/actions.js.tmpl",
		FileModTime: time.Unix(1533709790, 0),
		Content:     string("import types from \"./types\";\n\nexport default {}"),
	}
	file1d := &embedded.EmbeddedFile{
		Filename:    "vuetify/js/getters.js.tmpl",
		FileModTime: time.Unix(1533709790, 0),
		Content:     string("export default {}\n"),
	}
	file1e := &embedded.EmbeddedFile{
		Filename:    "vuetify/js/index.js.tmpl",
		FileModTime: time.Unix(1533709790, 0),
		Content:     string("import actions from \"./actions\";\nimport getters from \"./getters\";\nimport mutations from \"./mutations\";\nimport routes from \"./routes\";\n\nconst namespaced = true;\n\nconst state = {\n  entities: routes.routes\n};\n\nexport default {\n  namespaced,\n  state,\n  actions,\n  getters,\n  mutations\n};"),
	}
	file1f := &embedded.EmbeddedFile{
		Filename:    "vuetify/js/mutations.js.tmpl",
		FileModTime: time.Unix(1533709790, 0),
		Content:     string("import types from \"./types\";\n\nexport default {}\n"),
	}
	file1g := &embedded.EmbeddedFile{
		Filename:    "vuetify/js/routes.js.tmpl",
		FileModTime: time.Unix(1534330498, 0),
		Content:     string("{{range .Entities}}\n// {{.Name}} {{.Description}}\nimport {{.Name}}List from \"./views/{{plural .Name}}List.vue\";\nimport {{.Name}}Edit from \"./views/{{plural .Name}}Edit.vue\";\n{{end}}\n\nlet routes = [\n  {{range $i, $v := .Entities}}\n  {\n    path: \"/{{lower (plural .Name)}}\",\n    name: \"{{lower (plural .Name)}}_list\",\n    component: {{.Name}}List,\n    meta: {\n      icon: \"{{.Vuetify.Icon}}\",\n      entity: \"{{plural .Name}}\",\n      showInMenu: {{if .Vuetify.NotInMenu}}false{{else}}true{{end}}\n    }\n  },\n  {\n    path: \"/g_{{lower (plural .Name)}}/edit/:id\",\n    name: \"g_{{lower (plural .Name)}}_edit\",\n    component: {{.Name}}Edit,\n    meta: {\n      icon: \"{{.Vuetify.Icon}}\",\n      entity: \"{{plural .Name}}\",\n      showInMenu: false\n    }\n  }{{if ne (plus1 $i) (len $.Entities)}},{{end}}\n  {{end}}\n];\n\nexport default routes;"),
	}
	file1h := &embedded.EmbeddedFile{
		Filename:    "vuetify/js/types.js.tmpl",
		FileModTime: time.Unix(1533709790, 0),
		Content:     string("export default {}\n"),
	}
	file1j := &embedded.EmbeddedFile{
		Filename:    "vuetify/old/vuetify_edit.vue.tmpl",
		FileModTime: time.Unix(1533709790, 0),
		Content:     string("<template>\n    <div class=\"container\">\n\t\t<v-toolbar color=\"transparent\" flat>\n            <v-toolbar-title class=\"grey--text text--darken-4 ml-0\"><h2>{{.Entity.Name}}</h2></v-toolbar-title>\n            <v-spacer></v-spacer>\n            <v-btn ml-0 small color=\"grey\" flat :to=\"{name: '{{.Endpoint}}List'}\">\n                <v-icon dark>arrow_back</v-icon> Back\n            </v-btn>\n        </v-toolbar>\n\t\t<v-alert :type=\"message.type\" :value=\"true\" v-for=\"(message, index) in messages\" :key=\"index\">\n\t\t{{ \"{{ message.text }}\" }}\n\t\t</v-alert>\n  \n        {{range .Entity.Fields -}}\n        {{widget_field \"vuetify\" .Widget.Type .}}\n        {{- end}}\n\n        <v-btn color=\"primary\" @click=\"save()\">Save</v-btn>\n        <v-btn color=\"gray\" :to=\"{name: '{{.Endpoint}}List'}\">Cancel</v-btn>\n\t</div>\n</template>\n  \n<script>\nimport axios from \"axios\"\n\nexport default {\n    props: [\"id\"],\n    created() {\n        if (!this.id) {\n            return\n        }\n\n        axios.get(\"/api/{{.Endpoint}}/\" + this.id).then(response => {\n            this.id = response.data.entity.id\n            {{range .Entity.Fields}}{{if ne .Serialized \"id\"}}\n            this.entity.{{.Serialized}} = response.data.entity.{{.Serialized}}\n            {{if eq .Widget.Type \"date\"}}this.dates.{{.Serialized}}.value = response.data.entity.{{.Serialized}}.substr(0,10){{end}}\n            {{end}}{{end}}\n        })\n    },\n    data() {\n        return {\n            select: {\n                {{range $i, $v := .Entity.Fields}}{{if eq .Widget.Type \"date\"}}\n                {{.Serialized}}: {\n                    items:[\n                        {{range $j, $u := .Widget.Options}}\n                        {text: \"{{.Label}}\", value: \"{{.Value}}\"}{{if eq (plus1 $j) (len $u)}},{{end}}\n                        {{end}}\n                    ]\n                }{{if ne (plus1 $i) (len $.Entity.Fields)}},{{end}}\n                {{end}}{{end}}\n\t\t\t},\n\t\t\tdates: {\n                {{range $i, $v := .Entity.Fields}}{{if eq .Widget.Type \"date\"}}\n\t\t\t\t{{.Serialized}}: {value: null, menuAppear: false}{{if ne (plus1 $i) (len $.Entity.Fields)}},{{end}}\n                {{end}}{{end}}\n\t\t\t},\n            messages: [],\n            entity: {\n                {{range $i, $e := .Entity.Fields}}{{if ne .Serialized \"id\"}}\n                {{.Serialized}} : null{{if ne (plus1 $i) (len $.Entity.Fields)}},{{end}}\n                {{end}}{{end}}\n            }\n        }\n    },\n    watch: {\n        {{range $i, $e := .Entity.Fields}}\n        \"select.{{.Serialized}}.search\": function(val) {\n            val && this.querySelections(\"{{.Serialized}}\", \"{{$.Endpoint}}\", \"{{$.Prefix}}{{.Relationship.Target.Endpoint}}\", val)\n        }{{if ne (plus1 $i) (len $.Entity.Fields)}},{{end}}\n        {{end}}\n    },\n    methods: {\n        querySelections(fieldname, endpoint, filter, val) {\n            this.select[fieldname].loading = true\n            axios.get(\"/api/\" + endpoint + \"?\" + filter + \"-lk=\" + encodeURIComponent(val)).then(response => {\n                this.select[fieldname].loading = false\n                this.select[fieldname].items = response.data.entities.map(function(e) {\n                    return { text: e[filter], value: e.id }\n                })\n            })\n        },\n        save() {\n            if (this.id) {\n                axios.put(\"/api/{{.Endpoint}}/\" + this.id, this.entity).then(this.saved)\n            } else {\n                axios.post(\"/api/{{.Endpoint}}\", this.entity).then(this.saved)\n            }\n\t\t},\n\t\tsaved(response) {\n\t\t\tthis.id = response.data.entity.id\n\t\t\t{{range .Entity.Fields}}{{if ne .Serialized \"id\"}}\n            this.entity.{{.Serialized}} = response.data.entity.{{.Serialized}}\n            {{end}}{{end}}\n\n\t\t\tthis.messages.push({\n\t\t\t\ttype: \"success\",\n\t\t\t\ttext: \"{{.Entity.Name}} saved successfully\"\n\t\t\t})\n\t\t}\n    }\n}\n</script>"),
	}
	file1k := &embedded.EmbeddedFile{
		Filename:    "vuetify/old/vuetify_editor-field-checkbox.vue.tmpl",
		FileModTime: time.Unix(1533709790, 0),
		Content:     string("<v-checkbox label=\"{{.Label}}\" v-model=\"entity.{{.Serialized}}\"></v-checkbox>"),
	}
	file1l := &embedded.EmbeddedFile{
		Filename:    "vuetify/old/vuetify_editor-field-date.vue.tmpl",
		FileModTime: time.Unix(1533709790, 0),
		Content:     string("<v-menu\n\tref=\"menu_{{.Serialized}}\"\n\tlazy\n\t:close-on-content-click=\"false\"\n\tv-model=\"dates.{{.Serialized}}.menuAppear\"\n\ttransition=\"scale-transition\"\n\toffset-y\n\tfull-width\n\t:nudge-right=\"40\"\n\tmin-width=\"290px\"\n\t:return-value.sync=\"dates.{{.Serialized}}.value\"\n\t>\n\t<v-text-field\n\t\tslot=\"activator\"\n\t\tlabel=\"{{.Label}}\"\n\t\tv-model=\"dates.{{.Serialized}}.value\"\n\t\tprepend-icon=\"event\"\n\t\treadonly\n\t\t></v-text-field>\n\t\t<v-date-picker v-model=\"dates.{{.Serialized}}.value\" @change=\"entity.{{.Serialized}} = dates.{{.Serialized}}.value + 'T00:00:00Z'\" no-title scrollable>\n\t\t<v-spacer></v-spacer>\n\t\t<v-btn flat color=\"primary\" @click=\"menu_{{.Serialized}} = false\">Cancel</v-btn>\n\t\t<v-btn flat color=\"primary\" @click=\"$refs.menu_{{.Serialized}}.save(dates.{{.Serialized}}.value)\">OK</v-btn>\n\t\t</v-date-picker>\n</v-menu>"),
	}
	file1m := &embedded.EmbeddedFile{
		Filename:    "vuetify/old/vuetify_editor-field-number.vue.tmpl",
		FileModTime: time.Unix(1533709790, 0),
		Content:     string("<v-text-field v-model=\"entity.{{.Serialized}}\" label=\"{{.Label}}\" type=\"number\" />"),
	}
	file1n := &embedded.EmbeddedFile{
		Filename:    "vuetify/old/vuetify_editor-field-password.vue.tmpl",
		FileModTime: time.Unix(1533709790, 0),
		Content:     string("<v-text-field\n\tv-model=\"entity.{{.Serialized}}\"\n\t:append-icon=\"e1 ? 'visibility' : 'visibility_off'\"\n\t:append-icon-cb=\"() => (e1 = !e1)\"\n\t:type=\"e1 ? 'password' : 'text'\"\n\tcounter\n  ></v-text-field>"),
	}
	file1o := &embedded.EmbeddedFile{
		Filename:    "vuetify/old/vuetify_editor-field-select-rel.vue.tmpl",
		FileModTime: time.Unix(1533709790, 0),
		Content:     string("<v-select\n    autocomplete\n    cache-items\n    required\n    label=\"{{.Label}}\"\n    :loading=\"select.{{.Serialized}}.isloading\"\n    :items=\"select.{{.Serialized}}.items\"\n\t:search-input.sync=\"select.{{.Serialized}}.search\"\n\tv-model=\"entity.{{.Serialized}}\"\n\t{{if .Widget.Multiple}}multiple chips{{end}}\n></v-select>"),
	}
	file1p := &embedded.EmbeddedFile{
		Filename:    "vuetify/old/vuetify_editor-field-select.vue.tmpl",
		FileModTime: time.Unix(1533709790, 0),
		Content:     string("<v-select\n\tautocomplete\n\tcache-items\n\trequired\n\tlabel=\"{{.Label}}\"\n\t:items=\"select.{{.Serialized}}.items\"\n\tv-model=\"entity.{{.Serialized}}\"\n\t{{if .Widget.Multiple}}multiple chips{{end}}\n></v-select>"),
	}
	file1q := &embedded.EmbeddedFile{
		Filename:    "vuetify/old/vuetify_editor-field-textarea.vue.tmpl",
		FileModTime: time.Unix(1533709790, 0),
		Content:     string("<v-text-field v-model=\"entity.{{.Serialized}}\" label=\"{{.Label}}\" multiline />"),
	}
	file1r := &embedded.EmbeddedFile{
		Filename:    "vuetify/old/vuetify_editor-field-textfield.vue.tmpl",
		FileModTime: time.Unix(1533709790, 0),
		Content:     string("<v-text-field v-model=\"entity.{{.Serialized}}\" label=\"{{.Label}}\" />"),
	}
	file1s := &embedded.EmbeddedFile{
		Filename:    "vuetify/old/vuetify_editor-field-time.vue.tmpl",
		FileModTime: time.Unix(1533709790, 0),
		Content:     string("<div>\n\t<v-time-picker v-model=\"entity.{{.Serialized}}\" label=\"{{.Label}}\" :landscape=\"landscape\"></v-time-picker>\n</div>"),
	}
	file1t := &embedded.EmbeddedFile{
		Filename:    "vuetify/old/vuetify_editor-field-toggle.vue.tmpl",
		FileModTime: time.Unix(1533709790, 0),
		Content:     string("<v-switch\n\tlabel=\"{{.Label}}\"\n\tv-model=\"entity.{{.Serialized}}\"\n></v-switch>"),
	}
	file1v := &embedded.EmbeddedFile{
		Filename:    "vuetify/views/edit.vue.tmpl",
		FileModTime: time.Unix(1534795419, 0),
		Content:     string("<template>\n    <div>\n        <div class=\"listing--container\">\n            <v-toolbar color=\"transparent\" class=\"listing-toolbar\" flat ml-0>\n                <v-btn icon :to=\"{name: '{{- plural (lower .Entity.Name) -}}_list'}\">\n                    <v-icon large>arrow_back</v-icon>\n                </v-btn>\n                <v-toolbar-title class=\"ma-0 pa-0\">\n                    <h2>Edit {{.Entity.Name}}</h2>\n                </v-toolbar-title>\n                <v-spacer></v-spacer>\n                <v-btn mr-0 color=\"primary\" :to=\"''\">\n                    <v-icon dark>save</v-icon> Save\n                </v-btn>\n            </v-toolbar>\n        </div>\n        <v-card>\n            <v-card-text>\n                <v-form>\n                    <div class=\"gocipe-form-grid\" v-if=\"entity\">\n                        {{ range .Entity.Fields }} {{if not .EditWidget.Hide }}\n                        <template>\n                            <div class=\"gocipe-field-container\">\n                                <component :is=\"'g{{ucfirst .EditWidget.Type }}'\" :label=\"'{{ .Label }}'\" :hint=\"'widget: {{ .EditWidget.Type }}'\" @gocipe=\"(e) => this.entity.set{{ucfirst .Property.Name}}(e)\" :value=\"this.entity.get{{ucfirst .Property.Name}}()\"></component>\n                            </div>\n                        </template>\n                        {{end}} {{end}}\n                    </div>\n                </v-form>\n            </v-card-text>\n            <v-card-actions>\n                <v-btn color=\"primary\" @click=\"update\">\n                    Save\n                    <v-icon right>save</v-icon>\n                </v-btn>\n            </v-card-actions>\n        </v-card>\n\n        <v-snackbar v-model=\"snackbar.show\" :right=\"true\" :vertical=\"true\" :bottom=\"true\" color=\"primary\" :timeout=\"6000\">\n            {{ printf `{{ snackbar.text }}` }}\n            <v-btn dark flat @click=\"snackbarHide\">\n                Close\n            </v-btn>\n        </v-snackbar>\n    </div>\n</template>\n\n\n<script>\nimport { BreadClient } from \"@/services/service_bread_pb_service\";\nimport { Get{{ .Entity.Name}}Request } from \"@/services/service_bread_pb\";\nimport { Update{{ .Entity.Name}}Request } from \"@/services/service_bread_pb\";\nimport gTextfield from \"@/widgets/gTextfield.vue\";\nimport gImagefield from \"@/widgets/gImagefield.vue\";\nimport gCheckbox from \"@/widgets/gCheckbox.vue\";\nimport gIcon from \"@/widgets/gIcon.vue\";\n\nexport default {\n  data() {\n    return {\n      messages: [],   \n      snackbar: {\n          show: false, \n          text: ''\n      },\n      entity: null,\n      loading: false,\n      id: null\n    };\n  },\n  {{/*\n    The Code below tranforms into something like this. A computed property with custom getter and setters\n    computed: {\n        name: {\n        get: function() {\n            return this.entity.getName();\n        },\n        set: function(value) {\n            this.entity.setName(value);\n        }\n        }\n    },\n  */}}\n\n  components: {\n      gTextfield,\n      gImagefield,\n      gCheckbox,\n      gIcon\n  },\n  mounted() {\n    this.id = this.$route.params.id;\n    let cli = new BreadClient(\"/api\");\n    let req = new Get{{ .Entity.Name}}Request();\n    req.setId(this.id);\n\n    this.loading = true;\n\n    cli.get{{ .Entity.Name}}(req, (err, resp) => {\n        if (err) {\n            console.log(err);\n            return;\n        }\n        this.loading = false;\n        this.entity = resp.get{{ucfirst .Entity.Name}}();\n    });\n  },\n  methods: {\n        log: function(e) {\n            console.log(e)\n        },\n        update: function() {\n            let cli = new BreadClient(\"/api\");\n            let req = new Update{{.Entity.Name}}Request();\n            req.set{{ ucfirst .Entity.Name}}(this.entity);\n            this.loading = true;\n\n            this.snackbarShow('{{ucfirst .Entity.Name}} Saved');\n            this.debug();\n\n            cli.update{{.Entity.Name}}(req, (err, resp) => {\n                if (err) {\n                    console.log(err);\n                    this.loading = false;\n                    return;\n                }\n            });\n        },\n        debug: function() {\n            {{ range .Entity.Fields }}\n            console.log(\"{{.Property.Name}}\", this.entity.get{{ ucfirst .Property.Name }}());\n            {{end}}\n        },\n        snackbarShow: function(text, color) {\n            this.snackbar.show = true;\n            this.snackbar.color = color || 'info';\n            this.snackbar.text = text || 'something happened';\n        },\n        snackbarHide: function() {\n            this.snackbar.show = false\n        }\n  }\n};\n</script>\n\n<style lang=\"scss\" scoped>\n.gocipe-form-grid {\n  width: 100%;\n  max-width: 800px;\n  margin: 0 auto;\n  display: grid;\n  grid-template-columns: 1fr;\n  grid-column-gap: var(--gutter, 40px);\n  .gocipe-field-container {\n    // grid-column: 1/2;\n  }\n}\n</style>\n"),
	}
	file1w := &embedded.EmbeddedFile{
		Filename:    "vuetify/views/list.vue.tmpl",
		FileModTime: time.Unix(1534795419, 0),
		Content:     string("<template>\n    <div class=\"listing--container\">\n        <v-toolbar color=\"transparent\" class=\"listing-toolbar\" flat ml-0>\n            <v-btn icon>\n                <v-icon large>{{.Entity.Vuetify.Icon}}</v-icon>\n            </v-btn>\n            <v-toolbar-title class=\"ma-0 pa-0\">\n                <h2>{{.Entity.Name}}</h2>\n            </v-toolbar-title>\n            <v-spacer></v-spacer>\n            <v-btn mr-0 color=\"primary\" :to=\"{path: '{{plural (lower .Entity.Name) }}/edit'}\">\n                <v-icon dark>add</v-icon> Add\n            </v-btn>\n        </v-toolbar>\n\n        <!-- Error Messages -->\n        <v-alert :type=\"message.type==='E' ? 'error' : message.type\" :value=\"true\" v-for=\"(message, index) in messages\" :key=\"index\">\n            {{ \"{{ message.text }}\" }}\n        </v-alert>\n\n        <!-- Empty Check -->\n        <div v-if=\"loading\" centered>\n            <v-progress-linear :indeterminate=\"true\"></v-progress-linear>\n            <p class=\"text-xs-center\">contacting server...</p>\n        </div>\n        <v-alert type=\"info\" value=\"true\" color=\"primary\" outline icon=\"info\" v-else-if=\"entities.length===0 && !loading\">\n            No {{.Entity.Name}} exist. Would you like to create one now?\n            <v-btn color=\"primary\" :to=\"{path: '{{plural (lower .Entity.Name) }}/edit'}\">create new</v-btn>\n        </v-alert>\n\n        <!-- Table form listing -->\n        <template v-else>\n            <v-text-field mb-4 append-icon=\"search\" label=\"Search\" single-line hide-details v-model=\"search\"></v-text-field>\n            <v-data-table :headers=\"headers\" :items=\"entities\" class=\"elevation-1\" :search=\"search\">\n                <template slot=\"items\" slot-scope=\"props\">\n                    <td class=\"justify-center layout px-0\">\n                        <v-btn icon class=\"mx-0\" :to=\"{name: '{{plural (lower .Entity.Name )}}_edit', params:{ id: props.item.getId() }}\">\n                            <v-icon>edit</v-icon>\n                        </v-btn>\n                        <v-tooltip top>\n                            <v-btn slot=\"activator\" icon class=\"mx-0\" :to=\"{name: 'g_{{plural (lower .Entity.Name )}}_edit', params:{ id: props.item.getId() }}\">\n                                <v-icon>accessible_forward</v-icon>\n                            </v-btn>\n                            <span>Automatically generated Edit Form</span>\n                        </v-tooltip>\n                    </td>\n                    <!-- Check if it should appear in the list -->\n                    {{ range .Entity.Fields }} {{if not .ListWidget.Hide}}\n                    <!-- Use different rendering for dates -->\n                    {{ if eq .Property.Type \"time\" }}\n                    <td>\n                        <timeago :datetime=\"{{printf \" props.item.get%s().toDate() \" (ucfirst .Property.Name) }}\"></timeago>\n                    </td>\n                    {{- else -}}\n                    <!-- Use different rendering for dates -->\n                    {{if eq .ListWidget.Type \"image\"}}\n                    <td>\n                        <img :src=\"{{ printf \" props.item.get%s() \" (ucfirst .Property.Name) }} \" />\n                    </td>\n                    {{else}}\n                    <td>\n                        <v-tooltip top>\n                            <span slot=\"activator\">\n                                {{ printf \"{{ props.item.get%s()}}\" (ucfirst .Property.Name) }}\n                            </span>\n                            <span>Widget Type : {{ ucfirst .Property.Type}}</span>\n                        </v-tooltip>\n                    </td>\n                    {{end}} {{end}} {{end}} {{end}}\n                </template>\n\n                <template slot=\"no-data\">\n                    <v-flex ma-4>\n                        <v-alert slot=\"no-results\" :value=\"true\" color=\"primary\" outline icon=\"info\" v-if=\"search.length> 0\"> Your search for \"{{ \"{{ search }}\" }}\" found no results.\n                        </v-alert>\n                        <v-alert slot=\"no-results\" :value=\"true\" color=\"primary\" outline icon=\"info\" v-else>\n                            No {{.Entity.Name}} found.\n                        </v-alert>\n                    </v-flex>\n                </template>\n            </v-data-table>\n        </template>\n\n        <v-snackbar v-model=\"snackbar.show\" :right=\"true\" :bottom=\"true\" color=\"primary\" :timeout=\"2000\">\n            {{ printf `{{ snackbar.text }}` }}\n            <v-btn dark flat @click=\"snackbarHide\">\n                Close\n            </v-btn>\n        </v-snackbar>\n    </div>\n</template>\n\n<script>\nimport { BreadClient } from \"@/services/service_bread_pb_service\";\nimport { List{{plural .Entity.Name}}Request } from \"@/services/service_bread_pb\";\n\nexport default {\n  data() {\n    return {\n      messages: [],\n      search: \"\",\n      snackbar: {\n          show: false, \n          text: ''\n      },\n      text: \"hola\",\n      headers: [\n        {'text': 'Action', 'value': null, sortable: false, 'width': '80px'},\n\t\t{{range .Entity.Fields }}{{if not .ListWidget.Hide}}\n\t\t{text: \"{{.Label}}\", value: \"{{.Property.Name}}\"},\n\t\t{{end}}{{end}}\n      ],\n      entities: [],\n      loading: false\n    };\n  },\n  mounted() {\n    let cli = new BreadClient(\"/api\");\n    let req = new List{{plural .Entity.Name}}Request();\n    this.loading = true;\n\n    cli.list{{plural .Entity.Name}}(req, (err, resp) => {\n        if (err) {\n            console.log(err);\n            return;\n        }\n        this.loading = false;\n        this.snackbarShow('{{ucfirst (plural .Entity.Name)}} Loaded');\n        this.entities = resp.get{{ucfirst (plural .Entity.Name)}}List();\n    });\n  },\n  methods: {\n      create: function() {\n          let cli = new BreadClient(\"/api\");\n          let req = new Create{{.Entity.Name}}Request();\n          this.snackbarShow('Loading {{ucfirst (plural .Entity.Name)}}');\n          this.loading = true;\n\n           cli.create{{.Entity.Name}}(req, (err, resp) => {\n            if (err) {\n                console.log(err);\n                this.loading = false;\n                return;\n            }\n\n            this.$router.go({\n                name: \"{{plural .Entity.Name}}_edit\",\n                params: { id: resp.get{{.Entity.Name}}().getId() } \n            });\n        });\n      },\n      snackbarShow: function(text, color) {\n          this.snackbar.show = true;\n          this.snackbar.color = color || 'info';\n          this.snackbar.text = text || 'something happened';\n      },\n      snackbarHide: function() {\n          this.snackbar.show = false\n      }\n  }\n};\n</script>\n\n<style lang=\"scss\">\n.listing-toolbar .v-toolbar__content {\n  padding: 0;\n}\n\n.listing--container td {\n  img {\n    display: block !important;\n    height: 48px;\n    width: auto;\n  }\n}\n</style>\n\n\n<style lang=\"scss\" scoped>\n.bounce-enter-active {\n  animation: bounce-in 0.5s;\n}\n.bounce-leave-active {\n  animation: bounce-in 0.5s reverse;\n}\n@keyframes bounce-in {\n  0% {\n    transform: scale(0);\n  }\n  50% {\n    transform: scale(1.5);\n  }\n  100% {\n    transform: scale(1);\n  }\n}\n</style>\n"),
	}

	// define dirs
	dir1 := &embedded.EmbeddedDir{
		Filename:   "",
		DirModTime: time.Unix(1533812553, 0),
		ChildFiles: []*embedded.EmbeddedFile{
			filey,  // "http.go.tmpl"
			filez,  // "rest.go.tmpl"
			file10, // "rest_hooks.go.tmpl"

		},
	}
	dir2 := &embedded.EmbeddedDir{
		Filename:   "application",
		DirModTime: time.Unix(1534420769, 0),
		ChildFiles: []*embedded.EmbeddedFile{
			file3, // "application/gen-service.sh.tmpl"
			file4, // "application/main.go.tmpl"
			file5, // "application/makefile.tmpl"
			file6, // "application/route.go.tmpl"

		},
	}
	dir7 := &embedded.EmbeddedDir{
		Filename:   "bootstrap",
		DirModTime: time.Unix(1533812553, 0),
		ChildFiles: []*embedded.EmbeddedFile{
			file8, // "bootstrap/bootstrap.go.tmpl"
			file9, // "bootstrap/env.tmpl"

		},
	}
	dira := &embedded.EmbeddedDir{
		Filename:   "bread",
		DirModTime: time.Unix(1534420769, 0),
		ChildFiles: []*embedded.EmbeddedFile{
			fileb, // "bread/service_bread.gocipe.go.tmpl"
			filec, // "bread/service_bread.proto.tmpl"
			filed, // "bread/service_bread_hooks.go.tmpl"

		},
	}
	dire := &embedded.EmbeddedDir{
		Filename:   "crud",
		DirModTime: time.Unix(1534490268, 0),
		ChildFiles: []*embedded.EmbeddedFile{
			filef, // "crud/crud.go.tmpl"
			fileg, // "crud/hooks.go.tmpl"
			fileh, // "crud/models.go.tmpl"
			filei, // "crud/moderrors.go.tmpl"
			filex, // "crud/protobuf.proto.tmpl"

		},
	}
	dirj := &embedded.EmbeddedDir{
		Filename:   "crud/partials",
		DirModTime: time.Unix(1534795470, 0),
		ChildFiles: []*embedded.EmbeddedFile{
			filek, // "crud/partials/delete_many.go.tmpl"
			filel, // "crud/partials/delete_single.go.tmpl"
			filem, // "crud/partials/get.go.tmpl"
			filen, // "crud/partials/insert.go.tmpl"
			fileo, // "crud/partials/list.go.tmpl"
			filep, // "crud/partials/loadrelated_manymany.go.tmpl"
			fileq, // "crud/partials/loadrelated_manyone.go.tmpl"
			filer, // "crud/partials/loadrelated_onemany.go.tmpl"
			files, // "crud/partials/merge.go.tmpl"
			filet, // "crud/partials/save.go.tmpl"
			fileu, // "crud/partials/saverelated_manymany.go.tmpl"
			filev, // "crud/partials/saverelated_onemany.go.tmpl"
			filew, // "crud/partials/update.go.tmpl"

		},
	}
	dir11 := &embedded.EmbeddedDir{
		Filename:   "schema",
		DirModTime: time.Unix(1533812553, 0),
		ChildFiles: []*embedded.EmbeddedFile{
			file12, // "schema/schema.sql.tmpl"

		},
	}
	dir13 := &embedded.EmbeddedDir{
		Filename:   "util",
		DirModTime: time.Unix(1534490495, 0),
		ChildFiles: []*embedded.EmbeddedFile{
			file14, // "util/credentials.go.tmpl"
			file15, // "util/files.go.tmpl"
			file16, // "util/rice.go.tmpl"
			file17, // "util/util.go.tmpl"
			file18, // "util/web.go.tmpl"
			file19, // "util/ws.go.tmpl"

		},
	}
	dir1a := &embedded.EmbeddedDir{
		Filename:   "vuetify",
		DirModTime: time.Unix(1533709790, 0),
		ChildFiles: []*embedded.EmbeddedFile{},
	}
	dir1b := &embedded.EmbeddedDir{
		Filename:   "vuetify/js",
		DirModTime: time.Unix(1534330498, 0),
		ChildFiles: []*embedded.EmbeddedFile{
			file1c, // "vuetify/js/actions.js.tmpl"
			file1d, // "vuetify/js/getters.js.tmpl"
			file1e, // "vuetify/js/index.js.tmpl"
			file1f, // "vuetify/js/mutations.js.tmpl"
			file1g, // "vuetify/js/routes.js.tmpl"
			file1h, // "vuetify/js/types.js.tmpl"

		},
	}
	dir1i := &embedded.EmbeddedDir{
		Filename:   "vuetify/old",
		DirModTime: time.Unix(1533709790, 0),
		ChildFiles: []*embedded.EmbeddedFile{
			file1j, // "vuetify/old/vuetify_edit.vue.tmpl"
			file1k, // "vuetify/old/vuetify_editor-field-checkbox.vue.tmpl"
			file1l, // "vuetify/old/vuetify_editor-field-date.vue.tmpl"
			file1m, // "vuetify/old/vuetify_editor-field-number.vue.tmpl"
			file1n, // "vuetify/old/vuetify_editor-field-password.vue.tmpl"
			file1o, // "vuetify/old/vuetify_editor-field-select-rel.vue.tmpl"
			file1p, // "vuetify/old/vuetify_editor-field-select.vue.tmpl"
			file1q, // "vuetify/old/vuetify_editor-field-textarea.vue.tmpl"
			file1r, // "vuetify/old/vuetify_editor-field-textfield.vue.tmpl"
			file1s, // "vuetify/old/vuetify_editor-field-time.vue.tmpl"
			file1t, // "vuetify/old/vuetify_editor-field-toggle.vue.tmpl"

		},
	}
	dir1u := &embedded.EmbeddedDir{
		Filename:   "vuetify/views",
		DirModTime: time.Unix(1534795419, 0),
		ChildFiles: []*embedded.EmbeddedFile{
			file1v, // "vuetify/views/edit.vue.tmpl"
			file1w, // "vuetify/views/list.vue.tmpl"

		},
	}

	// link ChildDirs
	dir1.ChildDirs = []*embedded.EmbeddedDir{
		dir2,  // "application"
		dir7,  // "bootstrap"
		dira,  // "bread"
		dire,  // "crud"
		dir11, // "schema"
		dir13, // "util"
		dir1a, // "vuetify"

	}
	dir2.ChildDirs = []*embedded.EmbeddedDir{}
	dir7.ChildDirs = []*embedded.EmbeddedDir{}
	dira.ChildDirs = []*embedded.EmbeddedDir{}
	dire.ChildDirs = []*embedded.EmbeddedDir{
		dirj, // "crud/partials"

	}
	dirj.ChildDirs = []*embedded.EmbeddedDir{}
	dir11.ChildDirs = []*embedded.EmbeddedDir{}
	dir13.ChildDirs = []*embedded.EmbeddedDir{}
	dir1a.ChildDirs = []*embedded.EmbeddedDir{
		dir1b, // "vuetify/js"
		dir1i, // "vuetify/old"
		dir1u, // "vuetify/views"

	}
	dir1b.ChildDirs = []*embedded.EmbeddedDir{}
	dir1i.ChildDirs = []*embedded.EmbeddedDir{}
	dir1u.ChildDirs = []*embedded.EmbeddedDir{}

	// register embeddedBox
	embedded.RegisterEmbeddedBox(`templates`, &embedded.EmbeddedBox{
		Name: `templates`,
		Time: time.Unix(1533812553, 0),
		Dirs: map[string]*embedded.EmbeddedDir{
			"":              dir1,
			"application":   dir2,
			"bootstrap":     dir7,
			"bread":         dira,
			"crud":          dire,
			"crud/partials": dirj,
			"schema":        dir11,
			"util":          dir13,
			"vuetify":       dir1a,
			"vuetify/js":    dir1b,
			"vuetify/old":   dir1i,
			"vuetify/views": dir1u,
		},
		Files: map[string]*embedded.EmbeddedFile{
			"application/gen-service.sh.tmpl":                      file3,
			"application/main.go.tmpl":                             file4,
			"application/makefile.tmpl":                            file5,
			"application/route.go.tmpl":                            file6,
			"bootstrap/bootstrap.go.tmpl":                          file8,
			"bootstrap/env.tmpl":                                   file9,
			"bread/service_bread.gocipe.go.tmpl":                   fileb,
			"bread/service_bread.proto.tmpl":                       filec,
			"bread/service_bread_hooks.go.tmpl":                    filed,
			"crud/crud.go.tmpl":                                    filef,
			"crud/hooks.go.tmpl":                                   fileg,
			"crud/models.go.tmpl":                                  fileh,
			"crud/moderrors.go.tmpl":                               filei,
			"crud/partials/delete_many.go.tmpl":                    filek,
			"crud/partials/delete_single.go.tmpl":                  filel,
			"crud/partials/get.go.tmpl":                            filem,
			"crud/partials/insert.go.tmpl":                         filen,
			"crud/partials/list.go.tmpl":                           fileo,
			"crud/partials/loadrelated_manymany.go.tmpl":           filep,
			"crud/partials/loadrelated_manyone.go.tmpl":            fileq,
			"crud/partials/loadrelated_onemany.go.tmpl":            filer,
			"crud/partials/merge.go.tmpl":                          files,
			"crud/partials/save.go.tmpl":                           filet,
			"crud/partials/saverelated_manymany.go.tmpl":           fileu,
			"crud/partials/saverelated_onemany.go.tmpl":            filev,
			"crud/partials/update.go.tmpl":                         filew,
			"crud/protobuf.proto.tmpl":                             filex,
			"http.go.tmpl":                                         filey,
			"rest.go.tmpl":                                         filez,
			"rest_hooks.go.tmpl":                                   file10,
			"schema/schema.sql.tmpl":                               file12,
			"util/credentials.go.tmpl":                             file14,
			"util/files.go.tmpl":                                   file15,
			"util/rice.go.tmpl":                                    file16,
			"util/util.go.tmpl":                                    file17,
			"util/web.go.tmpl":                                     file18,
			"util/ws.go.tmpl":                                      file19,
			"vuetify/js/actions.js.tmpl":                           file1c,
			"vuetify/js/getters.js.tmpl":                           file1d,
			"vuetify/js/index.js.tmpl":                             file1e,
			"vuetify/js/mutations.js.tmpl":                         file1f,
			"vuetify/js/routes.js.tmpl":                            file1g,
			"vuetify/js/types.js.tmpl":                             file1h,
			"vuetify/old/vuetify_edit.vue.tmpl":                    file1j,
			"vuetify/old/vuetify_editor-field-checkbox.vue.tmpl":   file1k,
			"vuetify/old/vuetify_editor-field-date.vue.tmpl":       file1l,
			"vuetify/old/vuetify_editor-field-number.vue.tmpl":     file1m,
			"vuetify/old/vuetify_editor-field-password.vue.tmpl":   file1n,
			"vuetify/old/vuetify_editor-field-select-rel.vue.tmpl": file1o,
			"vuetify/old/vuetify_editor-field-select.vue.tmpl":     file1p,
			"vuetify/old/vuetify_editor-field-textarea.vue.tmpl":   file1q,
			"vuetify/old/vuetify_editor-field-textfield.vue.tmpl":  file1r,
			"vuetify/old/vuetify_editor-field-time.vue.tmpl":       file1s,
			"vuetify/old/vuetify_editor-field-toggle.vue.tmpl":     file1t,
			"vuetify/views/edit.vue.tmpl":                          file1v,
			"vuetify/views/list.vue.tmpl":                          file1w,
		},
	})
}
